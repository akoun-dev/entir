{
  "name": "Base",
  "version": "1.3",
  "dependencies": [],
  "models": [
    {
      "name": "avatar.mixin",
      "description": "Avatar Mixin",
      "fields": [
        {
          "name": "avatar_1920",
          "type": "Image"
        },
        {
          "name": "avatar_1024",
          "type": "Image"
        },
        {
          "name": "avatar_512",
          "type": "Image"
        },
        {
          "name": "avatar_256",
          "type": "Image"
        },
        {
          "name": "avatar_128",
          "type": "Image"
        }
      ],
      "methods": [
        {
          "name": "_compute_avatar",
          "params": [
            "self",
            "avatar_field",
            "image_field"
          ],
          "decorators": [],
          "source": "def _compute_avatar(self, avatar_field, image_field):\n        for record in self:\n            avatar = record[image_field]\n            if not avatar:\n                if record.id and record[record._avatar_name_field]:\n                    avatar = record._avatar_generate_svg()\n                else:\n                    avatar = b64encode(record._avatar_get_placeholder())\n            record[avatar_field] = avatar",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_1920",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_1920(self):\n        self._compute_avatar('avatar_1920', 'image_1920')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_1024",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_1024(self):\n        self._compute_avatar('avatar_1024', 'image_1024')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_512",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_512(self):\n        self._compute_avatar('avatar_512', 'image_512')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_256",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_256(self):\n        self._compute_avatar('avatar_256', 'image_256')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_128",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_128(self):\n        self._compute_avatar('avatar_128', 'image_128')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_avatar_generate_svg",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _avatar_generate_svg(self):\n        initial = html_escape(self[self._avatar_name_field][0].upper())\n        bgcolor = get_hsl_from_seed(self[self._avatar_name_field] + str(self.create_date.timestamp() if self.create_date else \"\"))\n        return b64encode((\n            \"<?xml version='1.0' encoding='UTF-8' ?>\"\n            \"<svg height='180' width='180' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>\"\n            f\"<rect fill='{bgcolor}' height='180' width='180'/>\"\n            f\"<text fill='#ffffff' font-size='96' text-anchor='middle' x='90' y='125' font-family='sans-serif'>{initial}</text>\"\n            \"</svg>\"\n        ).encode())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_avatar_get_placeholder_path",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _avatar_get_placeholder_path(self):\n        return \"base/static/img/avatar_grey.png\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_avatar_get_placeholder",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _avatar_get_placeholder(self):\n        return file_open(self._avatar_get_placeholder_path(), 'rb').read()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "AvatarMixin"
    },
    {
      "name": "decimal.precision",
      "description": "Decimal Precision",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "digits",
          "type": "Integer",
          "required": true
        }
      ],
      "methods": [
        {
          "name": "precision_get",
          "params": [
            "self",
            "application"
          ],
          "decorators": [],
          "source": "def precision_get(self, application):\n        self.flush_model(['name', 'digits'])\n        self.env.cr.execute('select digits from decimal_precision where name=%s', (application,))\n        res = self.env.cr.fetchone()\n        return res[0] if res else 2",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        res = super(DecimalPrecision, self).create(vals_list)\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "data"
          ],
          "decorators": [],
          "source": "def write(self, data):\n        res = super(DecimalPrecision, self).write(data)\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        res = super(DecimalPrecision, self).unlink()\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_digits_warning",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_digits_warning(self):\n        if self.digits < self._origin.digits:\n            return {\n                'warning': {\n                    'title': _(\"Warning for %s\", self.name),\n                    'message': _(\n                        \"The precision has been reduced for %s.\\n\"\n                        \"Note that existing data WON'T be updated by this change.\\n\\n\"\n                        \"As decimal precisions impact the whole system, this may cause critical issues.\\n\"\n                        \"E.g. reducing the precision could disturb your financial balance.\\n\\n\"\n                        \"Therefore, changing decimal precisions in a running database is not recommended.\",\n                        self.name,\n                    )\n                }\n            }\n\n# compatibility for decimal_precision.get_precision(): expose the module in addons namespace\ndp = sys.modules['odoo.addons.base.models.decimal_precision']\nodoo.addons.decimal_precision = dp\nsys.modules['odoo.addons.decimal_precision'] = dp\nsys.modules['openerp.addons.decimal_precision'] = dp",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "DecimalPrecision"
    },
    {
      "name": "image.mixin",
      "description": "Image Mixin",
      "fields": [
        {
          "name": "image_1920",
          "type": "Image"
        },
        {
          "name": "image_1024",
          "type": "Image"
        },
        {
          "name": "image_512",
          "type": "Image"
        },
        {
          "name": "image_256",
          "type": "Image"
        },
        {
          "name": "image_128",
          "type": "Image"
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ImageMixin"
    },
    {
      "name": "ir.actions.actions",
      "description": "Actions",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Action Name"
        },
        {
          "name": "type",
          "type": "Char",
          "required": true,
          "string": "Action Type"
        },
        {
          "name": "xml_id",
          "type": "Char",
          "string": "External ID"
        },
        {
          "name": "help",
          "type": "Html",
          "string": "Action Description",
          "help": "Optional help text for the users with a description of the target view, such as its usage and purpose."
        },
        {
          "name": "binding_model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "help": "Setting a value makes this action available in the sidebar for the given model."
        },
        {
          "name": "binding_type",
          "type": "Selection"
        },
        {
          "name": "binding_view_types",
          "type": "Char"
        }
      ],
      "methods": [
        {
          "name": "_compute_xml_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_xml_id(self):\n        res = self.get_external_id()\n        for record in self:\n            record.xml_id = res.get(record.id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        res = super(IrActions, self).create(vals_list)\n        # self.get_bindings() depends on action records\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        res = super(IrActions, self).write(vals)\n        # self.get_bindings() depends on action records\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        \"\"\"unlink ir.action.todo/ir.filters which are related to actions which will be deleted.\n           NOTE: ondelete cascade will not work on ir.actions.actions so we will need to do it manually.\"\"\"\n        todos = self.env['ir.actions.todo'].search([('action_id', 'in', self.ids)])\n        todos.unlink()\n        filters = self.env['ir.filters'].search([('action_id', 'in', self.ids)])\n        filters.unlink()\n        res = super(IrActions, self).unlink()\n        # self.get_bindings() depends on action records\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_check_home_action",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_check_home_action(self):\n        self.env['res.users'].with_context(active_test=False).search([('action_id', 'in', self.ids)]).sudo().write({'action_id': None})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_eval_context",
          "params": [
            "self",
            "action=None"
          ],
          "decorators": [],
          "source": "def _get_eval_context(self, action=None):\n        \"\"\" evaluation context to pass to safe_eval \"\"\"\n        return {\n            'uid': self._uid,\n            'user': self.env.user,\n            'time': tools.safe_eval.time,\n            'datetime': tools.safe_eval.datetime,\n            'dateutil': tools.safe_eval.dateutil,\n            'timezone': timezone,\n            'float_compare': float_compare,\n            'b64encode': base64.b64encode,\n            'b64decode': base64.b64decode,\n            'Command': Command,\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_bindings",
          "params": [
            "self",
            "model_name"
          ],
          "decorators": [],
          "source": "def get_bindings(self, model_name):\n        \"\"\" Retrieve the list of actions bound to the given model.\n\n           :return: a dict mapping binding types to a list of dict describing\n                    actions, where the latter is given by calling the method\n                    ``read`` on the action record.\n        \"\"\"\n        result = {}\n        for action_type, all_actions in self._get_bindings(model_name).items():\n            actions = []\n            for action in all_actions:\n                action = dict(action)\n                groups = action.pop('groups_id', None)\n                if groups and not self.user_has_groups(groups):\n                    # the user may not perform this action\n                    continue\n                res_model = action.pop('res_model', None)\n                if res_model and not self.env['ir.model.access'].check(\n                    res_model,\n                    mode='read',\n                    raise_exception=False\n                ):\n                    # the user won't be able to read records\n                    continue\n                actions.append(action)\n            if actions:\n                result[action_type] = actions\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_bindings",
          "params": [
            "self",
            "model_name"
          ],
          "decorators": [],
          "source": "def _get_bindings(self, model_name):\n        cr = self.env.cr\n\n        # discard unauthorized actions, and read action definitions\n        result = defaultdict(list)\n\n        self.env.flush_all()\n        cr.execute(\"\"\"\n            SELECT a.id, a.type, a.binding_type\n              FROM ir_actions a\n              JOIN ir_model m ON a.binding_model_id = m.id\n             WHERE m.model = %s\n          ORDER BY a.id\n        \"\"\", [model_name])\n        for action_id, action_model, binding_type in cr.fetchall():\n            try:\n                action = self.env[action_model].sudo().browse(action_id)\n                fields = ['name', 'binding_view_types']\n                for field in ('groups_id', 'res_model', 'sequence'):\n                    if field in action._fields:\n                        fields.append(field)\n                action = action.read(fields)[0]\n                if action.get('groups_id'):\n                    groups = self.env['res.groups'].browse(action['groups_id'])\n                    action['groups_id'] = ','.join(ext_id for ext_id in groups._ensure_xml_id().values())\n                result[binding_type].append(frozendict(action))\n            except (MissingError):\n                continue\n\n        # sort actions by their sequence if sequence available\n        if result.get('action'):\n            result['action'] = tuple(sorted(result['action'], key=lambda vals: vals.get('sequence', 0)))\n        return frozendict(result)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_for_xml_id",
          "params": [
            "self",
            "full_xml_id"
          ],
          "decorators": [],
          "source": "def _for_xml_id(self, full_xml_id):\n        \"\"\" Returns the action content for the provided xml_id\n\n        :param xml_id: the namespace-less id of the action (the @id\n                       attribute from the XML file)\n        :return: A read() view of the ir.actions.action safe for web use\n        \"\"\"\n        record = self.env.ref(full_xml_id)\n        assert isinstance(self.env[record._name], self.env.registry[self._name])\n        return record._get_action_dict()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_action_dict",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_action_dict(self):\n        \"\"\" Returns the action content for the provided action record.\n        \"\"\"\n        self.ensure_one()\n        readable_fields = self._get_readable_fields()\n        return {\n            field: value\n            for field, value in self.sudo().read()[0].items()\n            if field in readable_fields\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_readable_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_readable_fields(self):\n        \"\"\" return the list of fields that are safe to read\n\n        Fetched via /web/action/load or _for_xml_id method\n        Only fields used by the web client should included\n        Accessing content useful for the server-side must\n        be done manually with superuser\n        \"\"\"\n        return {\n            \"binding_model_id\", \"binding_type\", \"binding_view_types\",\n            \"display_name\", \"help\", \"id\", \"name\", \"type\", \"xml_id\",\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_eval_context (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_bindings (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_for_xml_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrActions"
    },
    {
      "name": "ir.actions.act_window",
      "description": "Action Window",
      "fields": [
        {
          "name": "type",
          "type": "Char"
        },
        {
          "name": "view_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "string": "View Ref."
        },
        {
          "name": "domain",
          "type": "Char",
          "string": "Domain Value",
          "help": "Optional domain filtering of the destination data, as a Python expression"
        },
        {
          "name": "context",
          "type": "Char",
          "required": true,
          "string": "Context Value"
        },
        {
          "name": "res_id",
          "type": "Integer",
          "string": "Record ID",
          "help": "Database ID of record to open in form view, when ``view_mode`` is set to "
        },
        {
          "name": "res_model",
          "type": "Char",
          "required": true,
          "string": "Destination Model",
          "help": "Model name of the object to open in the view window"
        },
        {
          "name": "target",
          "type": "Selection"
        },
        {
          "name": "view_mode",
          "type": "Char",
          "required": true,
          "help": "Comma-separated list of allowed view modes, such as "
        },
        {
          "name": "mobile_view_mode",
          "type": "Char",
          "help": "First view mode in mobile and small screen environments (default="
        },
        {
          "name": "usage",
          "type": "Char",
          "string": "Action Usage",
          "help": "Used to filter menu and home actions from the user form."
        },
        {
          "name": "view_ids",
          "type": "One2many",
          "relation": "ir.actions.act_window.view",
          "string": "No of Views"
        },
        {
          "name": "views",
          "type": "Binary",
          "help": "This function field computes the ordered list of views that should be enabled "
        },
        {
          "name": "limit",
          "type": "Integer",
          "help": "Default limit for the list view"
        },
        {
          "name": "groups_id",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Groups"
        },
        {
          "name": "search_view_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "string": "Search View Ref."
        },
        {
          "name": "filter",
          "type": "Boolean"
        }
      ],
      "methods": [
        {
          "name": "_check_model",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_model(self):\n        for action in self:\n            if action.res_model not in self.env:\n                raise ValidationError(_('Invalid model name %r in action definition.', action.res_model))\n            if action.binding_model_id and action.binding_model_id.model not in self.env:\n                raise ValidationError(_('Invalid model name %r in action definition.', action.binding_model_id.model))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_views",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_views(self):\n        \"\"\" Compute an ordered list of the specific view modes that should be\n            enabled when displaying the result of this action, along with the\n            ID of the specific view to use for each mode, if any were required.\n\n            This function hides the logic of determining the precedence between\n            the view_modes string, the view_ids o2m, and the view_id m2o that\n            can be set on the action.\n        \"\"\"\n        for act in self:\n            act.views = [(view.view_id.id, view.view_mode) for view in act.view_ids]\n            got_modes = [view.view_mode for view in act.view_ids]\n            all_modes = act.view_mode.split(',')\n            missing_modes = [mode for mode in all_modes if mode not in got_modes]\n            if missing_modes:\n                if act.view_id.type in missing_modes:\n                    # reorder missing modes to put view_id first if present\n                    missing_modes.remove(act.view_id.type)\n                    act.views.append((act.view_id.id, act.view_id.type))\n                act.views.extend([(False, mode) for mode in missing_modes])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_view_mode",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_view_mode(self):\n        for rec in self:\n            modes = rec.view_mode.split(',')\n            if len(modes) != len(set(modes)):\n                raise ValidationError(_('The modes in view_mode must not be duplicated: %s', modes))\n            if ' ' in modes:\n                raise ValidationError(_('No spaces allowed in view_mode: %r', modes))\n\n    type = fields.Char(default=\"ir.actions.act_window\")\n    view_id = fields.Many2one('ir.ui.view', string='View Ref.', ondelete='set null')\n    domain = fields.Char(string='Domain Value',\n                         help=\"Optional domain filtering of the destination data, as a Python expression\")\n    context = fields.Char(string='Context Value', default={}, required=True,\n                          help=\"Context dictionary as Python expression, empty by default (Default: {})\")\n    res_id = fields.Integer(string='Record ID', help=\"Database ID of record to open in form view, when ``view_mode`` is set to 'form' only\")\n    res_model = fields.Char(string='Destination Model', required=True,\n                            help=\"Model name of the object to open in the view window\")\n    target = fields.Selection([('current', 'Current Window'), ('new', 'New Window'), ('inline', 'Inline Edit'), ('fullscreen', 'Full Screen'), ('main', 'Main action of Current Window')], default=\"current\", string='Target Window')\n    view_mode = fields.Char(required=True, default='tree,form',\n                            help=\"Comma-separated list of allowed view modes, such as 'form', 'tree', 'calendar', etc. (Default: tree,form)\")\n    mobile_view_mode = fields.Char(default=\"kanban\", help=\"First view mode in mobile and small screen environments (default='kanban'). If it can't be found among available view modes, the same mode as for wider screens is used)\")\n    usage = fields.Char(string='Action Usage',\n                        help=\"Used to filter menu and home actions from the user form.\")\n    view_ids = fields.One2many('ir.actions.act_window.view', 'act_window_id', string='No of Views')\n    views = fields.Binary(compute='_compute_views',\n                          help=\"This function field computes the ordered list of views that should be enabled \" \\\n                               \"when displaying the result of an action, federating view mode, views and \" \\\n                               \"reference view. The result is returned as an ordered list of pairs (view_id,view_mode).\")\n    limit = fields.Integer(default=80, help='Default limit for the list view')\n    groups_id = fields.Many2many('res.groups', 'ir_act_window_group_rel',\n                                 'act_id', 'gid', string='Groups')\n    search_view_id = fields.Many2one('ir.ui.view', string='Search View Ref.')\n    filter = fields.Boolean()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "read",
          "params": [
            "self",
            "fields=None",
            "load='_classic_read'"
          ],
          "decorators": [],
          "source": "def read(self, fields=None, load='_classic_read'):\n        \"\"\" call the method get_empty_list_help of the model and set the window action help message\n        \"\"\"\n        result = super(IrActionsActWindow, self).read(fields, load=load)\n        if not fields or 'help' in fields:\n            for values in result:\n                model = values.get('res_model')\n                if model in self.env:\n                    eval_ctx = dict(self.env.context)\n                    try:\n                        ctx = safe_eval(values.get('context', '{}'), eval_ctx)\n                    except:\n                        ctx = {}\n                    values['help'] = self.with_context(**ctx).env[model].get_empty_list_help(values.get('help', ''))\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.env.registry.clear_cache()\n        for vals in vals_list:\n            if not vals.get('name') and vals.get('res_model'):\n                vals['name'] = self.env[vals['res_model']]._description\n        return super(IrActionsActWindow, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self.env.registry.clear_cache()\n        return super(IrActionsActWindow, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "exists",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def exists(self):\n        ids = self._existing()\n        existing = self.filtered(lambda rec: rec.id in ids)\n        return existing",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_existing",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _existing(self):\n        self._cr.execute(\"SELECT id FROM %s\" % self._table)\n        return set(row[0] for row in self._cr.fetchall())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_readable_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_readable_fields(self):\n        return super()._get_readable_fields() | {\n            \"context\", \"mobile_view_mode\", \"domain\", \"filter\", \"groups_id\", \"limit\",\n            \"res_id\", \"res_model\", \"search_view_id\", \"target\", \"view_id\", \"view_mode\", \"views\",\n            # `flags` is not a real field of ir.actions.act_window but is used\n            # to give the parameters to generate the action\n            \"flags\"\n        }\n\n\nVIEW_TYPES = [\n    ('tree', 'Tree'),\n    ('form', 'Form'),\n    ('graph', 'Graph'),\n    ('pivot', 'Pivot'),\n    ('calendar', 'Calendar'),\n    ('gantt', 'Gantt'),\n    ('kanban', 'Kanban'),\n]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.actions.actions"
        }
      ],
      "constraints": [
        {
          "type": "python",
          "name": "_check_model",
          "definition": "@api.constrains('res_model', 'binding_model_id')\n    def _check_model(self):\n        for action in self:\n            if action.res_model not in self.env:\n                raise ValidationError(_('Invalid model name %r in action definition.', action.res_model))\n            if action.binding_model_id and action.binding_model_id.model not in self.env:\n                raise ValidationError(_('Invalid model name %r in action definition.', action.binding_model_id.model))",
          "message": "'res_model', 'binding_model_id'"
        },
        {
          "type": "python",
          "name": "_check_view_mode",
          "definition": "@api.constrains('view_mode')\n    def _check_view_mode(self):\n        for rec in self:\n            modes = rec.view_mode.split(',')\n            if len(modes) != len(set(modes)):\n                raise ValidationError(_('The modes in view_mode must not be duplicated: %s', modes))\n            if ' ' in modes:\n                raise ValidationError(_('No spaces allowed in view_mode: %r', modes))\n\n    type = fields.Char(default=\"ir.actions.act_window\")\n    view_id = fields.Many2one('ir.ui.view', string='View Ref.', ondelete='set null')\n    domain = fields.Char(string='Domain Value',\n                         help=\"Optional domain filtering of the destination data, as a Python expression\")\n    context = fields.Char(string='Context Value', default={}, required=True,\n                          help=\"Context dictionary as Python expression, empty by default (Default: {})\")\n    res_id = fields.Integer(string='Record ID', help=\"Database ID of record to open in form view, when ``view_mode`` is set to 'form' only\")\n    res_model = fields.Char(string='Destination Model', required=True,\n                            help=\"Model name of the object to open in the view window\")\n    target = fields.Selection([('current', 'Current Window'), ('new', 'New Window'), ('inline', 'Inline Edit'), ('fullscreen', 'Full Screen'), ('main', 'Main action of Current Window')], default=\"current\", string='Target Window')\n    view_mode = fields.Char(required=True, default='tree,form',\n                            help=\"Comma-separated list of allowed view modes, such as 'form', 'tree', 'calendar', etc. (Default: tree,form)\")\n    mobile_view_mode = fields.Char(default=\"kanban\", help=\"First view mode in mobile and small screen environments (default='kanban'). If it can't be found among available view modes, the same mode as for wider screens is used)\")\n    usage = fields.Char(string='Action Usage',\n                        help=\"Used to filter menu and home actions from the user form.\")\n    view_ids = fields.One2many('ir.actions.act_window.view', 'act_window_id', string='No of Views')\n    views = fields.Binary(compute='_compute_views',\n                          help=\"This function field computes the ordered list of views that should be enabled \" \\\n                               \"when displaying the result of an action, federating view mode, views and \" \\\n                               \"reference view. The result is returned as an ordered list of pairs (view_id,view_mode).\")\n    limit = fields.Integer(default=80, help='Default limit for the list view')\n    groups_id = fields.Many2many('res.groups', 'ir_act_window_group_rel',\n                                 'act_id', 'gid', string='Groups')\n    search_view_id = fields.Many2one('ir.ui.view', string='Search View Ref.')\n    filter = fields.Boolean()",
          "message": "'view_mode'"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrActionsActWindow"
    },
    {
      "name": "ir.actions.act_window.view",
      "description": "Action Window View",
      "fields": [
        {
          "name": "sequence",
          "type": "Integer"
        },
        {
          "name": "view_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "string": "View"
        },
        {
          "name": "view_mode",
          "type": "Selection",
          "required": true,
          "string": "View Type"
        },
        {
          "name": "act_window_id",
          "type": "Many2one",
          "relation": "ir.actions.act_window",
          "string": "Action"
        },
        {
          "name": "multi",
          "type": "Boolean",
          "string": "On Multiple Doc.",
          "help": "If set to true, the action will not be displayed on the right toolbar of a form view."
        }
      ],
      "methods": [
        {
          "name": "_auto_init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _auto_init(self):\n        res = super(IrActionsActWindowView, self)._auto_init()\n        tools.create_unique_index(self._cr, 'act_window_view_unique_mode_per_action',\n                                  self._table, ['act_window_id', 'view_mode'])\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "IrActionsActWindowView"
    },
    {
      "name": "ir.actions.act_window_close",
      "description": "Action Window Close",
      "fields": [
        {
          "name": "type",
          "type": "Char"
        }
      ],
      "methods": [
        {
          "name": "_get_readable_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_readable_fields(self):\n        return super()._get_readable_fields() | {\n            # 'effect' and 'infos' are not real fields of `ir.actions.act_window_close` but they are\n            # used to display the rainbowman ('effect') and waited by the action_service ('infos').\n            \"effect\", \"infos\"\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.actions.actions"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "IrActionsActWindowclose"
    },
    {
      "name": "ir.actions.act_url",
      "description": "Action URL",
      "fields": [
        {
          "name": "type",
          "type": "Char"
        },
        {
          "name": "url",
          "type": "Text",
          "required": true,
          "string": "Action URL"
        },
        {
          "name": "target",
          "type": "Selection"
        }
      ],
      "methods": [
        {
          "name": "_get_readable_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_readable_fields(self):\n        return super()._get_readable_fields() | {\n            \"target\", \"url\", \"close\",\n        }\n\nWEBHOOK_SAMPLE_VALUES = {\n    \"integer\": 42,\n    \"float\": 42.42,\n    \"monetary\": 42.42,\n    \"char\": \"Hello World\",\n    \"text\": \"Hello World\",\n    \"html\": \"<p>Hello World</p>\",\n    \"boolean\": True,\n    \"selection\": \"option1\",\n    \"date\": \"2020-01-01\",\n    \"datetime\": \"2020-01-01 00:00:00\",\n    \"binary\": \"<base64_data>\",\n    \"many2one\": 47,\n    \"many2many\": [42, 47],\n    \"one2many\": [42, 47],\n    \"reference\": \"res.partner,42\",\n    None: \"some_data\",\n}",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.actions.actions"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "IrActionsActUrl"
    },
    {
      "name": "ir.actions.server",
      "description": "Server Actions",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "type",
          "type": "Char"
        },
        {
          "name": "usage",
          "type": "Selection"
        },
        {
          "name": "state",
          "type": "Selection"
        },
        {
          "name": "sequence",
          "type": "Integer",
          "help": "When dealing with multiple actions, the execution order is "
        },
        {
          "name": "model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true,
          "string": "Model",
          "help": "Model on which the server action runs."
        },
        {
          "name": "available_model_ids",
          "type": "Many2many",
          "relation": "ir.model",
          "string": "Available Models"
        },
        {
          "name": "model_name",
          "type": "Char",
          "readonly": true,
          "string": "Model Name"
        },
        {
          "name": "code",
          "type": "Text",
          "string": "Python Code",
          "help": "Write Python code that the action will execute. Some variables are "
        },
        {
          "name": "child_ids",
          "type": "Many2many",
          "relation": "ir.actions.server",
          "string": "Child Actions",
          "help": "Child server actions that will be executed. Note that the last return returned action value will be used as global return value."
        },
        {
          "name": "crud_model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "string": "Record to Create",
          "help": "Specify which kind of record should be created. Set this field only to specify a different model than the base model."
        },
        {
          "name": "crud_model_name",
          "type": "Char",
          "readonly": true,
          "string": "Target Model Name"
        },
        {
          "name": "link_field_id",
          "type": "Many2one",
          "relation": "ir.model.fields",
          "string": "Link Field",
          "help": "Specify a field used to link the newly created record on the record used by the server action."
        },
        {
          "name": "groups_id",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Allowed Groups",
          "help": "Groups that can execute the server action. Leave empty to allow everybody."
        },
        {
          "name": "update_field_id",
          "type": "Many2one",
          "relation": "ir.model.fields",
          "string": "Field to Update"
        },
        {
          "name": "update_path",
          "type": "Char",
          "string": "Field to Update Path",
          "help": "Path to the field to update, e.g. "
        },
        {
          "name": "update_related_model_id",
          "type": "Many2one",
          "relation": "ir.model"
        },
        {
          "name": "update_field_type",
          "type": "Selection",
          "readonly": true
        },
        {
          "name": "update_m2m_operation",
          "type": "Selection"
        },
        {
          "name": "update_boolean_value",
          "type": "Selection"
        },
        {
          "name": "value",
          "type": "Text",
          "help": "For Python expressions, this field may hold a Python expression "
        },
        {
          "name": "evaluation_type",
          "type": "Selection"
        },
        {
          "name": "resource_ref",
          "type": "Reference",
          "string": "Record"
        },
        {
          "name": "selection_value",
          "type": "Many2one",
          "relation": "ir.model.fields.selection",
          "string": "Custom Value"
        },
        {
          "name": "value_field_to_show",
          "type": "Selection"
        },
        {
          "name": "webhook_url",
          "type": "Char",
          "string": "Webhook URL",
          "help": "URL to send the POST request to."
        },
        {
          "name": "webhook_field_ids",
          "type": "Many2many",
          "relation": "ir.model.fields",
          "string": "Webhook Fields",
          "help": "Fields to send in the POST request. "
        },
        {
          "name": "webhook_sample_payload",
          "type": "Text",
          "string": "Sample Payload"
        }
      ],
      "methods": [
        {
          "name": "_default_update_path",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _default_update_path(self):\n        if not self.env.context.get('default_model_id'):\n            return ''\n        ir_model = self.env['ir.model'].browse(self.env.context['default_model_id'])\n        model = self.env[ir_model.model]\n        sensible_default_fields = ['partner_id', 'user_id', 'user_ids', 'stage_id', 'state', 'active']\n        for field_name in sensible_default_fields:\n            if field_name in model._fields and not model._fields[field_name].readonly:\n                return field_name\n        return ''\n\n    name = fields.Char(required=True)\n    type = fields.Char(default='ir.actions.server')\n    usage = fields.Selection([\n        ('ir_actions_server', 'Server Action'),\n        ('ir_cron', 'Scheduled Action')], string='Usage',\n        default='ir_actions_server', required=True)\n    state = fields.Selection([\n        ('object_write', 'Update Record'),\n        ('object_create', 'Create Record'),\n        ('code', 'Execute Code'),\n        ('webhook', 'Send Webhook Notification'),\n        ('multi', 'Execute Existing Actions')], string='Type',\n        default='object_write', required=True, copy=True,\n        help=\"Type of server action. The following values are available:\\n\"\n             \"- 'Update a Record': update the values of a record\\n\"\n             \"- 'Create Activity': create an activity (Discuss)\\n\"\n             \"- 'Send Email': post a message, a note or send an email (Discuss)\\n\"\n             \"- 'Send SMS': send SMS, log them on documents (SMS)\"\n             \"- 'Add/Remove Followers': add or remove followers to a record (Discuss)\\n\"\n             \"- 'Create Record': create a new record with new values\\n\"\n             \"- 'Execute Code': a block of Python code that will be executed\\n\"\n             \"- 'Send Webhook Notification': send a POST request to an external system, also known as a Webhook\\n\"\n             \"- 'Execute Existing Actions': define an action that triggers several other server actions\\n\")\n    # Generic\n    sequence = fields.Integer(default=5,\n                              help=\"When dealing with multiple actions, the execution order is \"\n                                   \"based on the sequence. Low number means high priority.\")\n    model_id = fields.Many2one('ir.model', string='Model', required=True, ondelete='cascade', index=True,\n                               help=\"Model on which the server action runs.\")\n    available_model_ids = fields.Many2many('ir.model', string='Available Models', compute='_compute_available_model_ids', store=False)\n    model_name = fields.Char(related='model_id.model', string='Model Name', readonly=True, store=True)\n    # Python code\n    code = fields.Text(string='Python Code', groups='base.group_system',\n                       default=DEFAULT_PYTHON_CODE,\n                       help=\"Write Python code that the action will execute. Some variables are \"\n                            \"available for use; help about python expression is given in the help tab.\")\n    # Multi\n    child_ids = fields.Many2many('ir.actions.server', 'rel_server_actions', 'server_id', 'action_id',\n                                 string='Child Actions', help='Child server actions that will be executed. Note that the last return returned action value will be used as global return value.')\n    # Create\n    crud_model_id = fields.Many2one(\n        'ir.model', string='Record to Create',\n        compute='_compute_crud_relations', readonly=False, store=True,\n        help=\"Specify which kind of record should be created. Set this field only to specify a different model than the base model.\")\n    crud_model_name = fields.Char(related='crud_model_id.model', string='Target Model Name', readonly=True)\n    link_field_id = fields.Many2one(\n        'ir.model.fields', string='Link Field',\n        compute='_compute_link_field_id', readonly=False, store=True,\n        help=\"Specify a field used to link the newly created record on the record used by the server action.\")\n    groups_id = fields.Many2many('res.groups', 'ir_act_server_group_rel',\n                                 'act_id', 'gid', string='Allowed Groups', help='Groups that can execute the server action. Leave empty to allow everybody.')\n\n    update_field_id = fields.Many2one('ir.model.fields', string='Field to Update', ondelete='cascade', compute='_compute_crud_relations', store=True, readonly=False)\n    update_path = fields.Char(string='Field to Update Path', help=\"Path to the field to update, e.g. 'partner_id.name'\", default=_default_update_path)\n    update_related_model_id = fields.Many2one('ir.model', compute='_compute_crud_relations', readonly=False, store=True)\n    update_field_type = fields.Selection(related='update_field_id.ttype', readonly=True)\n    update_m2m_operation = fields.Selection([\n        ('add', 'Adding'),\n        ('remove', 'Removing'),\n        ('set', 'Setting it to'),\n        ('clear', 'Clearing it')\n    ], string='Many2many Operations', default='add')\n    update_boolean_value = fields.Selection([('true', 'Yes (True)'), ('false', \"No (False)\")], string='Boolean Value', default='true')\n\n    value = fields.Text(help=\"For Python expressions, this field may hold a Python expression \"\n                             \"that can use the same values as for the code field on the server action,\"\n                             \"e.g. `env.user.name` to set the current user's name as the value \"\n                             \"or `record.id` to set the ID of the record on which the action is run.\\n\\n\"\n                             \"For Static values, the value will be used directly without evaluation, e.g.\"\n                             \"`42` or `My custom name` or the selected record.\")\n    evaluation_type = fields.Selection([\n        ('value', 'Update'),\n        ('equation', 'Compute')\n    ], 'Value Type', default='value', change_default=True)\n    resource_ref = fields.Reference(\n        string='Record', selection='_selection_target_model', inverse='_set_resource_ref')\n    selection_value = fields.Many2one('ir.model.fields.selection', string=\"Custom Value\", ondelete='cascade',\n                                      domain='[(\"field_id\", \"=\", update_field_id)]', inverse='_set_selection_value')\n\n    value_field_to_show = fields.Selection([\n        ('value', 'value'),\n        ('resource_ref', 'reference'),\n        ('update_boolean_value', 'update_boolean_value'),\n        ('selection_value', 'selection_value'),\n    ], compute='_compute_value_field_to_show')\n    # Webhook\n    webhook_url = fields.Char(string='Webhook URL', help=\"URL to send the POST request to.\")\n    webhook_field_ids = fields.Many2many('ir.model.fields', 'ir_act_server_webhook_field_rel', 'server_id', 'field_id',\n                                         string='Webhook Fields',\n                                         help=\"Fields to send in the POST request. \"\n                                              \"The id and model of the record are always sent as '_id' and '_model'. \"\n                                              \"The name of the action that triggered the webhook is always sent as '_name'.\")\n    webhook_sample_payload = fields.Text(string='Sample Payload', compute='_compute_webhook_sample_payload')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_webhook_field_ids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_webhook_field_ids(self):\n        \"\"\"Check that the selected fields don't have group restrictions\"\"\"\n        restricted_fields = dict()\n        for action in self:\n            Model = self.env[action.model_id.model]\n            for model_field in action.webhook_field_ids:\n                # you might think that the ir.model.field record holds references\n                # to the groups, but that's not the case - we need to field object itself\n                field = Model._fields[model_field.name]\n                if field.groups:\n                    restricted_fields.setdefault(action.name, []).append(model_field.field_description)\n        if restricted_fields:\n            restricted_field_per_action = \"\\n\".join([f\"{action}: {', '.join(f for f in fields)}\" for action, fields in restricted_fields.items()])\n            raise ValidationError(_(\"Group-restricted fields cannot be included in \"\n                                    \"webhook payloads, as it could allow any user to \"\n                                    \"accidentally leak sensitive information. You will \"\n                                    \"have to remove the following fields from the webhook payload \"\n                                    \"in the following actions:\\n %s\", restricted_field_per_action))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_available_model_ids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_available_model_ids(self):\n        allowed_models = self.env['ir.model'].search(\n            [('model', 'in', list(self.env['ir.model.access']._get_allowed_models()))]\n        )\n        self.available_model_ids = allowed_models.ids",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_crud_relations",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_crud_relations(self):\n        \"\"\" Compute the crud_model_id and update_field_id fields.\n\n        The crud_model_id is the model on which the action will create or update\n        records. In the case of record creation, it is the same as the main model\n        of the action. For record update, it will be the model linked to the last\n        field in the update_path.\n        This is only used for object_create and object_write actions.\n        The update_field_id is the field at the end of the update_path that will\n        be updated by the action - only used for object_write actions.\n        \"\"\"\n        for action in self:\n            if action.model_id and action.state in ('object_write', 'object_create'):\n                if action.state == 'object_create':\n                    action.crud_model_id = action.model_id\n                    action.update_field_id = False\n                    action.update_path = False\n                elif action.state == 'object_write':\n                    if action.update_path:\n                        # we need to traverse relations to find the target model and field\n                        model, field, _ = action._traverse_path()\n                        action.crud_model_id = model\n                        action.update_field_id = field\n                        need_update_model = action.evaluation_type == 'value' and action.update_field_id and action.update_field_id.relation\n                        action.update_related_model_id = action.env[\"ir.model\"]._get_id(field.relation) if need_update_model else False\n                    else:\n                        action.crud_model_id = action.model_id\n                        action.update_field_id = False\n            else:\n                action.crud_model_id = False\n                action.update_field_id = False\n                action.update_path = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_traverse_path",
          "params": [
            "self",
            "record=None"
          ],
          "decorators": [],
          "source": "def _traverse_path(self, record=None):\n        \"\"\" Traverse the update_path to find the target model and field, and optionally\n        the target record of an action of type 'object_write'.\n\n        :param record: optional record to use as starting point for the path traversal\n        :return: a tuple (model, field, records) where model is the target model and field is the\n                 target field; if no record was provided, records is None, otherwise it is the\n                    recordset at the end of the path starting from the provided record\n        \"\"\"\n        self.ensure_one()\n        path = self.update_path.split('.')\n        Model = self.env[self.model_id.model]\n        # sanity check: we're starting from a record that belongs to the model\n        if record and record._name != Model._name:\n            raise ValidationError(_(\"I have no idea how you *did that*, but you're trying to use a gibberish configuration: the model of the record on which the action is triggered is not the same as the model of the action.\"))\n        for field_name in path:\n            is_last_field = field_name == path[-1]\n            field = Model._fields[field_name]\n            if field.relational and not is_last_field:\n                Model = self.env[field.comodel_name]\n            elif not field.relational:\n                # sanity check: this should be the last field in the path\n                if not is_last_field:\n                    raise ValidationError(_(\"The path to the field to update contains a non-relational field (%s) that is not the last field in the path. You can't traverse non-relational fields (even in the quantum realm). Make sure only the last field in the path is non-relational.\", field_name))\n                if isinstance(field, fields.Json):\n                    raise ValidationError(_(\"I'm sorry to say that JSON fields (such as %s) are currently not supported.\", field_name))\n        target_records = None\n        if record is not None:\n            target_records = reduce(getitem, path[:-1], record)\n        model_id = self.env['ir.model']._get(Model._name)\n        field_id = self.env['ir.model.fields']._get(Model._name, field_name)\n        return model_id, field_id, target_records",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_stringify_path",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _stringify_path(self):\n        \"\"\" Returns a string representation of the update_path, with the field names\n        separated by the `>` symbol.\"\"\"\n        self.ensure_one()\n        path = self.update_path\n        if not path:\n            return ''\n        model = self.env[self.model_id.model]\n        pretty_path = []\n        field = None\n        for field_name in path.split('.'):\n            if field and field.type == 'properties':\n                pretty_path.append(field_name)\n                continue\n            field = model._fields[field_name]\n            field_id = self.env['ir.model.fields']._get(model._name, field_name)\n            if field.relational:\n                model = self.env[field.comodel_name]\n            pretty_path.append(field_id.field_description)\n        return ' > '.join(pretty_path)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_webhook_sample_payload",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_webhook_sample_payload(self):\n        for action in self:\n            if action.state != 'webhook':\n                action.webhook_sample_payload = False\n                continue\n            payload = {\n                'id': 1,\n                '_model': self.model_id.model,\n                '_name': action.name,\n            }\n            if self.model_id:\n                sample_record = self.env[self.model_id.model].with_context(active_test=False).search([], limit=1)\n                for field in action.webhook_field_ids:\n                    if sample_record:\n                        payload['id'] = sample_record.id\n                        payload.update(sample_record.read(self.webhook_field_ids.mapped('name'), load=None)[0])\n                    else:\n                        payload[field.name] = WEBHOOK_SAMPLE_VALUES[field.ttype] if field.ttype in WEBHOOK_SAMPLE_VALUES else WEBHOOK_SAMPLE_VALUES[None]\n            action.webhook_sample_payload = json.dumps(payload, indent=4, sort_keys=True, default=str)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_link_field_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_link_field_id(self):\n        invalid = self.filtered(lambda act: act.link_field_id.model_id != act.model_id)\n        if invalid:\n            invalid.link_field_id = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_python_code",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_python_code(self):\n        for action in self.sudo().filtered('code'):\n            msg = test_python_expr(expr=action.code.strip(), mode=\"exec\")\n            if msg:\n                raise ValidationError(msg)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_recursion",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_recursion(self):\n        if not self._check_m2m_recursion('child_ids'):\n            raise ValidationError(_('Recursion found in child server actions'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_readable_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_readable_fields(self):\n        return super()._get_readable_fields() | {\n            \"groups_id\", \"model_name\",\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_runner",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_runner(self):\n        multi = True\n        t = self.env.registry[self._name]\n        fn = getattr(t, f'_run_action_{self.state}_multi', None)\\\n          or getattr(t, f'run_action_{self.state}_multi', None)\n        if not fn:\n            multi = False\n            fn = getattr(t, f'_run_action_{self.state}', None)\\\n              or getattr(t, f'run_action_{self.state}', None)\n        if fn and fn.__name__.startswith('run_action_'):\n            fn = partial(fn, self)\n        return fn, multi",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_register_hook",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _register_hook(self):\n        super()._register_hook()\n\n        for cls in self.env.registry[self._name].mro():\n            for symbol in vars(cls).keys():\n                if symbol.startswith('run_action_'):\n                    _logger.warning(\n                        \"RPC-public action methods are deprecated, found %r (in class %s.%s)\",\n                        symbol, cls.__module__, cls.__name__\n                    )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create_action",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def create_action(self):\n        \"\"\" Create a contextual action for each server action. \"\"\"\n        for action in self:\n            action.write({'binding_model_id': action.model_id.id,\n                          'binding_type': 'action'})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink_action",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink_action(self):\n        \"\"\" Remove the contextual actions created for the server actions. \"\"\"\n        self.check_access_rights('write', raise_exception=True)\n        self.filtered('binding_model_id').write({'binding_model_id': False})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_run_action_code_multi",
          "params": [
            "self",
            "eval_context"
          ],
          "decorators": [],
          "source": "def _run_action_code_multi(self, eval_context):\n        safe_eval(self.code.strip(), eval_context, mode=\"exec\", nocopy=True, filename=str(self))  # nocopy allows to return 'action'\n        return eval_context.get('action')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_run_action_multi",
          "params": [
            "self",
            "eval_context=None"
          ],
          "decorators": [],
          "source": "def _run_action_multi(self, eval_context=None):\n        res = False\n        for act in self.child_ids.sorted():\n            res = act.run() or res\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_run_action_object_write",
          "params": [
            "self",
            "eval_context=None"
          ],
          "decorators": [],
          "source": "def _run_action_object_write(self, eval_context=None):\n        \"\"\"Apply specified write changes to active_id.\"\"\"\n        vals = self._eval_value(eval_context=eval_context)\n        res = {action.update_field_id.name: vals[action.id] for action in self}\n\n        if self._context.get('onchange_self'):\n            record_cached = self._context['onchange_self']\n            for field, new_value in res.items():\n                record_cached[field] = new_value\n        else:\n            starting_record = self.env[self.model_id.model].browse(self._context.get('active_id'))\n            _, _, target_records = self._traverse_path(record=starting_record)\n            target_records.write(res)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_run_action_webhook",
          "params": [
            "self",
            "eval_context=None"
          ],
          "decorators": [],
          "source": "def _run_action_webhook(self, eval_context=None):\n        \"\"\"Send a post request with a read of the selected field on active_id.\"\"\"\n        record = self.env[self.model_id.model].browse(self._context.get('active_id'))\n        url = self.webhook_url\n        if not record:\n            return\n        if not url:\n            raise UserError(_(\"I'll be happy to send a webhook for you, but you really need to give me a URL to reach out to...\"))\n        vals = {\n            '_model': self.model_id.model,\n            '_id': record.id,\n            '_action': f'{self.name}(#{self.id})',\n        }\n        if self.webhook_field_ids:\n            # you might think we could use the default json serializer of the requests library\n            # but it will fail on many fields, e.g. datetime, date or binary\n            # so we use the json.dumps serializer instead with the str() function as default\n            vals.update(record.read(self.webhook_field_ids.mapped('name'), load=None)[0])\n        json_values = json.dumps(vals, sort_keys=True, default=str)\n        _logger.info(\"Webhook call to %s\", url)\n        _logger.debug(\"POST JSON data for webhook call: %s\", json_values)\n        try:\n            # 'send and forget' strategy, and avoid locking the user if the webhook\n            # is slow or non-functional (we still allow for a 1s timeout so that\n            # if we get a proper error response code like 400, 404 or 500 we can log)\n            response = requests.post(url, data=json_values, headers={'Content-Type': 'application/json'}, timeout=1)\n            response.raise_for_status()\n        except requests.exceptions.ReadTimeout:\n            _logger.warning(\"Webhook call timed out after 1s - it may or may not have failed. \"\n                            \"If this happens often, it may be a sign that the system you're \"\n                            \"trying to reach is slow or non-functional.\")\n        except requests.exceptions.RequestException as e:\n            _logger.warning(\"Webhook call failed: %s\", e)\n        except Exception as e:  # noqa: BLE001\n            raise UserError(_(\"Wow, your webhook call failed with a really unusual error: %s\", e)) from e",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_run_action_object_create",
          "params": [
            "self",
            "eval_context=None"
          ],
          "decorators": [],
          "source": "def _run_action_object_create(self, eval_context=None):\n        \"\"\"Create specified model object with specified name contained in value.\n\n        If applicable, link active_id.<self.link_field_id> to the new record.\n        \"\"\"\n        res_id, _res_name = self.env[self.crud_model_id.model].name_create(self.value)\n\n        if self.link_field_id:\n            record = self.env[self.model_id.model].browse(self._context.get('active_id'))\n            if self.link_field_id.ttype in ['one2many', 'many2many']:\n                record.write({self.link_field_id.name: [Command.link(res_id)]})\n            else:\n                record.write({self.link_field_id.name: res_id})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_eval_context",
          "params": [
            "self",
            "action=None"
          ],
          "decorators": [],
          "source": "def _get_eval_context(self, action=None):\n        \"\"\" Prepare the context used when evaluating python code, like the\n        python formulas or code server actions.\n\n        :param action: the current server action\n        :type action: browse record\n        :returns: dict -- evaluation context given to (safe_)safe_eval \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "log",
          "params": [
            "message",
            "level=\"info\""
          ],
          "decorators": [],
          "source": "def log(message, level=\"info\"):\n            with self.pool.cursor() as cr:\n                cr.execute(\"\"\"\n                    INSERT INTO ir_logging(create_date, create_uid, type, dbname, name, level, message, path, line, func)\n                    VALUES (NOW() at time zone 'UTC', %s, %s, %s, %s, %s, %s, %s, %s, %s)\n                \"\"\", (self.env.uid, 'server', self._cr.dbname, __name__, level, message, \"action\", action.id, action.name))\n\n        eval_context = super(IrActionsServer, self)._get_eval_context(action=action)\n        model_name = action.model_id.sudo().model\n        model = self.env[model_name]\n        record = None\n        records = None\n        if self._context.get('active_model') == model_name and self._context.get('active_id'):\n            record = model.browse(self._context['active_id'])\n        if self._context.get('active_model') == model_name and self._context.get('active_ids'):\n            records = model.browse(self._context['active_ids'])\n        if self._context.get('onchange_self'):\n            record = self._context['onchange_self']\n        eval_context.update({\n            # orm\n            'env': self.env,\n            'model': model,\n            # Exceptions\n            'UserError': odoo.exceptions.UserError,\n            # record\n            'record': record,\n            'records': records,\n            # helpers\n            'log': log,\n            '_logger': LoggerProxy,\n        })\n        return eval_context",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "run",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def run(self):\n        \"\"\" Runs the server action. For each server action, the\n        :samp:`_run_action_{TYPE}[_multi]` method is called. This allows easy\n        overriding of the server actions.\n\n        The ``_multi`` suffix means the runner can operate on multiple records,\n        otherwise if there are multiple records the runner will be called once\n        for each.\n\n        The call context should contain the following keys:\n\n        active_id\n            id of the current object (single mode)\n        active_model\n            current model that should equal the action's model\n        active_ids (optional)\n           ids of the current records (mass mode). If ``active_ids`` and\n           ``active_id`` are present, ``active_ids`` is given precedence.\n        :return: an ``action_id`` to be executed, or ``False`` is finished\n                 correctly without return action\n        \"\"\"\n        res = False\n        for action in self.sudo():\n            action_groups = action.groups_id\n            if action_groups:\n                if not (action_groups & self.env.user.groups_id):\n                    raise AccessError(_(\"You don't have enough access rights to run this action.\"))\n            else:\n                model_name = action.model_id.model\n                try:\n                    self.env[model_name].check_access_rights(\"write\")\n                except AccessError:\n                    _logger.warning(\"Forbidden server action %r executed while the user %s does not have access to %s.\",\n                        action.name, self.env.user.login, model_name,\n                    )\n                    raise\n\n            eval_context = self._get_eval_context(action)\n            records = eval_context.get('record') or eval_context['model']\n            records |= eval_context.get('records') or eval_context['model']\n            if records.ids:\n                # check access rules on real records only; base automations of\n                # type 'onchange' can run server actions on new records\n                try:\n                    records.check_access_rule('write')\n                except AccessError:\n                    _logger.warning(\"Forbidden server action %r executed while the user %s does not have access to %s.\",\n                        action.name, self.env.user.login, records,\n                    )\n                    raise\n\n            runner, multi = action._get_runner()\n            if runner and multi:\n                # call the multi method\n                run_self = action.with_context(eval_context['env'].context)\n                res = runner(run_self, eval_context=eval_context)\n            elif runner:\n                active_id = self._context.get('active_id')\n                if not active_id and self._context.get('onchange_self'):\n                    active_id = self._context['onchange_self']._origin.id\n                    if not active_id:  # onchange on new record\n                        res = runner(action, eval_context=eval_context)\n                active_ids = self._context.get('active_ids', [active_id] if active_id else [])\n                for active_id in active_ids:\n                    # run context dedicated to a particular active_id\n                    run_self = action.with_context(active_ids=[active_id], active_id=active_id)\n                    eval_context[\"env\"].context = run_self._context\n                    res = runner(run_self, eval_context=eval_context)\n            else:\n                _logger.warning(\n                    \"Found no way to execute server action %r of type %r, ignoring it. \"\n                    \"Verify that the type is correct or add a method called \"\n                    \"`_run_action_<type>` or `_run_action_<type>_multi`.\",\n                    action.name, action.state\n                )\n        return res or False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_value_field_to_show",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_value_field_to_show(self):  # check if value_field_to_show can be removed and use ttype in xml view instead\n        for action in self:\n            if action.update_field_id.ttype in ('many2one', 'many2many'):\n                action.value_field_to_show = 'resource_ref'\n            elif action.update_field_id.ttype == 'selection':\n                action.value_field_to_show = 'selection_value'\n            elif action.update_field_id.ttype == 'boolean':\n                action.value_field_to_show = 'update_boolean_value'\n            else:\n                action.value_field_to_show = 'value'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_selection_target_model",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _selection_target_model(self):\n        return [(model.model, model.name) for model in self.env['ir.model'].sudo().search([])]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_raise_many2many_error",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _raise_many2many_error(self):\n        pass  # TODO: remove in master",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_resource_ref",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _set_resource_ref(self):\n        for action in self.filtered(lambda action: action.value_field_to_show == 'resource_ref'):\n            if action.resource_ref:\n                action.value = str(action.resource_ref.id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_selection_value",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _set_selection_value(self):\n        for action in self.filtered(lambda action: action.value_field_to_show == 'selection_value'):\n            if action.selection_value:\n                action.value = action.selection_value.value",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_eval_value",
          "params": [
            "self",
            "eval_context=None"
          ],
          "decorators": [],
          "source": "def _eval_value(self, eval_context=None):\n        result = {}\n        for action in self:\n            expr = action.value\n            if action.evaluation_type == 'equation':\n                expr = safe_eval(action.value, eval_context)\n            elif action.update_field_id.ttype == 'many2many':\n                operation = action.update_m2m_operation\n                if operation == 'add':\n                    expr = [Command.link(int(action.value))]\n                elif operation == 'remove':\n                    expr = [Command.unlink(int(action.value))]\n                elif operation == 'set':\n                    expr = [Command.set([int(action.value)])]\n                elif operation == 'clear':\n                    expr = [Command.clear()]\n            elif action.update_field_id.ttype == 'boolean':\n                expr = action.update_boolean_value == 'true'\n            elif action.update_field_id.ttype in ['many2one', 'integer']:\n                try:\n                    expr = int(action.value)\n                except Exception:\n                    pass\n            elif action.update_field_id.ttype == 'float':\n                with contextlib.suppress(Exception):\n                    expr = float(action.value)\n            result[action.id] = expr\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy_data",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy_data(self, default=None):\n        default = default or {}\n        if not default.get('name'):\n            default['name'] = _('%s (copy)', self.name)\n        return super().copy_data(default=default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.actions.actions"
        }
      ],
      "constraints": [
        {
          "type": "python",
          "name": "_check_webhook_field_ids",
          "definition": "@api.constrains('webhook_field_ids')\n    def _check_webhook_field_ids(self):\n        \"\"\"Check that the selected fields don't have group restrictions\"\"\"\n        restricted_fields = dict()\n        for action in self:\n            Model = self.env[action.model_id.model]\n            for model_field in action.webhook_field_ids:\n                # you might think that the ir.model.field record holds references\n                # to the groups, but that's not the case - we need to field object itself\n                field = Model._fields[model_field.name]\n                if field.groups:\n                    restricted_fields.setdefault(action.name, []).append(model_field.field_description)\n        if restricted_fields:\n            restricted_field_per_action = \"\\n\".join([f\"{action}: {', '.join(f for f in fields)}\" for action, fields in restricted_fields.items()])\n            raise ValidationError(_(\"Group-restricted fields cannot be included in \"\n                                    \"webhook payloads, as it could allow any user to \"\n                                    \"accidentally leak sensitive information. You will \"\n                                    \"have to remove the following fields from the webhook payload \"\n                                    \"in the following actions:\\n %s\", restricted_field_per_action))",
          "message": "'webhook_field_ids'"
        },
        {
          "type": "python",
          "name": "_check_python_code",
          "definition": "@api.constrains('code')\n    def _check_python_code(self):\n        for action in self.sudo().filtered('code'):\n            msg = test_python_expr(expr=action.code.strip(), mode=\"exec\")\n            if msg:\n                raise ValidationError(msg)",
          "message": "'code'"
        },
        {
          "type": "python",
          "name": "_check_recursion",
          "definition": "@api.constrains('child_ids')\n    def _check_recursion(self):\n        if not self._check_m2m_recursion('child_ids'):\n            raise ValidationError(_('Recursion found in child server actions'))",
          "message": "'child_ids'"
        },
        {
          "type": "python",
          "name": "_raise_many2many_error",
          "definition": "@api.constrains('update_field_id', 'evaluation_type')\n    def _raise_many2many_error(self):\n        pass  # TODO: remove in master",
          "message": "'update_field_id', 'evaluation_type'"
        }
      ],
      "accessRules": [
        {
          "name": "_default_update_path (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_selection_target_model (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrActionsServer"
    },
    {
      "name": "ir.actions.todo",
      "description": "Configuration Wizards",
      "fields": [
        {
          "name": "action_id",
          "type": "Many2one",
          "relation": "ir.actions.actions",
          "required": true,
          "string": "Action"
        },
        {
          "name": "sequence",
          "type": "Integer"
        },
        {
          "name": "state",
          "type": "Selection"
        },
        {
          "name": "name",
          "type": "Char"
        }
      ],
      "methods": [
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        todos = super(IrActionsTodo, self).create(vals_list)\n        for todo in todos:\n            if todo.state == \"open\":\n                self.ensure_one_open_todo()\n        return todos",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        res = super(IrActionsTodo, self).write(vals)\n        if vals.get('state', '') == 'open':\n            self.ensure_one_open_todo()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "ensure_one_open_todo",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def ensure_one_open_todo(self):\n        open_todo = self.search([('state', '=', 'open')], order='sequence asc, id desc', offset=1)\n        if open_todo:\n            open_todo.write({'state': 'done'})",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        if self:\n            try:\n                todo_open_menu = self.env.ref('base.open_menu')\n                # don't remove base.open_menu todo but set its original action\n                if todo_open_menu in self:\n                    todo_open_menu.action_id = self.env.ref('base.action_client_base_menu').id\n                    self -= todo_open_menu\n            except ValueError:\n                pass\n        return super(IrActionsTodo, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_launch",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_launch(self):\n        \"\"\" Launch Action of Wizard\"\"\"\n        self.ensure_one()\n\n        self.write({'state': 'done'})\n\n        # Load action\n        action_type = self.action_id.type\n        action = self.env[action_type].browse(self.action_id.id)\n\n        result = action.read()[0]\n        if action_type != 'ir.actions.act_window':\n            return result\n        result.setdefault('context', '{}')\n\n        # Open a specific record when res_id is provided in the context\n        ctx = safe_eval(result['context'], {'user': self.env.user})\n        if ctx.get('res_id'):\n            result['res_id'] = ctx.pop('res_id')\n\n        # disable log for automatic wizards\n        ctx['disable_log'] = True\n\n        result['context'] = ctx\n\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_open",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_open(self):\n        \"\"\" Sets configuration wizard in TODO state\"\"\"\n        return self.write({'state': 'open'})",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "ensure_one_open_todo (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrActionsTodo"
    },
    {
      "name": "ir.actions.client",
      "description": "Client Action",
      "fields": [
        {
          "name": "type",
          "type": "Char"
        },
        {
          "name": "tag",
          "type": "Char",
          "required": true,
          "string": "Client action tag",
          "help": "An arbitrary string, interpreted by the client"
        },
        {
          "name": "target",
          "type": "Selection"
        },
        {
          "name": "res_model",
          "type": "Char",
          "string": "Destination Model",
          "help": "Optional model, mostly used for needactions."
        },
        {
          "name": "context",
          "type": "Char",
          "required": true,
          "string": "Context Value"
        },
        {
          "name": "params",
          "type": "Binary",
          "string": "Supplementary arguments",
          "help": "Arguments sent to the client along with "
        },
        {
          "name": "params_store",
          "type": "Binary",
          "readonly": true,
          "string": "Params storage"
        }
      ],
      "methods": [
        {
          "name": "_compute_params",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_params(self):\n        self_bin = self.with_context(bin_size=False, bin_size_params_store=False)\n        for record, record_bin in zip(self, self_bin):\n            record.params = record_bin.params_store and safe_eval(record_bin.params_store, {'uid': self._uid})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_params",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_params(self):\n        for record in self:\n            params = record.params\n            record.params_store = repr(params) if isinstance(params, dict) else params",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_form_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_form_view(self):\n        doc = super(IrActionsActClient, self)._get_default_form_view()\n        params = doc.find(\".//field[@name='params']\")\n        params.getparent().remove(params)\n        params_store = doc.find(\".//field[@name='params_store']\")\n        params_store.getparent().remove(params_store)\n        return doc",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_readable_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_readable_fields(self):\n        return super()._get_readable_fields() | {\n            \"context\", \"params\", \"res_model\", \"tag\", \"target\",\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.actions.actions"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "IrActionsActClient"
    },
    {
      "name": "ir.actions.report",
      "description": "Report Action",
      "fields": [
        {
          "name": "type",
          "type": "Char"
        },
        {
          "name": "binding_type",
          "type": "Selection"
        },
        {
          "name": "model",
          "type": "Char",
          "required": true,
          "string": "Model Name"
        },
        {
          "name": "model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "string": "Model"
        },
        {
          "name": "report_type",
          "type": "Selection"
        },
        {
          "name": "report_name",
          "type": "Char",
          "required": true,
          "string": "Template Name"
        },
        {
          "name": "report_file",
          "type": "Char",
          "string": "Report File"
        },
        {
          "name": "groups_id",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Groups"
        },
        {
          "name": "multi",
          "type": "Boolean",
          "string": "On Multiple Doc.",
          "help": "If set to true, the action will not be displayed on the right toolbar of a form view."
        },
        {
          "name": "paperformat_id",
          "type": "Many2one",
          "relation": "report.paperformat"
        },
        {
          "name": "print_report_name",
          "type": "Char",
          "help": "This is the filename of the report going to download. Keep empty to not change the report filename. You can use a python expression with the "
        },
        {
          "name": "attachment_use",
          "type": "Boolean",
          "string": "Reload from Attachment",
          "help": "If enabled, then the second time the user prints with same attachment name, it returns the previous report."
        },
        {
          "name": "attachment",
          "type": "Char",
          "string": "Save as Attachment Prefix",
          "help": "This is the filename of the attachment used to store the printing result. Keep empty to not save the printed reports. You can use a python expression with the object and time variables."
        }
      ],
      "methods": [
        {
          "name": "_compute_model_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_model_id(self):\n        for action in self:\n            action.model_id = self.env['ir.model']._get(action.model).id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search_model_id",
          "params": [
            "self",
            "operator",
            "value"
          ],
          "decorators": [],
          "source": "def _search_model_id(self, operator, value):\n        ir_model_ids = None\n        if isinstance(value, str):\n            names = self.env['ir.model'].name_search(value, operator=operator)\n            ir_model_ids = [n[0] for n in names]\n\n        elif operator in ('any', 'not any'):\n            ir_model_ids = self.env['ir.model']._search(value)\n\n        elif isinstance(value, Iterable):\n            ir_model_ids = value\n\n        elif isinstance(value, int) and not isinstance(value, bool):\n            ir_model_ids = [value]\n\n        if ir_model_ids:\n            operator = 'not in' if operator in NEGATIVE_TERM_OPERATORS else 'in'\n            ir_model = self.env['ir.model'].browse(ir_model_ids)\n            return [('model', operator, ir_model.mapped('model'))]\n        elif isinstance(value, bool) or value is None:\n            return [('model', operator, value)]\n        else:\n            return FALSE_DOMAIN",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_readable_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_readable_fields(self):\n        return super()._get_readable_fields() | {\n            \"report_name\", \"report_type\", \"target\",\n            # these two are not real fields of ir.actions.report but are\n            # expected in the route /report/<converter>/<reportname> and must\n            # not be removed by clean_action\n            \"context\", \"data\",\n            # and this one is used by the frontend later on.\n            \"close_on_report_download\",\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "associated_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def associated_view(self):\n        \"\"\"Used in the ir.actions.report form view in order to search naively after the view(s)\n        used in the rendering.\n        \"\"\"\n        self.ensure_one()\n        action_ref = self.env.ref('base.action_ui_view')\n        if not action_ref or len(self.report_name.split('.')) < 2:\n            return False\n        action_data = action_ref.read()[0]\n        action_data['domain'] = [('name', 'ilike', self.report_name.split('.')[1]), ('type', '=', 'qweb')]\n        return action_data",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create_action",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def create_action(self):\n        \"\"\" Create a contextual action for each report. \"\"\"\n        for report in self:\n            model = self.env['ir.model']._get(report.model)\n            report.write({'binding_model_id': model.id, 'binding_type': 'report'})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink_action",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink_action(self):\n        \"\"\" Remove the contextual actions created for the reports. \"\"\"\n        self.check_access_rights('write', raise_exception=True)\n        self.filtered('binding_model_id').write({'binding_model_id': False})\n        return True\n\n    #--------------------------------------------------------------------------\n    # Main report methods\n    #--------------------------------------------------------------------------",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "retrieve_attachment",
          "params": [
            "self",
            "record"
          ],
          "decorators": [],
          "source": "def retrieve_attachment(self, record):\n        '''Retrieve an attachment for a specific record.\n\n        :param record: The record owning of the attachment.\n        :return: A recordset of length <=1 or None\n        '''\n        attachment_name = safe_eval(self.attachment, {'object': record, 'time': time}) if self.attachment else ''\n        if not attachment_name:\n            return None\n        return self.env['ir.attachment'].search([\n                ('name', '=', attachment_name),\n                ('res_model', '=', self.model),\n                ('res_id', '=', record.id)\n        ], limit=1)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_wkhtmltopdf_state",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_wkhtmltopdf_state(self):\n        '''Get the current state of wkhtmltopdf: install, ok, upgrade, workers or broken.\n        * install: Starting state.\n        * upgrade: The binary is an older version (< 0.12.0).\n        * ok: A binary was found with a recent version (>= 0.12.0).\n        * workers: Not enough workers found to perform the pdf rendering process (< 2 workers).\n        * broken: A binary was found but not responding.\n\n        :return: wkhtmltopdf_state\n        '''\n        return wkhtmltopdf_state",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_paperformat",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_paperformat(self):\n        return self.paperformat_id or self.env.company.paperformat_id",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_layout",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_layout(self):\n        return self.env.ref('web.minimal_layout', raise_if_not_found=False)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_report_url",
          "params": [
            "self",
            "layout=None"
          ],
          "decorators": [],
          "source": "def _get_report_url(self, layout=None):\n        report_url = self.env['ir.config_parameter'].sudo().get_param('report.url')\n        return report_url or (layout or self._get_layout() or self).get_base_url()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_prepare_html",
          "params": [
            "self",
            "html",
            "report_model=False"
          ],
          "decorators": [],
          "source": "def _prepare_html(self, html, report_model=False):\n        '''Divide and recreate the header/footer html by merging all found in html.\n        The bodies are extracted and added to a list. Then, extract the specific_paperformat_args.\n        The idea is to put all headers/footers together. Then, we will use a javascript trick\n        (see minimal_layout template) to set the right header/footer during the processing of wkhtmltopdf.\n        This allows the computation of multiple reports in a single call to wkhtmltopdf.\n\n        :param html: The html rendered by render_qweb_html.\n        :type: bodies: list of string representing each one a html body.\n        :type header: string representing the html header.\n        :type footer: string representing the html footer.\n        :type specific_paperformat_args: dictionary of prioritized paperformat values.\n        :return: bodies, header, footer, specific_paperformat_args\n        '''\n\n        # Return empty dictionary if 'web.minimal_layout' not found.\n        layout = self._get_layout()\n        if not layout:\n            return {}\n        base_url = self._get_report_url(layout=layout)\n        url = urlparse(base_url)\n        query = parse_qs(url.query or \"\")\n        debug = self.env.context.get(\"debug\")\n        if not isinstance(debug, str):\n            debug = \"1\" if debug else \"0\"\n        query[\"debug\"] = debug\n        base_url = url._replace(query=urlencode(query)).geturl()\n\n        root = lxml.html.fromstring(html, parser=lxml.html.HTMLParser(encoding='utf-8'))\n        match_klass = \"//div[contains(concat(' ', normalize-space(@class), ' '), ' {} ')]\"\n\n        header_node = etree.Element('div', id='minimal_layout_report_headers')\n        footer_node = etree.Element('div', id='minimal_layout_report_footers')\n        bodies = []\n        res_ids = []\n\n        body_parent = root.xpath('//main')[0]\n        # Retrieve headers\n        for node in root.xpath(match_klass.format('header')):\n            body_parent = node.getparent()\n            node.getparent().remove(node)\n            header_node.append(node)\n\n        # Retrieve footers\n        for node in root.xpath(match_klass.format('footer')):\n            body_parent = node.getparent()\n            node.getparent().remove(node)\n            footer_node.append(node)\n\n        # Retrieve bodies\n        for node in root.xpath(match_klass.format('article')):\n            # set context language to body language\n            IrQweb = self.env['ir.qweb']\n            if node.get('data-oe-lang'):\n                IrQweb = IrQweb.with_context(lang=node.get('data-oe-lang'))\n            body = IrQweb._render(layout.id, {\n                    'subst': False,\n                    'body': Markup(lxml.html.tostring(node, encoding='unicode')),\n                    'base_url': base_url,\n                    'report_xml_id': self.xml_id,\n                    'debug': self.env.context.get(\"debug\"),\n                }, raise_if_not_found=False)\n            bodies.append(body)\n            if node.get('data-oe-model') == report_model:\n                res_ids.append(int(node.get('data-oe-id', 0)))\n            else:\n                res_ids.append(None)\n\n        if not bodies:\n            body = ''.join(lxml.html.tostring(c, encoding='unicode') for c in body_parent.getchildren())\n            bodies.append(body)\n\n        # Get paperformat arguments set in the root html tag. They are prioritized over\n        # paperformat-record arguments.\n        specific_paperformat_args = {}\n        for attribute in root.items():\n            if attribute[0].startswith('data-report-'):\n                specific_paperformat_args[attribute[0]] = attribute[1]\n\n        header = self.env['ir.qweb']._render(layout.id, {\n            'subst': True,\n            'body': Markup(lxml.html.tostring(header_node, encoding='unicode')),\n            'base_url': base_url,\n            'debug': self.env.context.get(\"debug\"),\n        })\n        footer = self.env['ir.qweb']._render(layout.id, {\n            'subst': True,\n            'body': Markup(lxml.html.tostring(footer_node, encoding='unicode')),\n            'base_url': base_url,\n            'debug': self.env.context.get(\"debug\"),\n        })\n\n        return bodies, res_ids, header, footer, specific_paperformat_args",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_report_from_name",
          "params": [
            "self",
            "report_name"
          ],
          "decorators": [],
          "source": "def _get_report_from_name(self, report_name):\n        \"\"\"Get the first record of ir.actions.report having the ``report_name`` as value for\n        the field report_name.\n        \"\"\"\n        report_obj = self.env['ir.actions.report']\n        conditions = [('report_name', '=', report_name)]\n        context = self.env['res.users'].context_get()\n        return report_obj.with_context(context).sudo().search(conditions, limit=1)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_report",
          "params": [
            "self",
            "report_ref"
          ],
          "decorators": [],
          "source": "def _get_report(self, report_ref):\n        \"\"\"Get the report (with sudo) from a reference\n        report_ref: can be one of\n            - ir.actions.report id\n            - ir.actions.report record\n            - ir.model.data reference to ir.actions.report\n            - ir.actions.report report_name\n        \"\"\"\n        ReportSudo = self.env['ir.actions.report'].sudo()\n        if isinstance(report_ref, int):\n            return ReportSudo.browse(report_ref)\n        if isinstance(report_ref, models.Model):\n            if report_ref._name != self._name:\n                raise ValueError(\"Expected report of type %s, got %s\" % (self._name, report_ref._name))\n            return report_ref.sudo()\n        report = ReportSudo.search([('report_name', '=', report_ref)], limit=1)\n        if report:\n            return report\n        report = self.env.ref(report_ref)\n        if report:\n            if report._name != \"ir.actions.report\":\n                raise ValueError(\"Fetching report %r: type %s, expected ir.actions.report\" % (report_ref, report._name))\n            return report.sudo()\n        raise ValueError(\"Fetching report %r: report not found\" % report_ref)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "barcode",
          "params": [
            "self",
            "barcode_type",
            "value",
            "**kwargs"
          ],
          "decorators": [],
          "source": "def barcode(self, barcode_type, value, **kwargs):\n        defaults = {\n            'width': (600, int),\n            'height': (100, int),\n            'humanreadable': (False, lambda x: bool(int(x))),\n            'quiet': (True, lambda x: bool(int(x))),\n            'mask': (None, lambda x: x),\n            'barBorder': (4, int),\n            # The QR code can have different layouts depending on the Error Correction Level\n            # See: https://en.wikipedia.org/wiki/QR_code#Error_correction\n            # Level 'L'  up to 7% damage   (default)\n            # Level 'M'  up to 15% damage  (i.e. required by l10n_ch QR bill)\n            # Level 'Q'  up to 25% damage\n            # Level 'H'  up to 30% damage\n            'barLevel': ('L', lambda x: x in ('L', 'M', 'Q', 'H') and x or 'L'),\n        }\n        kwargs = {k: validator(kwargs.get(k, v)) for k, (v, validator) in defaults.items()}\n        kwargs['humanReadable'] = kwargs.pop('humanreadable')\n        if kwargs['humanReadable']:\n            kwargs['fontName'] = _DEFAULT_BARCODE_FONT\n\n        if barcode_type == 'UPCA' and len(value) in (11, 12, 13):\n            barcode_type = 'EAN13'\n            if len(value) in (11, 12):\n                value = '0%s' % value\n        elif barcode_type == 'auto':\n            symbology_guess = {8: 'EAN8', 13: 'EAN13'}\n            barcode_type = symbology_guess.get(len(value), 'Code128')\n        elif barcode_type == 'QR':\n            # for `QR` type, `quiet` is not supported. And is simply ignored.\n            # But we can use `barBorder` to get a similar behaviour.\n            if kwargs['quiet']:\n                kwargs['barBorder'] = 0\n\n        if barcode_type in ('EAN8', 'EAN13') and not check_barcode_encoding(value, barcode_type):\n            # If the barcode does not respect the encoding specifications, convert its type into Code128.\n            # Otherwise, the report-lab method may return a barcode different from its value. For instance,\n            # if the barcode type is EAN-8 and the value 11111111, the report-lab method will take the first\n            # seven digits and will compute the check digit, which gives: 11111115 -> the barcode does not\n            # match the expected value.\n            barcode_type = 'Code128'\n\n        try:\n            barcode = createBarcodeDrawing(barcode_type, value=value, format='png', **kwargs)\n\n            # If a mask is asked and it is available, call its function to\n            # post-process the generated QR-code image\n            if kwargs['mask']:\n                available_masks = self.get_available_barcode_masks()\n                mask_to_apply = available_masks.get(kwargs['mask'])\n                if mask_to_apply:\n                    mask_to_apply(kwargs['width'], kwargs['height'], barcode)\n\n            return barcode.asString('png')\n        except (ValueError, AttributeError):\n            if barcode_type == 'Code128':\n                raise ValueError(\"Cannot convert into barcode.\")\n            elif barcode_type == 'QR':\n                raise ValueError(\"Cannot convert into QR code.\")\n            else:\n                return self.barcode('Code128', value, **kwargs)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_available_barcode_masks",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_barcode_masks(self):\n        \"\"\" Hook for extension.\n        This function returns the available QR-code masks, in the form of a\n        list of (code, mask_function) elements, where code is a string identifying\n        the mask uniquely, and mask_function is a function returning a reportlab\n        Drawing object with the result of the mask, and taking as parameters:\n            - width of the QR-code, in pixels\n            - height of the QR-code, in pixels\n            - reportlab Drawing object containing the barcode to apply the mask on\n        \"\"\"\n        return {}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_render_template",
          "params": [
            "self",
            "template",
            "values=None"
          ],
          "decorators": [],
          "source": "def _render_template(self, template, values=None):\n        \"\"\"Allow to render a QWeb template python-side. This function returns the 'ir.ui.view'\n        render but embellish it with some variables/methods used in reports.\n        :param values: additional methods/variables used in the rendering\n        :returns: html representation of the template\n        :rtype: bytes\n        \"\"\"\n        if values is None:\n            values = {}\n\n        # Browse the user instead of using the sudo self.env.user\n        user = self.env['res.users'].browse(self.env.uid)\n        view_obj = self.env['ir.ui.view'].with_context(inherit_branding=False)\n        values.update(\n            time=time,\n            context_timestamp=lambda t: fields.Datetime.context_timestamp(self.with_context(tz=user.tz), t),\n            user=user,\n            res_company=self.env.company,\n            web_base_url=self.env['ir.config_parameter'].sudo().get_param('web.base.url', default=''),\n        )\n        return view_obj._render_template(template, values).encode()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_merge_pdfs",
          "params": [
            "self",
            "streams"
          ],
          "decorators": [],
          "source": "def _merge_pdfs(self, streams):\n        writer = PdfFileWriter()\n        for stream in streams:\n            try:\n                reader = PdfFileReader(stream)\n                writer.appendPagesFromReader(reader)\n            except (PdfReadError, TypeError, NotImplementedError, ValueError):\n                # TODO : make custom_error_handler a parameter in master\n                custom_error_handler = self.env.context.get('custom_error_handler')\n                if custom_error_handler:\n                    custom_error_handler(stream)\n                    continue\n                raise UserError(_(\"Odoo is unable to merge the generated PDFs.\"))\n        result_stream = io.BytesIO()\n        streams.append(result_stream)\n        writer.write(result_stream)\n        return result_stream",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_render_qweb_pdf_prepare_streams",
          "params": [
            "self",
            "report_ref",
            "data",
            "res_ids=None"
          ],
          "decorators": [],
          "source": "def _render_qweb_pdf_prepare_streams(self, report_ref, data, res_ids=None):\n        if not data:\n            data = {}\n        data.setdefault('report_type', 'pdf')\n\n        # access the report details with sudo() but evaluation context as current user\n        report_sudo = self._get_report(report_ref)\n        has_duplicated_ids = res_ids and len(res_ids) != len(set(res_ids))\n\n        collected_streams = OrderedDict()\n\n        # Fetch the existing attachments from the database for later use.\n        # Reload the stream from the attachment in case of 'attachment_use'.\n        if res_ids:\n            records = self.env[report_sudo.model].browse(res_ids)\n            for record in records:\n                res_id = record.id\n                if res_id in collected_streams:\n                    continue\n\n                stream = None\n                attachment = None\n                if not has_duplicated_ids and report_sudo.attachment and not self._context.get(\"report_pdf_no_attachment\"):\n                    attachment = report_sudo.retrieve_attachment(record)\n\n                    # Extract the stream from the attachment.\n                    if attachment and report_sudo.attachment_use:\n                        stream = io.BytesIO(attachment.raw)\n\n                        # Ensure the stream can be saved in Image.\n                        if attachment.mimetype.startswith('image'):\n                            img = Image.open(stream)\n                            new_stream = io.BytesIO()\n                            img.convert(\"RGB\").save(new_stream, format=\"pdf\")\n                            stream.close()\n                            stream = new_stream\n\n                collected_streams[res_id] = {\n                    'stream': stream,\n                    'attachment': attachment,\n                }\n\n        # Call 'wkhtmltopdf' to generate the missing streams.\n        res_ids_wo_stream = [res_id for res_id, stream_data in collected_streams.items() if not stream_data['stream']]\n        all_res_ids_wo_stream = res_ids if has_duplicated_ids else res_ids_wo_stream\n        is_whtmltopdf_needed = not res_ids or res_ids_wo_stream\n\n        if is_whtmltopdf_needed:\n\n            if self.get_wkhtmltopdf_state() == 'install':\n                # wkhtmltopdf is not installed\n                # the call should be catched before (cf /report/check_wkhtmltopdf) but\n                # if get_pdf is called manually (email template), the check could be\n                # bypassed\n                raise UserError(_(\"Unable to find Wkhtmltopdf on this system. The PDF can not be created.\"))\n\n            # Disable the debug mode in the PDF rendering in order to not split the assets bundle\n            # into separated files to load. This is done because of an issue in wkhtmltopdf\n            # failing to load the CSS/Javascript resources in time.\n            # Without this, the header/footer of the reports randomly disappear\n            # because the resources files are not loaded in time.\n            # https://github.com/wkhtmltopdf/wkhtmltopdf/issues/2083\n            additional_context = {'debug': False}\n            data.setdefault(\"debug\", False)\n\n            html = self.with_context(**additional_context)._render_qweb_html(report_ref, all_res_ids_wo_stream, data=data)[0]\n\n            bodies, html_ids, header, footer, specific_paperformat_args = self.with_context(**additional_context)._prepare_html(html, report_model=report_sudo.model)\n\n            if not has_duplicated_ids and report_sudo.attachment and set(res_ids_wo_stream) != set(html_ids):\n                raise UserError(_(\n                    \"The report's template %r is wrong, please contact your administrator. \\n\\n\"\n                    \"Can not separate file to save as attachment because the report's template does not contains the\"\n                    \" attributes 'data-oe-model' and 'data-oe-id' on the div with 'article' classname.\",\n                    report_sudo.name,\n                ))\n\n            pdf_content = self._run_wkhtmltopdf(\n                bodies,\n                report_ref=report_ref,\n                header=header,\n                footer=footer,\n                landscape=self._context.get('landscape'),\n                specific_paperformat_args=specific_paperformat_args,\n                set_viewport_size=self._context.get('set_viewport_size'),\n            )\n            pdf_content_stream = io.BytesIO(pdf_content)\n\n            # Printing a PDF report without any records. The content could be returned directly.\n            if has_duplicated_ids or not res_ids:\n                return {\n                    False: {\n                        'stream': pdf_content_stream,\n                        'attachment': None,\n                    }\n                }\n\n            # Split the pdf for each record using the PDF outlines.\n\n            # Only one record: append the whole PDF.\n            if len(res_ids_wo_stream) == 1:\n                collected_streams[res_ids_wo_stream[0]]['stream'] = pdf_content_stream\n                return collected_streams\n\n            # In case of multiple docs, we need to split the pdf according the records.\n            # In the simplest case of 1 res_id == 1 page, we use the PDFReader to print the\n            # pages one by one.\n            html_ids_wo_none = [x for x in html_ids if x]\n            reader = PdfFileReader(pdf_content_stream)\n            if reader.numPages == len(res_ids_wo_stream):\n                for i in range(reader.numPages):\n                    attachment_writer = PdfFileWriter()\n                    attachment_writer.addPage(reader.getPage(i))\n                    stream = io.BytesIO()\n                    attachment_writer.write(stream)\n                    collected_streams[res_ids_wo_stream[i]]['stream'] = stream\n                return collected_streams\n\n            # In cases where the number of res_ids != the number of pages,\n            # we split the pdf based on top outlines computed by wkhtmltopdf.\n            # An outline is a <h?> html tag found on the document. To retrieve this table,\n            # we look on the pdf structure using pypdf to compute the outlines_pages from\n            # the top level heading in /Outlines.\n            if len(res_ids_wo_stream) > 1 and set(res_ids_wo_stream) == set(html_ids_wo_none):\n                root = reader.trailer['/Root']\n                has_valid_outlines = '/Outlines' in root and '/First' in root['/Outlines']\n                if not has_valid_outlines:\n                    return {False: {\n                        'report_action': self,\n                        'stream': pdf_content_stream,\n                        'attachment': None,\n                    }}\n\n                outlines_pages = []\n                node = root['/Outlines']['/First']\n                while True:\n                    outlines_pages.append(root['/Dests'][node['/Dest']][0])\n                    if '/Next' not in node:\n                        break\n                    node = node['/Next']\n                outlines_pages = sorted(set(outlines_pages))\n\n                # The number of outlines must be equal to the number of records to be able to split the document.\n                has_same_number_of_outlines = len(outlines_pages) == len(res_ids_wo_stream)\n\n                # There should be a top-level heading on first page\n                has_top_level_heading = outlines_pages[0] == 0\n\n                if has_same_number_of_outlines and has_top_level_heading:\n                    # Split the PDF according to outlines.\n                    for i, num in enumerate(outlines_pages):\n                        to = outlines_pages[i + 1] if i + 1 < len(outlines_pages) else reader.numPages\n                        attachment_writer = PdfFileWriter()\n                        for j in range(num, to):\n                            attachment_writer.addPage(reader.getPage(j))\n                        stream = io.BytesIO()\n                        attachment_writer.write(stream)\n                        collected_streams[res_ids_wo_stream[i]]['stream'] = stream\n\n                    return collected_streams\n\n            collected_streams[False] = {'stream': pdf_content_stream, 'attachment': None}\n\n        return collected_streams",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_prepare_pdf_report_attachment_vals_list",
          "params": [
            "self",
            "report",
            "streams"
          ],
          "decorators": [],
          "source": "def _prepare_pdf_report_attachment_vals_list(self, report, streams):\n        \"\"\"Hook to prepare attachment values needed for attachments creation\n        during the pdf report generation.\n\n        :param report: The report (with sudo) from a reference report_ref.\n        :param streams: Dict of streams for each report containing the pdf content and existing attachments.\n        :return: attachment values list needed for attachments creation.\n        \"\"\"\n        attachment_vals_list = []\n        for res_id, stream_data in streams.items():\n            # An attachment already exists.\n            if stream_data['attachment']:\n                continue\n\n            # if res_id is false\n            # we are unable to fetch the record, it won't be saved as we can't split the documents unambiguously\n            if not res_id or not stream_data['stream']:\n                _logger.warning(\n                    \"These documents were not saved as an attachment because the template of %s doesn't \"\n                    \"have any headers seperating different instances of it. If you want it saved,\"\n                    \"please print the documents separately\", report.report_name)\n                continue\n            record = self.env[report.model].browse(res_id)\n            attachment_name = safe_eval(report.attachment, {'object': record, 'time': time})\n\n            # Unable to compute a name for the attachment.\n            if not attachment_name:\n                continue\n\n            attachment_vals_list.append({\n                'name': attachment_name,\n                'raw': stream_data['stream'].getvalue(),\n                'res_model': report.model,\n                'res_id': record.id,\n                'type': 'binary',\n            })\n        return attachment_vals_list",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_render_qweb_pdf",
          "params": [
            "self",
            "report_ref",
            "res_ids=None",
            "data=None"
          ],
          "decorators": [],
          "source": "def _render_qweb_pdf(self, report_ref, res_ids=None, data=None):\n        if not data:\n            data = {}\n        if isinstance(res_ids, int):\n            res_ids = [res_ids]\n        data.setdefault('report_type', 'pdf')\n        # In case of test environment without enough workers to perform calls to wkhtmltopdf,\n        # fallback to render_html.\n        if (tools.config['test_enable'] or tools.config['test_file']) and not self.env.context.get('force_report_rendering'):\n            return self._render_qweb_html(report_ref, res_ids, data=data)\n\n        self = self.with_context(webp_as_jpg=True)\n        collected_streams = self._render_qweb_pdf_prepare_streams(report_ref, data, res_ids=res_ids)\n        has_duplicated_ids = res_ids and len(res_ids) != len(set(res_ids))\n\n        # access the report details with sudo() but keep evaluation context as current user\n        report_sudo = self._get_report(report_ref)\n\n        # Generate the ir.attachment if needed.\n        if not has_duplicated_ids and report_sudo.attachment and not self._context.get(\"report_pdf_no_attachment\"):\n            attachment_vals_list = self._prepare_pdf_report_attachment_vals_list(report_sudo, collected_streams)\n            if attachment_vals_list:\n                attachment_names = ', '.join(x['name'] for x in attachment_vals_list)\n                try:\n                    self.env['ir.attachment'].create(attachment_vals_list)\n                except AccessError:\n                    _logger.info(\"Cannot save PDF report %r attachments for user %r\", attachment_names, self.env.user.display_name)\n                else:\n                    _logger.info(\"The PDF documents %r are now saved in the database\", attachment_names)\n\n        stream_to_ids = {v['stream']: k for k, v in collected_streams.items() if v['stream']}\n        # Merge all streams together for a single record.\n        streams_to_merge = list(stream_to_ids.keys())\n        error_record_ids = []\n\n        if len(streams_to_merge) == 1:\n            pdf_content = streams_to_merge[0].getvalue()\n        else:\n            with self.with_context(\n                    custom_error_handler=lambda error_stream: error_record_ids.append(stream_to_ids[error_stream])\n            )._merge_pdfs(streams_to_merge) as pdf_merged_stream:\n                pdf_content = pdf_merged_stream.getvalue()\n\n        if error_record_ids:\n            action = {\n                'type': 'ir.actions.act_window',\n                'name': _('Problematic record(s)'),\n                'res_model': report_sudo.model,\n                'domain': [('id', 'in', error_record_ids)],\n                'views': [(False, 'tree'), (False, 'form')],\n            }\n            num_errors = len(error_record_ids)\n            if num_errors == 1:\n                action.update({\n                    'views': [(False, 'form')],\n                    'res_id': error_record_ids[0],\n                })\n            raise RedirectWarning(\n                message=_('Odoo is unable to merge the generated PDFs because of %(num_errors)s corrupted file(s)', num_errors=num_errors),\n                action=action,\n                button_text=_('View Problematic Record(s)'),\n            )\n\n        for stream in streams_to_merge:\n            stream.close()\n\n        if res_ids:\n            _logger.info(\"The PDF report has been generated for model: %s, records %s.\", report_sudo.model, str(res_ids))\n\n        return pdf_content, 'pdf'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_render_qweb_text",
          "params": [
            "self",
            "report_ref",
            "docids",
            "data=None"
          ],
          "decorators": [],
          "source": "def _render_qweb_text(self, report_ref, docids, data=None):\n        if not data:\n            data = {}\n        data.setdefault('report_type', 'text')\n        report = self._get_report(report_ref)\n        data = self._get_rendering_context(report, docids, data)\n        return self._render_template(report.report_name, data), 'text'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_render_qweb_html",
          "params": [
            "self",
            "report_ref",
            "docids",
            "data=None"
          ],
          "decorators": [],
          "source": "def _render_qweb_html(self, report_ref, docids, data=None):\n        if not data:\n            data = {}\n        data.setdefault('report_type', 'html')\n        report = self._get_report(report_ref)\n        data = self._get_rendering_context(report, docids, data)\n        return self._render_template(report.report_name, data), 'html'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_rendering_context_model",
          "params": [
            "self",
            "report"
          ],
          "decorators": [],
          "source": "def _get_rendering_context_model(self, report):\n        report_model_name = 'report.%s' % report.report_name\n        return self.env.get(report_model_name)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_rendering_context",
          "params": [
            "self",
            "report",
            "docids",
            "data"
          ],
          "decorators": [],
          "source": "def _get_rendering_context(self, report, docids, data):\n        # If the report is using a custom model to render its html, we must use it.\n        # Otherwise, fallback on the generic html rendering.\n        report_model = self._get_rendering_context_model(report)\n\n        data = data and dict(data) or {}\n\n        if report_model is not None:\n            data.update(report_model._get_report_values(docids, data=data))\n        else:\n            docs = self.env[report.model].browse(docids)\n            data.update({\n                'doc_ids': docids,\n                'doc_model': report.model,\n                'docs': docs,\n            })\n        data['is_html_empty'] = is_html_empty\n        return data",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_render",
          "params": [
            "self",
            "report_ref",
            "res_ids",
            "data=None"
          ],
          "decorators": [],
          "source": "def _render(self, report_ref, res_ids, data=None):\n        report = self._get_report(report_ref)\n        report_type = report.report_type.lower().replace('-', '_')\n        render_func = getattr(self, '_render_' + report_type, None)\n        if not render_func:\n            return None\n        return render_func(report_ref, res_ids, data=data)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "report_action",
          "params": [
            "self",
            "docids",
            "data=None",
            "config=True"
          ],
          "decorators": [],
          "source": "def report_action(self, docids, data=None, config=True):\n        \"\"\"Return an action of type ir.actions.report.\n\n        :param docids: id/ids/browse record of the records to print (if not used, pass an empty list)\n        :param data:\n        :param bool config:\n        :rtype: bytes\n        \"\"\"\n        context = self.env.context\n        if docids:\n            if isinstance(docids, models.Model):\n                active_ids = docids.ids\n            elif isinstance(docids, int):\n                active_ids = [docids]\n            elif isinstance(docids, list):\n                active_ids = docids\n            context = dict(self.env.context, active_ids=active_ids)\n\n        report_action = {\n            'context': context,\n            'data': data,\n            'type': 'ir.actions.report',\n            'report_name': self.report_name,\n            'report_type': self.report_type,\n            'report_file': self.report_file,\n            'name': self.name,\n        }\n\n        discard_logo_check = self.env.context.get('discard_logo_check')\n        if self.env.is_admin() and not self.env.company.external_report_layout_id and config and not discard_logo_check:\n            return self._action_configure_external_report_layout(report_action)\n\n        return report_action",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_action_configure_external_report_layout",
          "params": [
            "self",
            "report_action"
          ],
          "decorators": [],
          "source": "def _action_configure_external_report_layout(self, report_action):\n        action = self.env[\"ir.actions.actions\"]._for_xml_id(\"web.action_base_document_layout_configurator\")\n        py_ctx = json.loads(action.get('context', {}))\n        report_action['close_on_report_download'] = True\n        py_ctx['report_action'] = report_action\n        py_ctx['dialog_size'] = 'large'\n        action['context'] = py_ctx\n        return action",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.actions.actions"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_wkhtmltopdf_state (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_build_wkhtmltopdf_args (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_run_wkhtmltopdf (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_report_from_name (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_report (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "barcode (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_available_barcode_masks (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_merge_pdfs (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_render_qweb_text (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_render_qweb_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_render (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrActionsReport"
    },
    {
      "name": "ir.asset",
      "description": "Asset",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Name"
        },
        {
          "name": "bundle",
          "type": "Char",
          "required": true,
          "string": "Bundle name"
        },
        {
          "name": "directive",
          "type": "Selection",
          "string": "Directive"
        },
        {
          "name": "path",
          "type": "Char"
        },
        {
          "name": "target",
          "type": "Char",
          "string": "Target"
        },
        {
          "name": "active",
          "type": "Boolean",
          "string": "active"
        },
        {
          "name": "sequence",
          "type": "Integer",
          "required": true,
          "string": "Sequence"
        }
      ],
      "methods": [
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.env.registry.clear_cache('assets')\n        return super().create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        if self:\n            self.env.registry.clear_cache('assets')\n        return super().write(values)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self.env.registry.clear_cache('assets')\n        return super().unlink()\n\n    name = fields.Char(string='Name', required=True)\n    bundle = fields.Char(string='Bundle name', required=True)\n    directive = fields.Selection(string='Directive', selection=[\n        (APPEND_DIRECTIVE, 'Append'),\n        (PREPEND_DIRECTIVE, 'Prepend'),\n        (AFTER_DIRECTIVE, 'After'),\n        (BEFORE_DIRECTIVE, 'Before'),\n        (REMOVE_DIRECTIVE, 'Remove'),\n        (REPLACE_DIRECTIVE, 'Replace'),\n        (INCLUDE_DIRECTIVE, 'Include')], default=APPEND_DIRECTIVE)\n    path = fields.Char(string='Path (or glob pattern)', required=True)\n    target = fields.Char(string='Target')\n    active = fields.Boolean(string='active', default=True)\n    sequence = fields.Integer(string=\"Sequence\", default=DEFAULT_SEQUENCE, required=True)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_params",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_asset_params(self):\n        \"\"\"\n        This method can be overriden to add param _get_asset_paths call.\n        Those params will be part of the orm cache key\n        \"\"\"\n        return {}",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_bundle_url",
          "params": [
            "self",
            "filename",
            "unique",
            "assets_params",
            "ignore_params=False"
          ],
          "decorators": [],
          "source": "def _get_asset_bundle_url(self, filename, unique, assets_params, ignore_params=False):\n        return f'/web/assets/{unique}/{filename}'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_parse_bundle_name",
          "params": [
            "self",
            "bundle_name",
            "debug_assets"
          ],
          "decorators": [],
          "source": "def _parse_bundle_name(self, bundle_name, debug_assets):\n        bundle_name, asset_type = bundle_name.rsplit('.', 1)\n        rtl = False\n        if not debug_assets:\n            bundle_name, min_ = bundle_name.rsplit('.', 1)\n            if min_ != 'min':\n                raise ValueError(\"'min' expected in extension in non debug mode\")\n        if asset_type == 'css':\n            if bundle_name.endswith('.rtl'):\n                bundle_name = bundle_name[:-4]\n                rtl = True\n        elif asset_type != 'js':\n            raise ValueError('Only js and css assets bundle are supported for now')\n        if len(bundle_name.split('.')) != 2:\n            raise ValueError(f'{bundle_name} is not a valid bundle name, should have two parts')\n        return bundle_name, rtl, asset_type",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_paths",
          "params": [
            "self",
            "bundle",
            "assets_params"
          ],
          "decorators": [],
          "source": "def _get_asset_paths(self, bundle, assets_params):\n        \"\"\"\n        Fetches all asset file paths from a given list of addons matching a\n        certain bundle. The returned list is composed of tuples containing the\n        file path [1], the first addon calling it [0] and the bundle name.\n        Asset loading is performed as follows:\n\n        1. All 'ir.asset' records matching the given bundle and with a sequence\n        strictly less than 16 are applied.\n\n        3. The manifests of the given addons are checked for assets declaration\n        for the given bundle. If any, they are read sequentially and their\n        operations are applied to the current list.\n\n        4. After all manifests have been parsed, the remaining 'ir.asset'\n        records matching the bundle are also applied to the current list.\n\n        :param bundle: name of the bundle from which to fetch the file paths\n        :param assets_params: parameters needed by overrides, mainly website_id\n            see _get_asset_params\n        :returns: the list of tuples (path, addon, bundle)\n        \"\"\"\n        installed = self._get_installed_addons_list()\n        addons = self._get_active_addons_list(**assets_params)\n\n        asset_paths = AssetPaths()\n\n        addons = self._topological_sort(tuple(addons))\n\n        self._fill_asset_paths(bundle, asset_paths, [], addons, installed, **assets_params)\n        return asset_paths.list",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_fill_asset_paths",
          "params": [
            "self",
            "bundle",
            "asset_paths",
            "seen",
            "addons",
            "installed",
            "**assets_params"
          ],
          "decorators": [],
          "source": "def _fill_asset_paths(self, bundle, asset_paths, seen, addons, installed, **assets_params):\n        \"\"\"\n        Fills the given AssetPaths instance by applying the operations found in\n        the matching bundle of the given addons manifests.\n        See `_get_asset_paths` for more information.\n\n        :param bundle: name of the bundle from which to fetch the file paths\n        :param addons: list of addon names as strings\n        :param css: boolean: whether or not to include style files\n        :param js: boolean: whether or not to include script files\n        :param xml: boolean: whether or not to include template files\n        :param asset_paths: the AssetPath object to fill\n        :param seen: a list of bundles already checked to avoid circularity\n        \"\"\"\n        if bundle in seen:\n            raise Exception(\"Circular assets bundle declaration: %s\" % \" > \".join(seen + [bundle]))\n\n        # this index is used for prepending: files are inserted at the beginning\n        # of the CURRENT bundle.\n        bundle_start_index = len(asset_paths.list)\n\n        assets = self._get_related_assets([('bundle', '=', bundle)], **assets_params).filtered('active')\n        # 1. Process the first sequence of 'ir.asset' records\n        for asset in assets.filtered(lambda a: a.sequence < DEFAULT_SEQUENCE):\n            self._process_path(bundle, asset.directive, asset.target, asset.path, asset_paths, seen, addons, installed, bundle_start_index, **assets_params)\n\n        # 2. Process all addons' manifests.\n        for addon in addons:\n            for command in odoo.modules.module._get_manifest_cached(addon)['assets'].get(bundle, ()):\n                directive, target, path_def = self._process_command(command)\n                self._process_path(bundle, directive, target, path_def, asset_paths, seen, addons, installed, bundle_start_index, **assets_params)\n\n        # 3. Process the rest of 'ir.asset' records\n        for asset in assets.filtered(lambda a: a.sequence >= DEFAULT_SEQUENCE):\n            self._process_path(bundle, asset.directive, asset.target, asset.path, asset_paths, seen, addons, installed, bundle_start_index, **assets_params)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_process_path",
          "params": [
            "self",
            "bundle",
            "directive",
            "target",
            "path_def",
            "asset_paths",
            "seen",
            "addons",
            "installed",
            "bundle_start_index",
            "**assets_params"
          ],
          "decorators": [],
          "source": "def _process_path(self, bundle, directive, target, path_def, asset_paths, seen, addons, installed, bundle_start_index, **assets_params):\n        \"\"\"\n        This sub function is meant to take a directive and a set of\n        arguments and apply them to the current asset_paths list\n        accordingly.\n\n        It is nested inside `_get_asset_paths` since we need the current\n        list of addons, extensions and asset_paths.\n\n        :param directive: string\n        :param target: string or None or False\n        :param path_def: string\n        \"\"\"\n        if directive == INCLUDE_DIRECTIVE:\n            # recursively call this function for each INCLUDE_DIRECTIVE directive.\n            self._fill_asset_paths(path_def, asset_paths, seen + [bundle], addons, installed, **assets_params)\n            return\n        if can_aggregate(path_def):\n            paths = self._get_paths(path_def, installed)\n        else:\n            paths = [(path_def, EXTERNAL_ASSET, -1)]  # external urls\n\n        # retrieve target index when it applies\n        if directive in DIRECTIVES_WITH_TARGET:\n            target_paths = self._get_paths(target, installed)\n            if not target_paths and target.rpartition('.')[2] not in ASSET_EXTENSIONS:\n                # nothing to do: the extension of the target is wrong\n                return\n            if target_paths:\n                target = target_paths[0][0]\n            target_index = asset_paths.index(target, bundle)\n\n        if directive == APPEND_DIRECTIVE:\n            asset_paths.append(paths, bundle)\n        elif directive == PREPEND_DIRECTIVE:\n            asset_paths.insert(paths, bundle, bundle_start_index)\n        elif directive == AFTER_DIRECTIVE:\n            asset_paths.insert(paths, bundle, target_index + 1)\n        elif directive == BEFORE_DIRECTIVE:\n            asset_paths.insert(paths, bundle, target_index)\n        elif directive == REMOVE_DIRECTIVE:\n            asset_paths.remove(paths, bundle)\n        elif directive == REPLACE_DIRECTIVE:\n            asset_paths.insert(paths, bundle, target_index)\n            asset_paths.remove(target_paths, bundle)\n        else:\n            # this should never happen\n            raise ValueError(\"Unexpected directive\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_related_assets",
          "params": [
            "self",
            "domain"
          ],
          "decorators": [],
          "source": "def _get_related_assets(self, domain):\n        \"\"\"\n        Returns a set of assets matching the domain, regardless of their\n        active state. This method can be overridden to filter the results.\n        :param domain: search domain\n        :returns: ir.asset recordset\n        \"\"\"\n        # active_test is needed to disable some assets through filter_duplicate for website\n        # they will be filtered on active afterward\n        return self.with_context(active_test=False).sudo().search(domain, order='sequence, id')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_related_bundle",
          "params": [
            "self",
            "target_path_def",
            "root_bundle"
          ],
          "decorators": [],
          "source": "def _get_related_bundle(self, target_path_def, root_bundle):\n        \"\"\"\n        Returns the first bundle directly defining a glob matching the target\n        path. This is useful when generating an 'ir.asset' record to override\n        a specific asset and target the right bundle, i.e. the first one\n        defining the target path.\n\n        :param target_path_def: string: path to match.\n        :root_bundle: string: bundle from which to initiate the search.\n        :returns: the first matching bundle or None\n        \"\"\"\n        installed = self._get_installed_addons_list()\n        target_path, _full_path, _modified = self._get_paths(target_path_def, installed)[0]\n        assets_params = self._get_asset_params()\n        asset_paths = self._get_asset_paths(root_bundle, assets_params)\n\n        for path, _full_path, bundle, _modified in asset_paths:\n            if path == target_path:\n                return bundle\n\n        return root_bundle",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_active_addons_list",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_active_addons_list(self):\n        \"\"\"Can be overridden to filter the returned list of active modules.\"\"\"\n        return self._get_installed_addons_list()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_topological_sort",
          "params": [
            "self",
            "addons_tuple"
          ],
          "decorators": [],
          "source": "def _topological_sort(self, addons_tuple):\n        \"\"\"Returns a list of sorted modules name accord to the spec in ir.module.module\n        that is, application desc, sequence, name then topologically sorted\"\"\"\n        IrModule = self.env['ir.module.module']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "mapper",
          "params": [
            "addon"
          ],
          "decorators": [],
          "source": "def mapper(addon):\n            manif = odoo.modules.module._get_manifest_cached(addon)\n            from_terp = IrModule.get_values_from_terp(manif)\n            from_terp['name'] = addon\n            from_terp['depends'] = manif.get('depends', ['base'])\n            return from_terp\n\n        manifs = map(mapper, addons_tuple)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "sort_key",
          "params": [
            "manif"
          ],
          "decorators": [],
          "source": "def sort_key(manif):\n            return (not manif['application'], int(manif['sequence']), manif['name'])\n\n        manifs = sorted(manifs, key=sort_key)\n\n        return misc.topological_sort({manif['name']: tuple(manif['depends']) for manif in manifs})",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_installed_addons_list",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_installed_addons_list(self):\n        \"\"\"\n        Returns the list of all installed addons.\n        :returns: string[]: list of module names\n        \"\"\"\n        # Main source: the current registry list\n        # Second source of modules: server wide modules\n        return self.env.registry._init_modules.union(odoo.conf.server_wide_modules or [])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_paths",
          "params": [
            "self",
            "path_def",
            "installed"
          ],
          "decorators": [],
          "source": "def _get_paths(self, path_def, installed):\n        \"\"\"\n        Returns a list of tuple (path, full_path, modified) matching a given glob (path_def).\n        The glob can only occur in the static direcory of an installed addon.\n\n        If the path_def matches a (list of) file, the result will contain the full_path\n        and the modified time.\n        Ex: ('/base/static/file.js', '/home/user/source/odoo/odoo/addons/base/static/file.js', 643636800)\n\n        If the path_def looks like a non aggregable path (http://, /web/assets), only return the path\n        Ex: ('http://example.com/lib.js', None, -1)\n        The timestamp -1 is given to be thruthy while carrying no information.\n\n        If the path_def is not a wildward, but may still be a valid addons path, return a False path\n        with No timetamp\n        Ex: ('/_custom/web.asset_frontend', False, None)\n\n        :param path_def: the definition (glob) of file paths to match\n        :param installed: the list of installed addons\n        :param extensions: a list of extensions that found files must match\n        :returns: a list of tuple: (path, full_path, modified)\n        \"\"\"\n        paths = None\n        path_def = fs2web(path_def)  # we expect to have all path definition unix style or url style, this is a safety\n        path_parts = [part for part in path_def.split('/') if part]\n        addon = path_parts[0]\n        addon_manifest = odoo.modules.module._get_manifest_cached(addon)\n\n        safe_path = True\n        if addon_manifest:\n            if addon not in installed:\n                # Assert that the path is in the installed addons\n                raise Exception(f\"Unallowed to fetch files from addon {addon} for file {path_def}\")\n            addons_path = addon_manifest['addons_path']\n            full_path = os.path.normpath(os.sep.join([addons_path, *path_parts]))\n            # forbid escape from the current addon\n            # \"/mymodule/../myothermodule\" is forbidden\n            static_prefix = os.sep.join([addons_path, addon, 'static', ''])\n            if full_path.startswith(static_prefix):\n                paths_with_timestamps = _glob_static_file(full_path)\n                paths = [\n                    (fs2web(absolute_path[len(addons_path):]), absolute_path, timestamp)\n                    for absolute_path, timestamp in paths_with_timestamps\n                ]\n            else:\n                safe_path = False\n        else:\n            safe_path = False\n\n        if not paths and not can_aggregate(path_def):  # http:// or /web/content\n            paths = [(path_def, EXTERNAL_ASSET, -1)]\n\n        if not paths and not is_wildcard_glob(path_def):  # an attachment url most likely\n            paths = [(path_def, None, None)]\n\n        if not paths:\n            msg = f'IrAsset: the path \"{path_def}\" did not resolve to anything.'\n            if not safe_path:\n                msg += \" It may be due to security reasons.\"\n            _logger.warning(msg)\n        # Paths are filtered on the extensions (if any).\n        return paths",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_process_command",
          "params": [
            "self",
            "command"
          ],
          "decorators": [],
          "source": "def _process_command(self, command):\n        \"\"\"Parses a given command to return its directive, target and path definition.\"\"\"\n        if isinstance(command, str):\n            # Default directive: append\n            directive, target, path_def = APPEND_DIRECTIVE, None, command\n        elif command[0] in DIRECTIVES_WITH_TARGET:\n            directive, target, path_def = command\n        else:\n            directive, path_def = command\n            target = None\n        return directive, target, path_def",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "__init__",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def __init__(self):\n        self.list = []\n        self.memo = set()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "index",
          "params": [
            "self",
            "path",
            "bundle"
          ],
          "decorators": [],
          "source": "def index(self, path, bundle):\n        \"\"\"Returns the index of the given path in the current assets list.\"\"\"\n        if path not in self.memo:\n            self._raise_not_found(path, bundle)\n        for index, asset in enumerate(self.list):\n            if asset[0] == path:\n                return index",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "append",
          "params": [
            "self",
            "paths",
            "bundle"
          ],
          "decorators": [],
          "source": "def append(self, paths, bundle):\n        \"\"\"Appends the given paths to the current list.\"\"\"\n        for path, full_path, last_modified in paths:\n            if path not in self.memo:\n                self.list.append((path, full_path, bundle, last_modified))\n                self.memo.add(path)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "insert",
          "params": [
            "self",
            "paths",
            "bundle",
            "index"
          ],
          "decorators": [],
          "source": "def insert(self, paths, bundle, index):\n        \"\"\"Inserts the given paths to the current list at the given position.\"\"\"\n        to_insert = []\n        for path, full_path, last_modified in paths:\n            if path not in self.memo:\n                to_insert.append((path, full_path, bundle, last_modified))\n                self.memo.add(path)\n        self.list[index:index] = to_insert",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "remove",
          "params": [
            "self",
            "paths_to_remove",
            "bundle"
          ],
          "decorators": [],
          "source": "def remove(self, paths_to_remove, bundle):\n        \"\"\"Removes the given paths from the current list.\"\"\"\n        paths = {path for path, _full_path, _last_modified in paths_to_remove if path in self.memo}\n        if paths:\n            self.list[:] = [asset for asset in self.list if asset[0] not in paths]\n            self.memo.difference_update(paths)\n            return\n\n        if paths_to_remove:\n            self._raise_not_found([path for path, _full_path, _last_modified in paths_to_remove], bundle)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_raise_not_found",
          "params": [
            "self",
            "path",
            "bundle"
          ],
          "decorators": [],
          "source": "def _raise_not_found(self, path, bundle):\n        raise ValueError(\"File(s) %s not found in bundle %s\" % (path, bundle))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrAsset"
    },
    {
      "name": "ir.attachment",
      "description": "Attachment",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "description",
          "type": "Text"
        },
        {
          "name": "res_name",
          "type": "Char"
        },
        {
          "name": "res_model",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "res_field",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "res_id",
          "type": "Many2oneReference",
          "relation": "Resource ID",
          "readonly": true
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company",
          "string": "Company"
        },
        {
          "name": "type",
          "type": "Selection"
        },
        {
          "name": "url",
          "type": "Char"
        },
        {
          "name": "public",
          "type": "Boolean"
        },
        {
          "name": "access_token",
          "type": "Char"
        },
        {
          "name": "raw",
          "type": "Binary"
        },
        {
          "name": "datas",
          "type": "Binary"
        },
        {
          "name": "db_datas",
          "type": "Binary"
        },
        {
          "name": "store_fname",
          "type": "Char"
        },
        {
          "name": "file_size",
          "type": "Integer",
          "readonly": true
        },
        {
          "name": "checksum",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "mimetype",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "index_content",
          "type": "Text",
          "readonly": true
        }
      ],
      "methods": [
        {
          "name": "_compute_res_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_res_name(self):\n        for attachment in self:\n            if attachment.res_model and attachment.res_id:\n                record = self.env[attachment.res_model].browse(attachment.res_id)\n                attachment.res_name = record.display_name\n            else:\n                attachment.res_name = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_storage",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _storage(self):\n        return self.env['ir.config_parameter'].sudo().get_param('ir_attachment.location', 'file')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_filestore",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _filestore(self):\n        return config.filestore(self._cr.dbname)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_storage_domain",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_storage_domain(self):\n        # domain to retrieve the attachments to migrate\n        return {\n            'db': [('store_fname', '!=', False)],\n            'file': [('db_datas', '!=', False)],\n        }[self._storage()]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "force_storage",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def force_storage(self):\n        \"\"\"Force all attachments to be stored in the currently configured storage\"\"\"\n        if not self.env.is_admin():\n            raise AccessError(_('Only administrators can execute this action.'))\n\n        # Migrate only binary attachments and bypass the res_field automatic\n        # filter added in _search override\n        self.search(expression.AND([\n            self._get_storage_domain(),\n            ['&', ('type', '=', 'binary'), '|', ('res_field', '=', False), ('res_field', '!=', False)]\n        ]))._migrate()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_migrate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _migrate(self):\n        record_count = len(self)\n        storage = self._storage().upper()\n        # When migrating to filestore verifying if the directory has write permission\n        if storage == 'FILE':\n            filestore = self._filestore()\n            if not os.access(filestore, os.W_OK):\n                raise PermissionError(\"Write permission denied for filestore directory.\")\n        for index, attach in enumerate(self):\n            _logger.debug(\"Migrate attachment %s/%s to %s\", index + 1, record_count, storage)\n            # pass mimetype, to avoid recomputation\n            attach.write({'raw': attach.raw, 'mimetype': attach.mimetype})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_full_path",
          "params": [
            "self",
            "path"
          ],
          "decorators": [],
          "source": "def _full_path(self, path):\n        # sanitize path\n        path = re.sub('[.]', '', path)\n        path = path.strip('/\\\\')\n        return os.path.join(self._filestore(), path)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_path",
          "params": [
            "self",
            "bin_data",
            "sha"
          ],
          "decorators": [],
          "source": "def _get_path(self, bin_data, sha):\n        # retro compatibility\n        fname = sha[:3] + '/' + sha\n        full_path = self._full_path(fname)\n        if os.path.isfile(full_path):\n            return fname, full_path        # keep existing path\n\n        # scatter files across 256 dirs\n        # we use '/' in the db (even on windows)\n        fname = sha[:2] + '/' + sha\n        full_path = self._full_path(fname)\n        dirname = os.path.dirname(full_path)\n        if not os.path.isdir(dirname):\n            os.makedirs(dirname, exist_ok=True)\n        # prevent sha-1 collision\n        if os.path.isfile(full_path) and not self._same_content(bin_data, full_path):\n            raise UserError(_(\"The attachment collides with an existing file.\"))\n        return fname, full_path",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_file_read",
          "params": [
            "self",
            "fname"
          ],
          "decorators": [],
          "source": "def _file_read(self, fname):\n        assert isinstance(self, IrAttachment)\n        full_path = self._full_path(fname)\n        try:\n            with open(full_path, 'rb') as f:\n                return f.read()\n        except (IOError, OSError):\n            _logger.info(\"_read_file reading %s\", full_path, exc_info=True)\n        return b''",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_file_write",
          "params": [
            "self",
            "bin_value",
            "checksum"
          ],
          "decorators": [],
          "source": "def _file_write(self, bin_value, checksum):\n        assert isinstance(self, IrAttachment)\n        fname, full_path = self._get_path(bin_value, checksum)\n        if not os.path.exists(full_path):\n            try:\n                with open(full_path, 'wb') as fp:\n                    fp.write(bin_value)\n                # add fname to checklist, in case the transaction aborts\n                self._mark_for_gc(fname)\n            except IOError:\n                _logger.info(\"_file_write writing %s\", full_path, exc_info=True)\n        return fname",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_file_delete",
          "params": [
            "self",
            "fname"
          ],
          "decorators": [],
          "source": "def _file_delete(self, fname):\n        # simply add fname to checklist, it will be garbage-collected later\n        self._mark_for_gc(fname)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_mark_for_gc",
          "params": [
            "self",
            "fname"
          ],
          "decorators": [],
          "source": "def _mark_for_gc(self, fname):\n        \"\"\" Add ``fname`` in a checklist for the filestore garbage collection. \"\"\"\n        assert isinstance(self, IrAttachment)\n        fname = re.sub('[.]', '', fname).strip('/\\\\')\n        # we use a spooldir: add an empty file in the subdirectory 'checklist'\n        full_path = os.path.join(self._full_path('checklist'), fname)\n        if not os.path.exists(full_path):\n            dirname = os.path.dirname(full_path)\n            if not os.path.isdir(dirname):\n                with contextlib.suppress(OSError):\n                    os.makedirs(dirname)\n            open(full_path, 'ab').close()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_gc_file_store",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _gc_file_store(self):\n        \"\"\" Perform the garbage collection of the filestore. \"\"\"\n        assert isinstance(self, IrAttachment)\n        if self._storage() != 'file':\n            return\n\n        # Continue in a new transaction. The LOCK statement below must be the\n        # first one in the current transaction, otherwise the database snapshot\n        # used by it may not contain the most recent changes made to the table\n        # ir_attachment! Indeed, if concurrent transactions create attachments,\n        # the LOCK statement will wait until those concurrent transactions end.\n        # But this transaction will not see the new attachements if it has done\n        # other requests before the LOCK (like the method _storage() above).\n        cr = self._cr\n        cr.commit()\n\n        # prevent all concurrent updates on ir_attachment while collecting,\n        # but only attempt to grab the lock for a little bit, otherwise it'd\n        # start blocking other transactions. (will be retried later anyway)\n        cr.execute(\"SET LOCAL lock_timeout TO '10s'\")\n        try:\n            cr.execute(\"LOCK ir_attachment IN SHARE MODE\")\n        except psycopg2.errors.LockNotAvailable:\n            cr.rollback()\n            return False\n\n        self._gc_file_store_unsafe()\n\n        # commit to release the lock\n        cr.commit()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_gc_file_store_unsafe",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _gc_file_store_unsafe(self):\n        # retrieve the file names from the checklist\n        checklist = {}\n        for dirpath, _, filenames in os.walk(self._full_path('checklist')):\n            dirname = os.path.basename(dirpath)\n            for filename in filenames:\n                fname = \"%s/%s\" % (dirname, filename)\n                checklist[fname] = os.path.join(dirpath, filename)\n\n        # Clean up the checklist. The checklist is split in chunks and files are garbage-collected\n        # for each chunk.\n        removed = 0\n        for names in self.env.cr.split_for_in_conditions(checklist):\n            # determine which files to keep among the checklist\n            self.env.cr.execute(\"SELECT store_fname FROM ir_attachment WHERE store_fname IN %s\", [names])\n            whitelist = set(row[0] for row in self.env.cr.fetchall())\n\n            # remove garbage files, and clean up checklist\n            for fname in names:\n                filepath = checklist[fname]\n                if fname not in whitelist:\n                    try:\n                        os.unlink(self._full_path(fname))\n                        _logger.debug(\"_file_gc unlinked %s\", self._full_path(fname))\n                        removed += 1\n                    except (OSError, IOError):\n                        _logger.info(\"_file_gc could not unlink %s\", self._full_path(fname), exc_info=True)\n                with contextlib.suppress(OSError):\n                    os.unlink(filepath)\n\n        _logger.info(\"filestore gc %d checked, %d removed\", len(checklist), removed)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_datas",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_datas(self):\n        if self._context.get('bin_size'):\n            for attach in self:\n                attach.datas = human_size(attach.file_size)\n            return\n\n        for attach in self:\n            attach.datas = base64.b64encode(attach.raw or b'')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_raw",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_raw(self):\n        for attach in self:\n            if attach.store_fname:\n                attach.raw = attach._file_read(attach.store_fname)\n            else:\n                attach.raw = attach.db_datas",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_raw",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_raw(self):\n        self._set_attachment_data(lambda a: a.raw or b'')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_datas",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_datas(self):\n        self._set_attachment_data(lambda attach: base64.b64decode(attach.datas or b''))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_attachment_data",
          "params": [
            "self",
            "asbytes"
          ],
          "decorators": [],
          "source": "def _set_attachment_data(self, asbytes):\n        for attach in self:\n            # compute the fields that depend on datas\n            bin_data = asbytes(attach)\n            vals = self._get_datas_related_values(bin_data, attach.mimetype)\n\n            # take current location in filestore to possibly garbage-collect it\n            fname = attach.store_fname\n            # write as superuser, as user probably does not have write access\n            super(IrAttachment, attach.sudo()).write(vals)\n            if fname:\n                self._file_delete(fname)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_datas_related_values",
          "params": [
            "self",
            "data",
            "mimetype"
          ],
          "decorators": [],
          "source": "def _get_datas_related_values(self, data, mimetype):\n        checksum = self._compute_checksum(data)\n        try:\n            index_content = self._index(data, mimetype, checksum=checksum)\n        except TypeError:\n            index_content = self._index(data, mimetype)\n        values = {\n            'file_size': len(data),\n            'checksum': checksum,\n            'index_content': index_content,\n            'store_fname': False,\n            'db_datas': data,\n        }\n        if data and self._storage() != 'db':\n            values['store_fname'] = self._file_write(data, values['checksum'])\n            values['db_datas'] = False\n        return values",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_checksum",
          "params": [
            "self",
            "bin_data"
          ],
          "decorators": [],
          "source": "def _compute_checksum(self, bin_data):\n        \"\"\" compute the checksum for the given datas\n            :param bin_data : datas in its binary form\n        \"\"\"\n        # an empty file has a checksum too (for caching)\n        return hashlib.sha1(bin_data or b'').hexdigest()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_same_content",
          "params": [
            "self",
            "bin_data",
            "filepath"
          ],
          "decorators": [],
          "source": "def _same_content(self, bin_data, filepath):\n        BLOCK_SIZE = 1024\n        with open(filepath, 'rb') as fd:\n            i = 0\n            while True:\n                data = fd.read(BLOCK_SIZE)\n                if data != bin_data[i * BLOCK_SIZE:(i + 1) * BLOCK_SIZE]:\n                    return False\n                if not data:\n                    break\n                i += 1\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_mimetype",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _compute_mimetype(self, values):\n        \"\"\" compute the mimetype of the given values\n            :param values : dict of values to create or write an ir_attachment\n            :return mime : string indicating the mimetype, or application/octet-stream by default\n        \"\"\"\n        mimetype = None\n        if values.get('mimetype'):\n            mimetype = values['mimetype']\n        if not mimetype and values.get('name'):\n            mimetype = mimetypes.guess_type(values['name'])[0]\n        if not mimetype and values.get('url'):\n            mimetype = mimetypes.guess_type(values['url'].split('?')[0])[0]\n        if not mimetype or mimetype == 'application/octet-stream':\n            raw = None\n            if values.get('raw'):\n                raw = values['raw']\n            elif values.get('datas'):\n                raw = base64.b64decode(values['datas'])\n            if raw:\n                mimetype = guess_mimetype(raw)\n        return mimetype and mimetype.lower() or 'application/octet-stream'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_contents",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _postprocess_contents(self, values):\n        ICP = self.env['ir.config_parameter'].sudo().get_param\n        supported_subtype = ICP('base.image_autoresize_extensions', 'png,jpeg,bmp,tiff').split(',')\n\n        mimetype = values['mimetype'] = self._compute_mimetype(values)\n        _type, _match, _subtype = mimetype.partition('/')\n        is_image_resizable = _type == 'image' and _subtype in supported_subtype\n        if is_image_resizable and (values.get('datas') or values.get('raw')):\n            is_raw = values.get('raw')\n\n            # Can be set to 0 to skip the resize\n            max_resolution = ICP('base.image_autoresize_max_px', '1920x1920')\n            if str2bool(max_resolution, True):\n                try:\n                    img = False\n                    if is_raw:\n                        img = ImageProcess(values['raw'], verify_resolution=False)\n                    else:  # datas\n                        img = ImageProcess(base64.b64decode(values['datas']), verify_resolution=False)\n\n                    if not img.image:\n                        _logger.info('Post processing ignored : Empty source, SVG, or WEBP')\n                        return values\n\n                    w, h = img.image.size\n                    nw, nh = map(int, max_resolution.split('x'))\n                    if w > nw or h > nh:\n                        img = img.resize(nw, nh)\n                        quality = int(ICP('base.image_autoresize_quality', 80))\n                        image_data = img.image_quality(quality=quality)\n                        if is_raw:\n                            values['raw'] = image_data\n                        else:\n                            values['datas'] = base64.b64encode(image_data)\n                except UserError as e:\n                    # Catch error during test where we provide fake image\n                    # raise UserError(_(\"This file could not be decoded as an image file. Please try with a different file.\"))\n                    _logger.info('Post processing ignored : %s', e)\n        return values",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_contents",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _check_contents(self, values):\n        mimetype = values['mimetype'] = self._compute_mimetype(values)\n        xml_like = 'ht' in mimetype or ( # hta, html, xhtml, etc.\n                'xml' in mimetype and    # other xml (svg, text/xml, etc)\n                not mimetype.startswith('application/vnd.openxmlformats'))  # exception for Office formats\n        force_text = xml_like and (\n            self.env.context.get('attachments_mime_plainxml') or\n            not self.env['ir.ui.view'].sudo(False).check_access_rights('write', False))\n        if force_text:\n            values['mimetype'] = 'text/plain'\n        if not self.env.context.get('image_no_postprocess'):\n            values = self._postprocess_contents(values)\n        return values",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_index",
          "params": [
            "self",
            "bin_data",
            "file_type",
            "checksum=None"
          ],
          "decorators": [],
          "source": "def _index(self, bin_data, file_type, checksum=None):\n        \"\"\" compute the index content of the given binary data.\n            This is a python implementation of the unix command 'strings'.\n            :param bin_data : datas in binary form\n            :return index_content : string containing all the printable character of the binary data\n        \"\"\"\n        index_content = False\n        if file_type:\n            index_content = file_type.split('/')[0]\n            if index_content == 'text': # compute index_content only for text type\n                words = re.findall(b\"[\\x20-\\x7E]{4,}\", bin_data)\n                index_content = b\"\\n\".join(words).decode('ascii')\n        return index_content",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_serving_groups",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_serving_groups(self):\n        \"\"\" An ir.attachment record may be used as a fallback in the\n        http dispatch if its type field is set to \"binary\" and its url\n        field is set as the request's url. Only the groups returned by\n        this method are allowed to create and write on such records.\n        \"\"\"\n        return ['base.group_system']\n\n    name = fields.Char('Name', required=True)\n    description = fields.Text('Description')\n    res_name = fields.Char('Resource Name', compute='_compute_res_name')\n    res_model = fields.Char('Resource Model', readonly=True)\n    res_field = fields.Char('Resource Field', readonly=True)\n    res_id = fields.Many2oneReference('Resource ID', model_field='res_model',\n                                      readonly=True)\n    company_id = fields.Many2one('res.company', string='Company', change_default=True,\n                                 default=lambda self: self.env.company)\n    type = fields.Selection([('url', 'URL'), ('binary', 'File')],\n                            string='Type', required=True, default='binary', change_default=True,\n                            help=\"You can either upload a file from your computer or copy/paste an internet link to your file.\")\n    url = fields.Char('Url', index='btree_not_null', size=1024)\n    public = fields.Boolean('Is public document')\n\n    # for external access\n    access_token = fields.Char('Access Token', groups=\"base.group_user\")\n\n    # the field 'datas' is computed and may use the other fields below\n    raw = fields.Binary(string=\"File Content (raw)\", compute='_compute_raw', inverse='_inverse_raw')\n    datas = fields.Binary(string='File Content (base64)', compute='_compute_datas', inverse='_inverse_datas')\n    db_datas = fields.Binary('Database Data', attachment=False)\n    store_fname = fields.Char('Stored Filename', index=True, unaccent=False)\n    file_size = fields.Integer('File Size', readonly=True)\n    checksum = fields.Char(\"Checksum/SHA1\", size=40, readonly=True)\n    mimetype = fields.Char('Mime Type', readonly=True)\n    index_content = fields.Text('Indexed Content', readonly=True, prefetch=False)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_auto_init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _auto_init(self):\n        res = super(IrAttachment, self)._auto_init()\n        tools.create_index(self._cr, 'ir_attachment_res_idx',\n                           self._table, ['res_model', 'res_id'])\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_serving_attachments",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_serving_attachments(self):\n        if self.env.is_admin():\n            return\n        for attachment in self:\n            # restrict writing on attachments that could be served by the\n            # ir.http's dispatch exception handling\n            # XDO note: this should be done in check(write), constraints for access rights?\n            # XDO note: if read on sudo, read twice, one for constraints, one for _inverse_datas as user\n            if attachment.type == 'binary' and attachment.url:\n                has_group = self.env.user.has_group\n                if not any(has_group(g) for g in attachment.get_serving_groups()):\n                    raise ValidationError(_(\"Sorry, you are not allowed to write on this document\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "check",
          "params": [
            "self",
            "mode",
            "values=None"
          ],
          "decorators": [],
          "source": "def check(self, mode, values=None):\n        \"\"\" Restricts the access to an ir.attachment, according to referred mode \"\"\"\n        if self.env.is_superuser():\n            return True\n        # Always require an internal user (aka, employee) to access to a attachment\n        if not (self.env.is_admin() or self.env.user._is_internal()):\n            raise AccessError(_(\"Sorry, you are not allowed to access this document.\"))\n        # collect the records to check (by model)\n        model_ids = defaultdict(set)            # {model_name: set(ids)}\n        if self:\n            # DLE P173: `test_01_portal_attachment`\n            self.env['ir.attachment'].flush_model(['res_model', 'res_id', 'create_uid', 'public', 'res_field'])\n            self._cr.execute('SELECT res_model, res_id, create_uid, public, res_field FROM ir_attachment WHERE id IN %s', [tuple(self.ids)])\n            for res_model, res_id, create_uid, public, res_field in self._cr.fetchall():\n                if public and mode == 'read':\n                    continue\n                if not self.env.is_system():\n                    if not res_id and create_uid != self.env.uid:\n                        raise AccessError(_(\"Sorry, you are not allowed to access this document.\"))\n                    if res_field:\n                        field = self.env[res_model]._fields[res_field]\n                        if field.groups:\n                            if not self.env.user.user_has_groups(field.groups):\n                                raise AccessError(_(\"Sorry, you are not allowed to access this document.\"))\n                if not (res_model and res_id):\n                    continue\n                model_ids[res_model].add(res_id)\n        if values and values.get('res_model') and values.get('res_id'):\n            model_ids[values['res_model']].add(values['res_id'])\n\n        # check access rights on the records\n        for res_model, res_ids in model_ids.items():\n            # ignore attachments that are not attached to a resource anymore\n            # when checking access rights (resource was deleted but attachment\n            # was not)\n            if res_model not in self.env:\n                continue\n            if res_model == 'res.users' and len(res_ids) == 1 and self.env.uid == list(res_ids)[0]:\n                # by default a user cannot write on itself, despite the list of writeable fields\n                # e.g. in the case of a user inserting an image into his image signature\n                # we need to bypass this check which would needlessly throw us away\n                continue\n            records = self.env[res_model].browse(res_ids).exists()\n            # For related models, check if we can write to the model, as unlinking\n            # and creating attachments can be seen as an update to the model\n            access_mode = 'write' if mode in ('create', 'unlink') else mode\n            records.check_access_rights(access_mode)\n            records.check_access_rule(access_mode)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_filter_attachment_access",
          "params": [
            "self",
            "attachment_ids"
          ],
          "decorators": [],
          "source": "def _filter_attachment_access(self, attachment_ids):\n        \"\"\"Filter the given attachment to return only the records the current user have access to.\n\n        :param attachment_ids: List of attachment ids we want to filter\n        :return: <ir.attachment> the current user have access to\n        \"\"\"\n        ret_attachments = self.env['ir.attachment']\n        attachments = self.browse(attachment_ids)\n        if not attachments.check_access_rights('read', raise_exception=False):\n            return ret_attachments\n\n        for attachment in attachments.sudo():\n            # Use SUDO here to not raise an error during the prefetch\n            # And then drop SUDO right to check if we can access it\n            try:\n                attachment.sudo(False).check('read')\n                ret_attachments |= attachment\n            except AccessError:\n                continue\n        return ret_attachments",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search",
          "params": [
            "self",
            "domain",
            "offset=0",
            "limit=None",
            "order=None",
            "access_rights_uid=None"
          ],
          "decorators": [],
          "source": "def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):\n        # add res_field=False in domain if not present; the arg[0] trick below\n        # works for domain items and '&'/'|'/'!' operators too\n        disable_binary_fields_attachments = False\n        if not self.env.context.get('skip_res_field_check') and not any(arg[0] in ('id', 'res_field') for arg in domain):\n            disable_binary_fields_attachments = True\n            domain = [('res_field', '=', False)] + domain\n\n        if self.env.is_superuser():\n            # rules do not apply for the superuser\n            return super()._search(domain, offset, limit, order, access_rights_uid)\n\n        # For attachments, the permissions of the document they are attached to\n        # apply, so we must remove attachments for which the user cannot access\n        # the linked document. For the sake of performance, fetch the fields to\n        # determine those permissions within the same SQL query.\n        self.flush_model(['res_model', 'res_id', 'res_field', 'public', 'create_uid'])\n        query = super()._search(domain, offset, limit, order, access_rights_uid)\n        query_str, params = query.select(\n            f'\"{self._table}\".\"id\"',\n            f'\"{self._table}\".\"res_model\"',\n            f'\"{self._table}\".\"res_id\"',\n            f'\"{self._table}\".\"res_field\"',\n            f'\"{self._table}\".\"public\"',\n            f'\"{self._table}\".\"create_uid\"',\n        )\n        self.env.cr.execute(query_str, params)\n        rows = self.env.cr.fetchall()\n\n        # determine permissions based on linked records\n        all_ids = []\n        allowed_ids = set()\n        model_attachments = defaultdict(lambda: defaultdict(set))   # {res_model: {res_id: set(ids)}}\n        for id_, res_model, res_id, res_field, public, create_uid in rows:\n            all_ids.append(id_)\n            if public:\n                allowed_ids.add(id_)\n                continue\n            if not res_id and (self.env.is_system() or create_uid == self.env.uid):\n                allowed_ids.add(id_)\n                continue\n            if not (res_field and disable_binary_fields_attachments) and res_model and res_id:\n                model_attachments[res_model][res_id].add(id_)\n\n        # check permissions on records model by model\n        for res_model, targets in model_attachments.items():\n            if res_model not in self.env:\n                allowed_ids.update(id_ for ids in targets.values() for id_ in ids)\n                continue\n            if not self.env[res_model].check_access_rights('read', False):\n                continue\n            # filter ids according to what access rules permit\n            ResModel = self.env[res_model].with_context(active_test=False)\n            for res_id in ResModel.search([('id', 'in', list(targets))])._ids:\n                allowed_ids.update(targets[res_id])\n\n        # filter out all_ids by keeping allowed_ids only\n        result = [id_ for id_ in all_ids if id_ in allowed_ids]\n\n        # If the original search reached the limit, it is important the\n        # filtered record set does so too. When a JS view receive a\n        # record set whose length is below the limit, it thinks it\n        # reached the last page. To avoid an infinite recursion due to the\n        # permission checks the sub-call need to be aware of the number of\n        # expected records to retrieve\n        if len(all_ids) == limit and len(result) < self._context.get('need', limit):\n            need = self._context.get('need', limit) - len(result)\n            more_ids = self.with_context(need=need)._search(\n                domain, offset + len(all_ids), limit, order, access_rights_uid,\n            )\n            result.extend(list(more_ids)[:limit - len(result)])\n\n        return self.browse(result)._as_query(order)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        self.check('write', values=vals)\n        # remove computed field depending of datas\n        for field in ('file_size', 'checksum', 'store_fname'):\n            vals.pop(field, False)\n        if 'mimetype' in vals or 'datas' in vals or 'raw' in vals:\n            vals = self._check_contents(vals)\n        return super(IrAttachment, self).write(vals)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        if not (default or {}).keys() & {'datas', 'db_datas', 'raw'}:\n            # ensure the content is kept and recomputes checksum/store_fname\n            default = dict(default or {}, raw=self.raw)\n        return super(IrAttachment, self).copy(default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        if not self:\n            return True\n        self.check('unlink')\n\n        # First delete in the database, *then* in the filesystem if the\n        # database allowed it. Helps avoid errors when concurrent transactions\n        # are deleting the same file, and some of the transactions are\n        # rolled back by PostgreSQL (due to concurrent updates detection).\n        to_delete = set(attach.store_fname for attach in self if attach.store_fname)\n        res = super(IrAttachment, self).unlink()\n        for file_path in to_delete:\n            self._file_delete(file_path)\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        record_tuple_set = set()\n\n        # remove computed field depending of datas\n        vals_list = [{\n            key: value\n            for key, value\n            in vals.items()\n            if key not in ('file_size', 'checksum', 'store_fname')\n        } for vals in vals_list]\n\n        for values in vals_list:\n            values = self._check_contents(values)\n            raw, datas = values.pop('raw', None), values.pop('datas', None)\n            if raw or datas:\n                if isinstance(raw, str):\n                    # b64decode handles str input but raw needs explicit encoding\n                    raw = raw.encode()\n                values.update(self._get_datas_related_values(\n                    raw or base64.b64decode(datas or b''),\n                    values['mimetype']\n                ))\n\n            # 'check()' only uses res_model and res_id from values, and make an exists.\n            # We can group the values by model, res_id to make only one query when\n            # creating multiple attachments on a single record.\n            record_tuple = (values.get('res_model'), values.get('res_id'))\n            record_tuple_set.add(record_tuple)\n\n        # don't use possible contextual recordset for check, see commit for details\n        Attachments = self.browse()\n        for res_model, res_id in record_tuple_set:\n            Attachments.check('create', values={'res_model':res_model, 'res_id':res_id})\n        return super().create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_post_add_create",
          "params": [
            "self",
            "**kwargs"
          ],
          "decorators": [],
          "source": "def _post_add_create(self, **kwargs):\n        # TODO master: rename to _post_upload, better indicating its usage\n        pass",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "generate_access_token",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def generate_access_token(self):\n        tokens = []\n        for attachment in self:\n            if attachment.access_token:\n                tokens.append(attachment.access_token)\n                continue\n            access_token = self._generate_access_token()\n            attachment.write({'access_token': access_token})\n            tokens.append(access_token)\n        return tokens",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create_unique",
          "params": [
            "self",
            "values_list"
          ],
          "decorators": [],
          "source": "def create_unique(self, values_list):\n        ids = []\n        for values in values_list:\n            # Create only if record does not already exist for checksum and size.\n            try:\n                bin_data = base64.b64decode(values.get('datas', '')) or False\n            except binascii.Error:\n                raise UserError(_(\"Attachment is not encoded in base64.\"))\n            checksum = self._compute_checksum(bin_data)\n            existing_domain = [\n                ['id', '!=', False],  # No implicit condition on res_field.\n                ['checksum', '=', checksum],\n                ['file_size', '=', len(bin_data)],\n                ['mimetype', '=', values['mimetype']],\n            ]\n            existing = self.sudo().search(existing_domain)\n            if existing:\n                for attachment in existing:\n                    ids.append(attachment.id)\n            else:\n                attachment = self.create(values)\n                ids.append(attachment.id)\n        return ids",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_generate_access_token",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _generate_access_token(self):\n        return str(uuid.uuid4())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "validate_access",
          "params": [
            "self",
            "access_token"
          ],
          "decorators": [],
          "source": "def validate_access(self, access_token):\n        self.ensure_one()\n        record_sudo = self.sudo()\n\n        if access_token:\n            tok = record_sudo.with_context(prefetch_fields=False).access_token\n            valid_token = consteq(tok or '', access_token)\n            if not valid_token:\n                raise AccessError(\"Invalid access token\")\n            return record_sudo\n\n        if record_sudo.with_context(prefetch_fields=False).public:\n            return record_sudo\n\n        if self.env.user.has_group('base.group_portal'):\n            # Check the read access on the record linked to the attachment\n            # eg: Allow to download an attachment on a task from /my/tasks/task_id\n            self.check('read')\n            return record_sudo\n\n        return self",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_get",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_get(self):\n        return self.env['ir.actions.act_window']._for_xml_id('base.action_attachment')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_serve_attachment",
          "params": [
            "self",
            "url",
            "extra_domain=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _get_serve_attachment(self, url, extra_domain=None, order=None):\n        domain = [('type', '=', 'binary'), ('url', '=', url)] + (extra_domain or [])\n        return self.search(domain, order=order, limit=1)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "regenerate_assets_bundles",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def regenerate_assets_bundles(self):\n        self.search([\n            ('public', '=', True),\n            (\"url\", \"=like\", \"/web/assets/%\"),\n            ('res_model', '=', 'ir.ui.view'),\n            ('res_id', '=', 0),\n            ('create_uid', '=', SUPERUSER_ID),\n        ]).unlink()\n        self.env.registry.clear_cache('assets')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_serving_attachments",
          "definition": "@api.constrains('type', 'url')\n    def _check_serving_attachments(self):\n        if self.env.is_admin():\n            return\n        for attachment in self:\n            # restrict writing on attachments that could be served by the\n            # ir.http's dispatch exception handling\n            # XDO note: this should be done in check(write), constraints for access rights?\n            # XDO note: if read on sudo, read twice, one for constraints, one for _inverse_datas as user\n            if attachment.type == 'binary' and attachment.url:\n                has_group = self.env.user.has_group\n                if not any(has_group(g) for g in attachment.get_serving_groups()):\n                    raise ValidationError(_(\"Sorry, you are not allowed to write on this document\"))",
          "message": "'type', 'url'"
        }
      ],
      "accessRules": [
        {
          "name": "_storage (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_filestore (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_storage_domain (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "force_storage (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_full_path (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_path (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_file_read (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_file_write (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_file_delete (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_same_content (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_index (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_serving_groups (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_filter_attachment_access (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create_unique (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "action_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_serve_attachment (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "regenerate_assets_bundles (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrAttachment"
    },
    {
      "name": "ir.autovacuum",
      "description": "Automatic Vacuum",
      "fields": [],
      "methods": [
        {
          "name": "_run_vacuum_cleaner",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _run_vacuum_cleaner(self):\n        \"\"\"\n        Perform a complete database cleanup by safely calling every\n        ``@api.autovacuum`` decorated method.\n        \"\"\"\n        if not self.env.is_admin():\n            raise AccessDenied()\n\n        for model in self.env.values():\n            cls = self.env.registry[model._name]\n            for attr, func in inspect.getmembers(cls, is_autovacuum):\n                _logger.debug('Calling %s.%s()', model, attr)\n                try:\n                    func(model)\n                    self.env.cr.commit()\n                except Exception:\n                    _logger.exception(\"Failed %s.%s()\", model, attr)\n                    self.env.cr.rollback()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "AutoVacuum"
    },
    {
      "name": "ir.binary",
      "description": "File streaming helper model for controllers",
      "fields": [],
      "methods": [
        {
          "name": "_find_record_check_access",
          "params": [
            "self",
            "record",
            "access_token"
          ],
          "decorators": [],
          "source": "def _find_record_check_access(self, record, access_token):\n        if record._name == 'ir.attachment':\n            return record.validate_access(access_token)\n\n        record.check_access_rights('read')\n        record.check_access_rule('read')\n        return record",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_record_to_stream",
          "params": [
            "self",
            "record",
            "field_name"
          ],
          "decorators": [],
          "source": "def _record_to_stream(self, record, field_name):\n        \"\"\"\n        Low level method responsible for the actual conversion from a\n        model record to a stream. This method is an extensible hook for\n        other modules. It is not meant to be directly called from\n        outside or the ir.binary model.\n\n        :param record: the record where to load the data from.\n        :param str field_name: the binary field where to load the data\n            from.\n        :rtype: odoo.http.Stream\n        \"\"\"\n        if record._name == 'ir.attachment' and field_name in ('raw', 'datas', 'db_datas'):\n            return Stream.from_attachment(record)\n\n        record.check_field_access_rights('read', [field_name])\n\n        if record._fields[field_name].attachment:\n            field_attachment = self.env['ir.attachment'].sudo().search(\n                domain=[('res_model', '=', record._name),\n                        ('res_id', '=', record.id),\n                        ('res_field', '=', field_name)],\n                limit=1)\n            if not field_attachment:\n                raise MissingError(\"The related attachment does not exist.\")\n            return Stream.from_attachment(field_attachment)\n\n        return Stream.from_binary_field(record, field_name)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_placeholder_stream",
          "params": [
            "self",
            "path=None"
          ],
          "decorators": [],
          "source": "def _get_placeholder_stream(self, path=None):\n        if not path:\n            path = DEFAULT_PLACEHOLDER_PATH\n        return Stream.from_path(path, filter_ext=('.png', '.jpg'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_placeholder",
          "params": [
            "self",
            "path=False"
          ],
          "decorators": [],
          "source": "def _placeholder(self, path=False):\n        if not path:\n            path = DEFAULT_PLACEHOLDER_PATH\n        with file_open(path, 'rb', filter_ext=('.png', '.jpg')) as file:\n            return file.read()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "IrBinary"
    },
    {
      "name": "ir.config_parameter",
      "description": "System Parameter",
      "fields": [
        {
          "name": "key",
          "type": "Char",
          "required": true
        },
        {
          "name": "value",
          "type": "Text",
          "required": true
        }
      ],
      "methods": [
        {
          "name": "init",
          "params": [
            "self",
            "force=False"
          ],
          "decorators": [
            "@mute_logger('odoo.addons.base.models.ir_config_parameter')"
          ],
          "source": "@mute_logger('odoo.addons.base.models.ir_config_parameter')\n    def init(self, force=False):\n        \"\"\"\n        Initializes the parameters listed in _default_parameters.\n        It overrides existing parameters if force is ``True``.\n        \"\"\"\n        # avoid prefetching during module installation, as the res_users table\n        # may not have all prescribed columns\n        self = self.with_context(prefetch_fields=False)\n        for key, func in _default_parameters.items():\n            # force=True skips search and always performs the 'if' body (because ids=False)\n            params = self.sudo().search([('key', '=', key)])\n            if force or not params:\n                params.set_param(key, func())",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "get_param",
          "params": [
            "self",
            "key",
            "default=False"
          ],
          "decorators": [],
          "source": "def get_param(self, key, default=False):\n        \"\"\"Retrieve the value for a given key.\n\n        :param string key: The key of the parameter value to retrieve.\n        :param string default: default value if parameter is missing.\n        :return: The value of the parameter, or ``default`` if it does not exist.\n        :rtype: string\n        \"\"\"\n        self.check_access_rights('read')\n        return self._get_param(key) or default",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_param",
          "params": [
            "self",
            "key"
          ],
          "decorators": [
            "@ormcache('key')"
          ],
          "source": "@ormcache('key')\n    def _get_param(self, key):\n        # we bypass the ORM because get_param() is used in some field's depends,\n        # and must therefore work even when the ORM is not ready to work\n        self.flush_model(['key', 'value'])\n        self.env.cr.execute(\"SELECT value FROM ir_config_parameter WHERE key = %s\", [key])\n        result = self.env.cr.fetchone()\n        return result and result[0]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "set_param",
          "params": [
            "self",
            "key",
            "value"
          ],
          "decorators": [],
          "source": "def set_param(self, key, value):\n        \"\"\"Sets the value of a parameter.\n\n        :param string key: The key of the parameter value to set.\n        :param string value: The value to set.\n        :return: the previous value of the parameter or False if it did\n                 not exist.\n        :rtype: string\n        \"\"\"\n        param = self.search([('key', '=', key)])\n        if param:\n            old = param.value\n            if value is not False and value is not None:\n                if str(value) != old:\n                    param.write({'value': value})\n            else:\n                param.unlink()\n            return old\n        else:\n            if value is not False and value is not None:\n                self.create({'key': key, 'value': value})\n            return False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.env.registry.clear_cache()\n        return super(IrConfigParameter, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if 'key' in vals:\n            illegal = _default_parameters.keys() & self.mapped('key')\n            if illegal:\n                raise ValidationError(_(\"You cannot rename config parameters with keys %s\", ', '.join(illegal)))\n        self.env.registry.clear_cache()\n        return super(IrConfigParameter, self).write(vals)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self.env.registry.clear_cache()\n        return super(IrConfigParameter, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink_default_parameters",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink_default_parameters(self):\n        for record in self.filtered(lambda p: p.key in _default_parameters.keys()):\n            raise ValidationError(_(\"You cannot delete the %s record.\", record.key))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "key_uniq",
          "definition": "unique (key)",
          "message": "Key must be unique."
        }
      ],
      "accessRules": [
        {
          "name": "get_param (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "set_param (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrConfigParameter"
    },
    {
      "name": "ir.cron",
      "description": "Scheduled Actions",
      "fields": [
        {
          "name": "ir_actions_server_id",
          "type": "Many2one",
          "relation": "ir.actions.server",
          "required": true
        },
        {
          "name": "cron_name",
          "type": "Char"
        },
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "required": true,
          "string": "Scheduler User"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "interval_number",
          "type": "Integer",
          "help": "Repeat every x."
        },
        {
          "name": "interval_type",
          "type": "Selection"
        },
        {
          "name": "numbercall",
          "type": "Integer",
          "string": "Number of Calls",
          "help": "How many times the method is called,\\na negative number indicates no limit."
        },
        {
          "name": "doall",
          "type": "Boolean",
          "string": "Repeat Missed",
          "help": "Specify if missed occurrences should be executed when the server restarts."
        },
        {
          "name": "nextcall",
          "type": "Datetime",
          "required": true,
          "string": "Next Execution Date",
          "help": "Next planned execution date for this job."
        },
        {
          "name": "lastcall",
          "type": "Datetime",
          "string": "Last Execution Date",
          "help": "Previous time the cron ran successfully, provided to the job through the context on the `lastcall` key"
        },
        {
          "name": "priority",
          "type": "Integer",
          "help": "The priority of the job, as an integer: 0 means higher priority, 10 means lower priority."
        },
        {
          "name": "lastcall",
          "type": "Datetime.now"
        },
        {
          "name": "lastcall",
          "type": "Datetime.to_datetime"
        },
        {
          "name": "now",
          "type": "Datetime.context_timestamp"
        },
        {
          "name": "past_nextcall",
          "type": "Datetime.context_timestamp"
        },
        {
          "name": "now",
          "type": "Datetime.now"
        }
      ],
      "methods": [
        {
          "name": "_compute_cron_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_cron_name(self):\n        for cron in self.with_context(lang='en_US'):\n            cron.cron_name = cron.ir_actions_server_id.name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        for vals in vals_list:\n            vals['usage'] = 'ir_cron'\n        if os.getenv('ODOO_NOTIFY_CRON_CHANGES'):\n            self._cr.postcommit.add(self._notifydb)\n        return super().create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "default_get",
          "params": [
            "self",
            "fields_list"
          ],
          "decorators": [],
          "source": "def default_get(self, fields_list):\n        # only 'code' state is supported for cron job so set it as default\n        if not self._context.get('default_state'):\n            self = self.with_context(default_state='code')\n        return super(ir_cron, self).default_get(fields_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_interval_number",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_interval_number(self):\n        if self.active and (self.interval_number <= 0 or not self.interval_type):\n            self.active = False\n            return {'warning': {\n                'title': _(\"Scheduled action disabled\"),\n                'message': _(\"This scheduled action has been disabled because its interval number is not a strictly positive value.\")}\n            }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "method_direct_trigger",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def method_direct_trigger(self):\n        self.check_access_rights('write')\n        for cron in self:\n            cron._try_lock()\n            _logger.info('Manually starting job `%s`.', cron.name)\n            cron.with_user(cron.user_id).with_context({'lastcall': cron.lastcall}).ir_actions_server_id.run()\n            self.env.flush_all()\n            _logger.info('Job `%s` done.', cron.name)\n            cron.lastcall = fields.Datetime.now()\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_process_jobs",
          "params": [
            "cls",
            "db_name"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _process_jobs(cls, db_name):\n        \"\"\" Execute every job ready to be run on this database. \"\"\"\n        try:\n            db = odoo.sql_db.db_connect(db_name)\n            threading.current_thread().dbname = db_name\n            with db.cursor() as cron_cr:\n                cls._check_version(cron_cr)\n                jobs = cls._get_all_ready_jobs(cron_cr)\n                if not jobs:\n                    return\n                cls._check_modules_state(cron_cr, jobs)\n\n                for job_id in (job['id'] for job in jobs):\n                    try:\n                        job = cls._acquire_one_job(cron_cr, (job_id,))\n                    except psycopg2.extensions.TransactionRollbackError:\n                        cron_cr.rollback()\n                        _logger.debug(\"job %s has been processed by another worker, skip\", job_id)\n                        continue\n                    if not job:\n                        _logger.debug(\"another worker is processing job %s, skip\", job_id)\n                        continue\n                    _logger.debug(\"job %s acquired\", job_id)\n                    # take into account overridings of _process_job() on that database\n                    registry = odoo.registry(db_name)\n                    registry[cls._name]._process_job(db, cron_cr, job)\n                    cron_cr.commit()\n                    _logger.debug(\"job %s updated and released\", job_id)\n\n        except BadVersion:\n            _logger.warning('Skipping database %s as its base version is not %s.', db_name, BASE_VERSION)\n        except BadModuleState:\n            _logger.warning('Skipping database %s because of modules to install/upgrade/remove.', db_name)\n        except psycopg2.ProgrammingError as e:\n            if e.pgcode == '42P01':\n                # Class 42  Syntax Error or Access Rule Violation; 42P01: undefined_table\n                # The table ir_cron does not exist; this is probably not an OpenERP database.\n                _logger.warning('Tried to poll an undefined table on database %s.', db_name)\n            else:\n                raise\n        except Exception:\n            _logger.warning('Exception in cron:', exc_info=True)\n        finally:\n            if hasattr(threading.current_thread(), 'dbname'):\n                del threading.current_thread().dbname",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_check_version",
          "params": [
            "cls",
            "cron_cr"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _check_version(cls, cron_cr):\n        \"\"\" Ensure the code version matches the database version \"\"\"\n        cron_cr.execute(\"\"\"\n            SELECT latest_version\n            FROM ir_module_module\n             WHERE name='base'\n        \"\"\")\n        (version,) = cron_cr.fetchone()\n        if version is None:\n            raise BadModuleState()\n        if version != BASE_VERSION:\n            raise BadVersion()",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_check_modules_state",
          "params": [
            "cls",
            "cr",
            "jobs"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _check_modules_state(cls, cr, jobs):\n        \"\"\" Ensure no module is installing or upgrading \"\"\"\n        cr.execute(\"\"\"\n            SELECT COUNT(*)\n            FROM ir_module_module\n            WHERE state LIKE %s\n        \"\"\", ['to %'])\n        (changes,) = cr.fetchone()\n        if not changes:\n            return\n\n        if not jobs:\n            raise BadModuleState()\n\n        oldest = min([\n            fields.Datetime.from_string(job['nextcall'])\n            for job in jobs\n        ])\n        if datetime.now() - oldest < MAX_FAIL_TIME:\n            raise BadModuleState()\n\n        # the cron execution failed around MAX_FAIL_TIME * 60 times (1 failure\n        # per minute for 5h) in which case we assume that the crons are stuck\n        # because the db has zombie states and we force a call to\n        # reset_module_states.\n        odoo.modules.reset_modules_state(cr.dbname)",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_get_all_ready_jobs",
          "params": [
            "cls",
            "cr"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _get_all_ready_jobs(cls, cr):\n        \"\"\" Return a list of all jobs that are ready to be executed \"\"\"\n        cr.execute(\"\"\"\n            SELECT *\n            FROM ir_cron\n            WHERE active = true\n              AND numbercall != 0\n              AND (nextcall <= (now() at time zone 'UTC')\n                OR id in (\n                    SELECT cron_id\n                    FROM ir_cron_trigger\n                    WHERE call_at <= (now() at time zone 'UTC')\n                )\n              )\n            ORDER BY priority\n        \"\"\")\n        return cr.dictfetchall()",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_acquire_one_job",
          "params": [
            "cls",
            "cr",
            "job_ids"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _acquire_one_job(cls, cr, job_ids):\n        \"\"\"\n        Acquire for update one job that is ready from the job_ids tuple.\n\n        The jobs that have already been processed in this worker should\n        be excluded from the tuple.\n\n        This function raises a ``psycopg2.errors.SerializationFailure``\n        when the ``nextcall`` of one of the job_ids is modified in\n        another transaction. You should rollback the transaction and try\n        again later.\n        \"\"\"\n\n        # We have to make sure ALL jobs are executed ONLY ONCE no matter\n        # how many cron workers may process them. The exlusion mechanism\n        # is twofold: (i) prevent parallel processing of the same job,\n        # and (ii) prevent re-processing jobs that have been processed\n        # already.\n        #\n        # (i) is implemented via `LIMIT 1 FOR UPDATE SKIP LOCKED`, each\n        # worker just acquire one available job at a time and lock it so\n        # the other workers don't select it too.\n        # (ii) is implemented via the `WHERE` statement, when a job has\n        # been processed, its nextcall is updated to a date in the\n        # future and the optional triggers are removed.\n        #\n        # Note about (ii): it is possible that a job becomes available\n        # again quickly (e.g. high frequency or self-triggering cron).\n        # This function doesn't prevent from acquiring that job multiple\n        # times at different moments. This can block a worker on\n        # executing a same job in loop. To prevent this problem, the\n        # callee is responsible of providing a `job_ids` tuple without\n        # the jobs it has executed already.\n        #\n        # An `UPDATE` lock type is the strongest row lock, it conflicts\n        # with ALL other lock types. Among them the `KEY SHARE` row lock\n        # which is implicitely aquired by foreign keys to prevent the\n        # referenced record from being removed while in use. Because we\n        # never delete acquired cron jobs, foreign keys are safe to\n        # concurrently reference cron jobs. Hence, the `NO KEY UPDATE`\n        # row lock is used, it is a weaker lock that does conflict with\n        # everything BUT `KEY SHARE`.\n        #\n        # Learn more: https://www.postgresql.org/docs/current/explicit-locking.html#LOCKING-ROWS\n\n        query = \"\"\"\n            SELECT *\n            FROM ir_cron\n            WHERE active = true\n              AND numbercall != 0\n              AND (nextcall <= (now() at time zone 'UTC')\n                OR EXISTS (\n                    SELECT cron_id\n                    FROM ir_cron_trigger\n                    WHERE call_at <= (now() at time zone 'UTC')\n                      AND cron_id = ir_cron.id\n                )\n              )\n              AND id in %s\n            ORDER BY priority\n            LIMIT 1 FOR NO KEY UPDATE SKIP LOCKED\n        \"\"\"\n        try:\n            cr.execute(query, [job_ids], log_exceptions=False)\n        except psycopg2.extensions.TransactionRollbackError:\n            # A serialization error can occur when another cron worker\n            # commits the new `nextcall` value of a cron it just ran and\n            # that commit occured just before this query. The error is\n            # genuine and the job should be skipped in this cron worker.\n            raise\n        except Exception as exc:\n            _logger.error(\"bad query: %s\\nERROR: %s\", query, exc)\n            raise\n        return cr.dictfetchone()",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_process_job",
          "params": [
            "cls",
            "db",
            "cron_cr",
            "job"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _process_job(cls, db, cron_cr, job):\n        \"\"\" Execute a cron job and re-schedule a call for later. \"\"\"\n\n        # Compute how many calls were missed and at what time we should\n        # recall the cron next. In the example bellow, we fake a cron\n        # with an interval of 30 (starting at 0) that was last executed\n        # at 15 and that is executed again at 135.\n        #\n        #    0          60          120         180\n        #  --|-----|-----|-----|-----|-----|-----|----> time\n        #    1     2*    *     *     *  3  4\n        #\n        # 1: lastcall, the last time the cron was executed\n        # 2: past_nextcall, the cron nextcall as seen from lastcall\n        # *: missed_call, a total of 4 calls are missing\n        # 3: now\n        # 4: future_nextcall, the cron nextcall as seen from now\n\n        if job['interval_number'] <= 0:\n            _logger.error(\"Job %s %r has been disabled because its interval number is null or negative.\", job['id'], job['cron_name'])\n            cron_cr.execute(\"UPDATE ir_cron SET active=false WHERE id=%s\", [job['id']])\n            return\n\n        with cls.pool.cursor() as job_cr:\n            lastcall = fields.Datetime.to_datetime(job['lastcall'])\n            interval = _intervalTypes[job['interval_type']](job['interval_number'])\n            env = api.Environment(job_cr, job['user_id'], {'lastcall': lastcall})\n            ir_cron = env[cls._name]\n\n            # Use the user's timezone to compare and compute datetimes,\n            # otherwise unexpected results may appear. For instance, adding\n            # 1 month in UTC to July 1st at midnight in GMT+2 gives July 30\n            # instead of August 1st!\n            now = fields.Datetime.context_timestamp(ir_cron, datetime.utcnow())\n            past_nextcall = fields.Datetime.context_timestamp(\n                ir_cron, fields.Datetime.to_datetime(job['nextcall']))\n\n            # Compute how many call were missed\n            missed_call = past_nextcall\n            missed_call_count = 0\n            while missed_call <= now:\n                missed_call += interval\n                missed_call_count += 1\n            future_nextcall = missed_call\n\n            # Compute how many time we should run the cron\n            effective_call_count = (\n                     1 if not missed_call_count                    # run at least once\n                else 1 if not job['doall']                         # run once for all\n                else missed_call_count if job['numbercall'] == -1  # run them all\n                else min(missed_call_count, job['numbercall'])     # run maximum numbercall times\n            )\n            call_count_left = max(job['numbercall'] - effective_call_count, -1)\n\n            # The actual cron execution\n            for call in range(effective_call_count):\n                ir_cron._callback(job['cron_name'], job['ir_actions_server_id'], job['id'])\n\n        # Update the cron with the information computed above\n        cron_cr.execute(\"\"\"\n            UPDATE ir_cron\n            SET nextcall=%s,\n                numbercall=%s,\n                lastcall=%s,\n                active=%s\n            WHERE id=%s\n        \"\"\", [\n            fields.Datetime.to_string(future_nextcall.astimezone(pytz.UTC)),\n            call_count_left,\n            fields.Datetime.to_string(now.astimezone(pytz.UTC)),\n            job['active'] and bool(call_count_left),\n            job['id'],\n        ])\n\n        cron_cr.execute(\"\"\"\n            DELETE FROM ir_cron_trigger\n            WHERE cron_id = %s\n              AND call_at < (now() at time zone 'UTC')\n        \"\"\", [job['id']])",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_callback",
          "params": [
            "self",
            "cron_name",
            "server_action_id",
            "job_id"
          ],
          "decorators": [],
          "source": "def _callback(self, cron_name, server_action_id, job_id):\n        \"\"\" Run the method associated to a given job. It takes care of logging\n        and exception handling. Note that the user running the server action\n        is the user calling this method. \"\"\"\n        try:\n            if self.pool != self.pool.check_signaling():\n                # the registry has changed, reload self in the new registry\n                self.env.reset()\n                self = self.env()[self._name]\n\n            log_depth = (None if _logger.isEnabledFor(logging.DEBUG) else 1)\n            odoo.netsvc.log(_logger, logging.DEBUG, 'cron.object.execute', (self._cr.dbname, self._uid, '*', cron_name, server_action_id), depth=log_depth)\n            _logger.info('Starting job `%s`.', cron_name)\n            start_time = time.time()\n            self.env['ir.actions.server'].browse(server_action_id).run()\n            self.env.flush_all()\n            end_time = time.time()\n            _logger.info('Job done: `%s` (%.3fs).', cron_name, end_time - start_time)\n            if start_time and _logger.isEnabledFor(logging.DEBUG):\n                _logger.debug('%.3fs (cron %s, server action %d with uid %d)', end_time - start_time, cron_name, server_action_id, self.env.uid)\n            self.pool.signal_changes()\n        except Exception as e:\n            self.pool.reset_changes()\n            _logger.exception(\"Call from cron %s for server action #%s failed in Job #%s\",\n                              cron_name, server_action_id, job_id)\n            self._handle_callback_exception(cron_name, server_action_id, job_id, e)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_handle_callback_exception",
          "params": [
            "self",
            "cron_name",
            "server_action_id",
            "job_id",
            "job_exception"
          ],
          "decorators": [],
          "source": "def _handle_callback_exception(self, cron_name, server_action_id, job_id, job_exception):\n        \"\"\" Method called when an exception is raised by a job.\n\n        Simply logs the exception and rollback the transaction. \"\"\"\n        self._cr.rollback()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_try_lock",
          "params": [
            "self",
            "lockfk=False"
          ],
          "decorators": [],
          "source": "def _try_lock(self, lockfk=False):\n        \"\"\"Try to grab a dummy exclusive write-lock to the rows with the given ids,\n           to make sure a following write() or unlink() will not block due\n           to a process currently executing those cron tasks.\n\n           :param lockfk: acquire a strong row lock which conflicts with\n                          the lock aquired by foreign keys when they\n                          reference this row.\n        \"\"\"\n        if not self:\n            return\n        row_level_lock = \"UPDATE\" if lockfk else \"NO KEY UPDATE\"\n        try:\n            self._cr.execute(f\"\"\"\n                SELECT id\n                FROM \"{self._table}\"\n                WHERE id IN %s\n                FOR {row_level_lock} NOWAIT\n            \"\"\", [tuple(self.ids)], log_exceptions=False)\n        except psycopg2.OperationalError:\n            self._cr.rollback()  # early rollback to allow translations to work for the user feedback\n            raise UserError(_(\"Record cannot be modified right now: \"\n                              \"This cron task is currently being executed and may not be modified \"\n                              \"Please try again in a few minutes\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        self._try_lock()\n        if ('nextcall' in vals or vals.get('active')) and os.getenv('ODOO_NOTIFY_CRON_CHANGES'):\n            self._cr.postcommit.add(self._notifydb)\n        return super(ir_cron, self).write(vals)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self._try_lock(lockfk=True)\n        return super(ir_cron, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "try_write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def try_write(self, values):\n        try:\n            with self._cr.savepoint():\n                self._cr.execute(f\"\"\"\n                    SELECT id\n                    FROM \"{self._table}\"\n                    WHERE id IN %s\n                    FOR NO KEY UPDATE NOWAIT\n                \"\"\", [tuple(self.ids)], log_exceptions=False)\n        except psycopg2.OperationalError:\n            pass\n        else:\n            return super(ir_cron, self).write(values)\n        return False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "toggle",
          "params": [
            "self",
            "model",
            "domain"
          ],
          "decorators": [],
          "source": "def toggle(self, model, domain):\n        # Prevent deactivated cron jobs from being re-enabled through side effects on\n        # neutralized databases.\n        if self.env['ir.config_parameter'].sudo().get_param('database.is_neutralized'):\n            return True\n\n        active = bool(self.env[model].search_count(domain))\n        return self.try_write({'active': active})",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_trigger",
          "params": [
            "self",
            "at=None"
          ],
          "decorators": [],
          "source": "def _trigger(self, at=None):\n        \"\"\"\n        Schedule a cron job to be executed soon independently of its\n        ``nextcall`` field value.\n\n        By default the cron is scheduled to be executed in the next batch but\n        the optional `at` argument may be given to delay the execution later\n        with a precision down to 1 minute.\n\n        The method may be called with a datetime or an iterable of datetime.\n        The actual implementation is in :meth:`~._trigger_list`, which is the\n        recommended method for overrides.\n\n        :param Optional[Union[datetime.datetime, list[datetime.datetime]]] at:\n            When to execute the cron, at one or several moments in time instead\n            of as soon as possible.\n        :return: the created triggers records\n        :rtype: recordset\n        \"\"\"\n        if at is None:\n            at_list = [fields.Datetime.now()]\n        elif isinstance(at, datetime):\n            at_list = [at]\n        else:\n            at_list = list(at)\n            assert all(isinstance(at, datetime) for at in at_list)\n\n        return self._trigger_list(at_list)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_trigger_list",
          "params": [
            "self",
            "at_list"
          ],
          "decorators": [],
          "source": "def _trigger_list(self, at_list):\n        \"\"\"\n        Implementation of :meth:`~._trigger`.\n\n        :param list[datetime.datetime] at_list:\n            Execute the cron later, at precise moments in time.\n        :return: the created triggers records\n        :rtype: recordset\n        \"\"\"\n        self.ensure_one()\n        now = fields.Datetime.now()\n\n        if not self.sudo().active:\n            # skip triggers that would be ignored\n            at_list = [at for at in at_list if at > now]\n\n        if not at_list:\n            return self.env['ir.cron.trigger']\n\n        triggers = self.env['ir.cron.trigger'].sudo().create([\n            {'cron_id': self.id, 'call_at': at}\n            for at in at_list\n        ])\n        if _logger.isEnabledFor(logging.DEBUG):\n            ats = ', '.join(map(str, at_list))\n            _logger.debug(\"will execute '%s' at %s\", self.sudo().name, ats)\n\n        if min(at_list) <= now or os.getenv('ODOO_NOTIFY_CRON_CHANGES'):\n            self._cr.postcommit.add(self._notifydb)\n        return triggers",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_notifydb",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _notifydb(self):\n        \"\"\" Wake up the cron workers\n        The ODOO_NOTIFY_CRON_CHANGES environment variable allows to force the notifydb on both\n        ir_cron modification and on trigger creation (regardless of call_at)\n        \"\"\"\n        with odoo.sql_db.db_connect('postgres').cursor() as cr:\n            query = sql.SQL(\"SELECT {}('cron_trigger', %s)\").format(sql.Identifier(ODOO_NOTIFY_FUNCTION))\n            cr.execute(query, [self.env.cr.dbname])\n        _logger.debug(\"cron workers notified\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "default_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_callback (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_handle_callback_exception (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "toggle (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ir_cron"
    },
    {
      "name": "ir.cron.trigger",
      "description": "Triggered actions",
      "fields": [
        {
          "name": "cron_id",
          "type": "Many2one",
          "relation": "ir.cron"
        },
        {
          "name": "call_at",
          "type": "Datetime"
        }
      ],
      "methods": [
        {
          "name": "_gc_cron_triggers",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _gc_cron_triggers(self):\n        domain = [('call_at', '<', datetime.now() + relativedelta(weeks=-1))]\n        records = self.search(domain, limit=models.GC_UNLINK_LIMIT)\n        if len(records) >= models.GC_UNLINK_LIMIT:\n            self.env.ref('base.autovacuum_job')._trigger()\n        return records.unlink()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ir_cron_trigger"
    },
    {
      "name": "ir.default",
      "description": "Default Values",
      "fields": [
        {
          "name": "field_id",
          "type": "Many2one",
          "relation": "ir.model.fields",
          "required": true,
          "string": "Field"
        },
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "string": "User",
          "help": "If set, action binding only applies for this user."
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company",
          "string": "Company",
          "help": "If set, action binding only applies for this company"
        },
        {
          "name": "condition",
          "type": "Char",
          "help": "If set, applies the default upon condition."
        },
        {
          "name": "json_value",
          "type": "Char"
        }
      ],
      "methods": [
        {
          "name": "_check_json_format",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_json_format(self):\n        for record in self:\n            try:\n                json.loads(record.json_value)\n            except json.JSONDecodeError:\n                raise ValidationError(_('Invalid JSON format in Default Value field.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.env.registry.clear_cache()\n        return super(IrDefault, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if self:\n            self.env.registry.clear_cache()\n        new_default = super().write(vals)\n        self.check_access_rule('write')\n        return new_default",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        if self:\n            self.env.registry.clear_cache()\n        return super(IrDefault, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "set",
          "params": [
            "self",
            "model_name",
            "field_name",
            "value",
            "user_id=False",
            "company_id=False",
            "condition=False"
          ],
          "decorators": [],
          "source": "def set(self, model_name, field_name, value, user_id=False, company_id=False, condition=False):\n        \"\"\" Defines a default value for the given field. Any entry for the same\n            scope (field, user, company) will be replaced. The value is encoded\n            in JSON to be stored to the database.\n\n            :param model_name:\n            :param field_name:\n            :param value:\n            :param user_id: may be ``False`` for all users, ``True`` for the\n                            current user, or any user id\n            :param company_id: may be ``False`` for all companies, ``True`` for\n                               the current user's company, or any company id\n            :param condition: optional condition that restricts the\n                              applicability of the default value; this is an\n                              opaque string, but the client typically uses\n                              single-field conditions in the form ``'key=val'``.\n        \"\"\"\n        if user_id is True:\n            user_id = self.env.uid\n        if company_id is True:\n            company_id = self.env.company.id\n\n        # check consistency of model_name, field_name, and value\n        try:\n            model = self.env[model_name]\n            field = model._fields[field_name]\n            parsed = field.convert_to_cache(value, model)\n            json_value = json.dumps(value, ensure_ascii=False)\n        except KeyError:\n            raise ValidationError(_(\"Invalid field %s.%s\", model_name, field_name))\n        except Exception:\n            raise ValidationError(_(\"Invalid value for %s.%s: %s\", model_name, field_name, value))\n        if field.type == 'integer' and not (-2**31 < parsed < 2**31-1):\n            raise ValidationError(_(\"Invalid value for %s.%s: %s is out of bounds (integers should be between -2,147,483,648 and 2,147,483,647)\", model_name, field_name, value))\n\n        # update existing default for the same scope, or create one\n        field = self.env['ir.model.fields']._get(model_name, field_name)\n        default = self.search([\n            ('field_id', '=', field.id),\n            ('user_id', '=', user_id),\n            ('company_id', '=', company_id),\n            ('condition', '=', condition),\n        ])\n        if default:\n            # Avoid clearing the cache if nothing changes\n            if default.json_value != json_value:\n                default.write({'json_value': json_value})\n        else:\n            self.create({\n                'field_id': field.id,\n                'user_id': user_id,\n                'company_id': company_id,\n                'condition': condition,\n                'json_value': json_value,\n            })\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get",
          "params": [
            "self",
            "model_name",
            "field_name",
            "user_id=False",
            "company_id=False",
            "condition=False"
          ],
          "decorators": [],
          "source": "def _get(self, model_name, field_name, user_id=False, company_id=False, condition=False):\n        \"\"\" Return the default value for the given field, user and company, or\n            ``None`` if no default is available.\n\n            :param model_name:\n            :param field_name:\n            :param user_id: may be ``False`` for all users, ``True`` for the\n                            current user, or any user id\n            :param company_id: may be ``False`` for all companies, ``True`` for\n                               the current user's company, or any company id\n            :param condition: optional condition that restricts the\n                              applicability of the default value; this is an\n                              opaque string, but the client typically uses\n                              single-field conditions in the form ``'key=val'``.\n        \"\"\"\n        if user_id is True:\n            user_id = self.env.uid\n        if company_id is True:\n            company_id = self.env.company.id\n\n        field = self.env['ir.model.fields']._get(model_name, field_name)\n        default = self.search([\n            ('field_id', '=', field.id),\n            ('user_id', '=', user_id),\n            ('company_id', '=', company_id),\n            ('condition', '=', condition),\n        ], limit=1)\n        return json.loads(default.json_value) if default else None",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_model_defaults",
          "params": [
            "self",
            "model_name",
            "condition=False"
          ],
          "decorators": [],
          "source": "def _get_model_defaults(self, model_name, condition=False):\n        \"\"\" Return the available default values for the given model (for the\n            current user), as a dict mapping field names to values.\n        \"\"\"\n        cr = self.env.cr\n        query = \"\"\" SELECT f.name, d.json_value\n                    FROM ir_default d\n                    JOIN ir_model_fields f ON d.field_id=f.id\n                    WHERE f.model=%s\n                        AND (d.user_id IS NULL OR d.user_id=%s)\n                        AND (d.company_id IS NULL OR d.company_id=%s)\n                        AND {}\n                    ORDER BY d.user_id, d.company_id, d.id\n                \"\"\"\n        # self.env.company is empty when there is no user (controllers with auth=None)\n        params = [model_name, self.env.uid, self.env.company.id or None]\n        if condition:\n            query = query.format(\"d.condition=%s\")\n            params.append(condition)\n        else:\n            query = query.format(\"d.condition IS NULL\")\n        cr.execute(query, params)\n        result = {}\n        for row in cr.fetchall():\n            # keep the highest priority default for each field\n            if row[0] not in result:\n                result[row[0]] = json.loads(row[1])\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "discard_records",
          "params": [
            "self",
            "records"
          ],
          "decorators": [],
          "source": "def discard_records(self, records):\n        \"\"\" Discard all the defaults of many2one fields using any of the given\n            records.\n        \"\"\"\n        json_vals = [json.dumps(id) for id in records.ids]\n        domain = [('field_id.ttype', '=', 'many2one'),\n                  ('field_id.relation', '=', records._name),\n                  ('json_value', 'in', json_vals)]\n        return self.search(domain).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "discard_values",
          "params": [
            "self",
            "model_name",
            "field_name",
            "values"
          ],
          "decorators": [],
          "source": "def discard_values(self, model_name, field_name, values):\n        \"\"\" Discard all the defaults for any of the given values. \"\"\"\n        field = self.env['ir.model.fields']._get(model_name, field_name)\n        json_vals = [json.dumps(value, ensure_ascii=False) for value in values]\n        domain = [('field_id', '=', field.id), ('json_value', 'in', json_vals)]\n        return self.search(domain).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_json_format",
          "definition": "@api.constrains('json_value')\n    def _check_json_format(self):\n        for record in self:\n            try:\n                json.loads(record.json_value)\n            except json.JSONDecodeError:\n                raise ValidationError(_('Invalid JSON format in Default Value field.'))",
          "message": "'json_value'"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "set (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "discard_records (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "discard_values (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rule",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrDefault"
    },
    {
      "name": "ir.demo",
      "description": "Demo",
      "fields": [],
      "methods": [
        {
          "name": "install_demo",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def install_demo(self):\n        force_demo(self.env)\n        return {\n            'type': 'ir.actions.act_url',\n            'target': 'self',\n            'url': '/web',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "IrDemo"
    },
    {
      "name": "ir.demo_failure",
      "description": "Demo failure",
      "fields": [
        {
          "name": "module_id",
          "type": "Many2one",
          "relation": "ir.module.module",
          "required": true,
          "string": "Module"
        },
        {
          "name": "error",
          "type": "Char",
          "string": "Error"
        },
        {
          "name": "wizard_id",
          "type": "Many2one",
          "relation": "ir.demo_failure.wizard"
        }
      ],
      "methods": [],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "DemoFailure"
    },
    {
      "name": "ir.demo_failure.wizard",
      "description": "Demo Failure wizard",
      "fields": [
        {
          "name": "failure_ids",
          "type": "One2many",
          "relation": "ir.demo_failure",
          "readonly": true,
          "string": "Demo Installation Failures"
        },
        {
          "name": "failures_count",
          "type": "Integer"
        }
      ],
      "methods": [
        {
          "name": "_compute_failures_count",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_failures_count(self):\n        for r in self:\n            r.failures_count = len(r.failure_ids)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "done",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def done(self):\n        # pylint: disable=next-method-called\n        return self.env['ir.module.module'].next()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "DemoFailureWizard"
    },
    {
      "name": "ir.exports",
      "description": "Exports",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "string": "Export Name"
        },
        {
          "name": "resource",
          "type": "Char"
        },
        {
          "name": "export_fields",
          "type": "One2many",
          "relation": "ir.exports.line",
          "string": "Export ID"
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "IrExports"
    },
    {
      "name": "ir.exports.line",
      "description": "Exports Line",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "string": "Field Name"
        },
        {
          "name": "export_id",
          "type": "Many2one",
          "relation": "ir.exports",
          "string": "Export"
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "IrExportsLine"
    },
    {
      "name": "ir.fields.converter",
      "description": "Fields Converter",
      "fields": [
        {
          "name": "parsed_value",
          "type": "Date.from_string"
        },
        {
          "name": "parsed_value",
          "type": "Datetime.from_string"
        }
      ],
      "methods": [
        {
          "name": "_format_import_error",
          "params": [
            "self",
            "error_type",
            "error_msg",
            "error_params=()",
            "error_args=None"
          ],
          "decorators": [],
          "source": "def _format_import_error(self, error_type, error_msg, error_params=(), error_args=None):\n        # sanitize error params for later formatting by the import system\n        sanitize = lambda p: p.replace('%', '%%') if isinstance(p, str) else p\n        if error_params:\n            if isinstance(error_params, str):\n                error_params = sanitize(error_params)\n            elif isinstance(error_params, dict):\n                error_params = {k: sanitize(v) for k, v in error_params.items()}\n            elif isinstance(error_params, tuple):\n                error_params = tuple(sanitize(v) for v in error_params)\n        return error_type(error_msg % error_params, error_args)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_import_field_path",
          "params": [
            "self",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _get_import_field_path(self, field, value):\n        \"\"\" Rebuild field path for import error attribution to the right field.\n        This method uses the 'parent_fields_hierarchy' context key built during treatment of one2many fields\n        (_str_to_one2many). As the field to import is the last of the chain (child_id/child_id2/field_to_import),\n        we need to retrieve the complete hierarchy in case of error in order to assign the error to the correct\n        column in the import UI.\n\n        :param (str) field: field in which the value will be imported.\n        :param (str or list) value:\n            - str: in most of the case the value we want to import into a field is a string (or a number).\n            - list: when importing into a one2may field, all the records to import are regrouped into a list of dict.\n                E.g.: creating multiple partners: [{None: 'ChildA_1', 'type': 'Private address'}, {None: 'ChildA_2', 'type': 'Private address'}]\n                where 'None' is the name. (because we can find a partner by his name, we don't need to specify the field.)\n\n        The field_path value is computed based on the last field in the chain.\n        for example,\n            - path_field for 'Private address' at childA_1 is ['partner_id', 'type']\n            - path_field for 'childA_1' is ['partner_id']\n\n        So, by retrieving the correct field_path for each value to import, if errors are raised for those fields,\n        we can the link the errors to the correct header-field couple in the import UI.\n        \"\"\"\n        field_path = [field]\n        parent_fields_hierarchy = self._context.get('parent_fields_hierarchy')\n        if parent_fields_hierarchy:\n            field_path = parent_fields_hierarchy + field_path\n\n        field_path_value = value\n        while isinstance(field_path_value, list):\n            key = list(field_path_value[0].keys())[0]\n            if key:\n                field_path.append(key)\n            field_path_value = field_path_value[0][key]\n        return field_path",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "for_model",
          "params": [
            "self",
            "model",
            "fromtype=str"
          ],
          "decorators": [],
          "source": "def for_model(self, model, fromtype=str):\n        \"\"\" Returns a converter object for the model. A converter is a\n        callable taking a record-ish (a dictionary representing an odoo\n        record with values of typetag ``fromtype``) and returning a converted\n        records matching what :meth:`odoo.osv.orm.Model.write` expects.\n\n        :param model: :class:`odoo.osv.orm.Model` for the conversion base\n        :param fromtype:\n        :returns: a converter callable\n        :rtype: (record: dict, logger: (field, error) -> None) -> dict\n        \"\"\"\n        # make sure model is new api\n        model = self.env[model._name]\n\n        converters = {\n            name: self.to_field(model, field, fromtype)\n            for name, field in model._fields.items()\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "fn",
          "params": [
            "record",
            "log"
          ],
          "decorators": [],
          "source": "def fn(record, log):\n            converted = {}\n            import_file_context = self.env.context.get('import_file')\n            for field, value in record.items():\n                if field in REFERENCING_FIELDS:\n                    continue\n                if not value:\n                    converted[field] = False\n                    continue\n                try:\n                    converted[field], ws = converters[field](value)\n                    for w in ws:\n                        if isinstance(w, str):\n                            # wrap warning string in an ImportWarning for\n                            # uniform handling\n                            w = ImportWarning(w)\n                        log(field, w)\n                except (UnicodeEncodeError, UnicodeDecodeError) as e:\n                    log(field, ValueError(str(e)))\n                except ValueError as e:\n                    if import_file_context:\n                        # if the error is linked to a matching error, the error is a tuple\n                        # E.g.:(\"Value X cannot be found for field Y at row 1\", {\n                        #   'more_info': {},\n                        #   'value': 'X',\n                        #   'field': 'Y',\n                        #   'field_path': child_id/Y,\n                        # })\n                        # In order to link the error to the correct header-field couple in the import UI, we need to add\n                        # the field path to the additional error info.\n                        # As we raise the deepest child in error, we need to add the field path only for the deepest\n                        # error in the import recursion. (if field_path is given, don't overwrite it)\n                        error_info = len(e.args) > 1 and e.args[1]\n                        if error_info and not error_info.get('field_path'):  # only raise the deepest child in error\n                            error_info['field_path'] = self._get_import_field_path(field, value)\n                    log(field, e)\n            return converted\n\n        return fn",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "to_field",
          "params": [
            "self",
            "model",
            "field",
            "fromtype=str"
          ],
          "decorators": [],
          "source": "def to_field(self, model, field, fromtype=str):\n        \"\"\" Fetches a converter for the provided field object, from the\n        specified type.\n\n        A converter is simply a callable taking a value of type ``fromtype``\n        (or a composite of ``fromtype``, e.g. list or dict) and returning a\n        value acceptable for a write() on the field ``field``.\n\n        By default, tries to get a method on itself with a name matching the\n        pattern ``_$fromtype_to_$field.type`` and returns it.\n\n        Converter callables can either return a value and a list of warnings\n        to their caller or raise ``ValueError``, which will be interpreted as a\n        validation & conversion failure.\n\n        ValueError can have either one or two parameters. The first parameter\n        is mandatory, **must** be a unicode string and will be used as the\n        user-visible message for the error (it should be translatable and\n        translated). It can contain a ``field`` named format placeholder so the\n        caller can inject the field's translated, user-facing name (@string).\n\n        The second parameter is optional and, if provided, must be a mapping.\n        This mapping will be merged into the error dictionary returned to the\n        client.\n\n        If a converter can perform its function but has to make assumptions\n        about the data, it can send a warning to the user through adding an\n        instance of :class:`~.ImportWarning` to the second value\n        it returns. The handling of a warning at the upper levels is the same\n        as ``ValueError`` above.\n\n        :param model:\n        :param field: field object to generate a value for\n        :type field: :class:`odoo.fields.Field`\n        :param fromtype: type to convert to something fitting for ``field``\n        :type fromtype: type | str\n        :return: a function (fromtype -> field.write_type), if a converter is found\n        :rtype: Callable | None\n        \"\"\"\n        assert isinstance(fromtype, (type, str))\n        # FIXME: return None\n        typename = fromtype.__name__ if isinstance(fromtype, type) else fromtype\n        converter = getattr(self, '_%s_to_%s' % (typename, field.type), None)\n        if not converter:\n            return None\n        return functools.partial(converter, model, field)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_json",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_json(self, model, field, value):\n        try:\n            return json.loads(value), []\n        except ValueError:\n            msg = _(\"'%s' does not seem to be a valid JSON for field '%%(field)s'\")\n            raise self._format_import_error(ValueError, msg, value)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_properties",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_properties(self, model, field, value):\n        msg = _(\"Unable to import field type '%s'  \", field.type)\n        raise self._format_import_error(ValueError, msg)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_boolean",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_boolean(self, model, field, value):\n        # all translatables used for booleans\n        # potentially broken casefolding? What about locales?\n        trues = set(word.lower() for word in itertools.chain(\n            [u'1', u\"true\", u\"yes\"], # don't use potentially translated values\n            self._get_boolean_translations(u\"true\"),\n            self._get_boolean_translations(u\"yes\"),\n        ))\n        if value.lower() in trues:\n            return True, []\n\n        # potentially broken casefolding? What about locales?\n        falses = set(word.lower() for word in itertools.chain(\n            [u'', u\"0\", u\"false\", u\"no\"],\n            self._get_boolean_translations(u\"false\"),\n            self._get_boolean_translations(u\"no\"),\n        ))\n        if value.lower() in falses:\n            return False, []\n\n        if field.name in self._context.get('import_skip_records', []):\n            return None, []\n\n        return True, [self._format_import_error(\n            ValueError,\n            _(u\"Unknown value '%s' for boolean field '%%(field)s'\"),\n            value,\n            {'moreinfo': _(u\"Use '1' for yes and '0' for no\")}\n        )]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_integer",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_integer(self, model, field, value):\n        try:\n            return int(value), []\n        except ValueError:\n            raise self._format_import_error(\n                ValueError,\n                _(u\"'%s' does not seem to be an integer for field '%%(field)s'\"),\n                value\n            )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_float",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_float(self, model, field, value):\n        try:\n            return float(value), []\n        except ValueError:\n            raise self._format_import_error(\n                ValueError,\n                _(u\"'%s' does not seem to be a number for field '%%(field)s'\"),\n                value\n            )\n\n    _str_to_monetary = _str_to_float",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_id",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_id(self, model, field, value):\n        return value, []\n\n    _str_to_reference = _str_to_char = _str_to_text = _str_to_binary = _str_to_html = _str_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_date",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_date(self, model, field, value):\n        try:\n            parsed_value = fields.Date.from_string(value)\n            return fields.Date.to_string(parsed_value), []\n        except ValueError:\n            raise self._format_import_error(\n                ValueError,\n                _(u\"'%s' does not seem to be a valid date for field '%%(field)s'\"),\n                value,\n                {'moreinfo': _(u\"Use the format '%s'\", u\"2012-12-31\")}\n            )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_input_tz",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _input_tz(self):\n        # if there's a tz in context, try to use that\n        if self._context.get('tz'):\n            try:\n                return pytz.timezone(self._context['tz'])\n            except pytz.UnknownTimeZoneError:\n                pass\n\n        # if the current user has a tz set, try to use that\n        user = self.env.user\n        if user.tz:\n            try:\n                return pytz.timezone(user.tz)\n            except pytz.UnknownTimeZoneError:\n                pass\n\n        # fallback if no tz in context or on user: UTC\n        return pytz.UTC",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_datetime",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_datetime(self, model, field, value):\n        try:\n            parsed_value = fields.Datetime.from_string(value)\n        except ValueError:\n            raise self._format_import_error(\n                ValueError,\n                _(u\"'%s' does not seem to be a valid datetime for field '%%(field)s'\"),\n                value,\n                {'moreinfo': _(u\"Use the format '%s'\", u\"2012-12-31 23:59:59\")}\n            )\n\n        input_tz = self._input_tz()# Apply input tz to the parsed naive datetime\n        dt = input_tz.localize(parsed_value, is_dst=False)\n        # And convert to UTC before reformatting for writing\n        return fields.Datetime.to_string(dt.astimezone(pytz.UTC)), []",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_boolean_translations",
          "params": [
            "self",
            "src"
          ],
          "decorators": [],
          "source": "def _get_boolean_translations(self, src):\n        # Cache translations so they don't have to be reloaded from scratch on\n        # every row of the file\n        tnx_cache = self._cr.cache.setdefault(self._name, {})\n        if src in tnx_cache:\n            return tnx_cache[src]\n\n        values = OrderedSet()\n        for lang, __ in self.env['res.lang'].get_installed():\n            translations = code_translations.get_python_translations('base', lang)\n            if src in translations:\n                values.add(translations[src])\n\n        result = tnx_cache[src] = list(values)\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_selection_translations",
          "params": [
            "self",
            "field",
            "src"
          ],
          "decorators": [],
          "source": "def _get_selection_translations(self, field, src):\n        if not src:\n            return []\n        # Cache translations so they don't have to be reloaded from scratch on\n        # every row of the file\n        tnx_cache = self._cr.cache.setdefault(self._name, {})\n        if src in tnx_cache:\n            return tnx_cache[src]\n\n        values = OrderedSet()\n        self.env['ir.model.fields.selection'].flush_model()\n        query = \"\"\"\n            SELECT s.name\n            FROM ir_model_fields_selection s\n            JOIN ir_model_fields f ON s.field_id = f.id\n            WHERE f.model = %s AND f.name = %s AND s.name->>'en_US' = %s\n        \"\"\"\n        self.env.cr.execute(query, [field.model_name, field.name, src])\n        for (name,) in self.env.cr.fetchall():\n            name.pop('en_US')\n            values.update(name.values())\n\n        result = tnx_cache[src] = list(values)\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_selection",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_selection(self, model, field, value):\n        # get untranslated values\n        env = self.with_context(lang=None).env\n        selection = field.get_description(env)['selection']\n\n        for item, label in selection:\n            label = ustr(label)\n            if callable(field.selection):\n                labels = [label]\n                for item2, label2 in field._description_selection(self.env):\n                    if item2 == item:\n                        labels.append(label2)\n                        break\n            else:\n                labels = [label] + self._get_selection_translations(field, label)\n            # case insensitive comparaison of string to allow to set the value even if the given 'value' param is not\n            # exactly (case sensitive) the same as one of the selection item.\n            if value.lower() == str(item).lower() or any(value.lower() == label.lower() for label in labels):\n                return item, []\n\n        if field.name in self._context.get('import_skip_records', []):\n            return None, []\n        elif field.name in self._context.get('import_set_empty_fields', []):\n            return False, []\n        raise self._format_import_error(\n            ValueError,\n            _(u\"Value '%s' not found in selection field '%%(field)s'\"),\n            value,\n            {'moreinfo': [_label or str(item) for item, _label in selection if _label or item]}\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "db_id_for",
          "params": [
            "self",
            "model",
            "field",
            "subfield",
            "value"
          ],
          "decorators": [],
          "source": "def db_id_for(self, model, field, subfield, value):\n        \"\"\" Finds a database id for the reference ``value`` in the referencing\n        subfield ``subfield`` of the provided field of the provided model.\n\n        :param model: model to which the field belongs\n        :param field: relational field for which references are provided\n        :param subfield: a relational subfield allowing building of refs to\n                         existing records: ``None`` for a name_search,\n                         ``id`` for an external id and ``.id`` for a database\n                         id\n        :param value: value of the reference to match to an actual record\n        :return: a pair of the matched database identifier (if any), the\n                 translated user-readable name for the field and the list of\n                 warnings\n        :rtype: (ID|None, unicode, list)\n        \"\"\"\n        # the function 'flush' comes from BaseModel.load(), and forces the\n        # creation/update of former records (batch creation)\n        flush = self._context.get('import_flush', lambda **kw: None)\n\n        id = None\n        warnings = []\n        error_msg = ''\n        action = {\n            'name': 'Possible Values',\n            'type': 'ir.actions.act_window', 'target': 'new',\n            'view_mode': 'tree,form',\n            'views': [(False, 'list'), (False, 'form')],\n            'context': {'create': False},\n            'help': _(u\"See all possible values\")}\n        if subfield is None:\n            action['res_model'] = field.comodel_name\n        elif subfield in ('id', '.id'):\n            action['res_model'] = 'ir.model.data'\n            action['domain'] = [('model', '=', field.comodel_name)]\n\n        RelatedModel = self.env[field.comodel_name]\n        if subfield == '.id':\n            field_type = _(u\"database id\")\n            if isinstance(value, str) and not self._str_to_boolean(model, field, value)[0]:\n                return False, field_type, warnings\n            try:\n                tentative_id = int(value)\n            except ValueError:\n                raise self._format_import_error(\n                    ValueError,\n                    _(u\"Invalid database id '%s' for the field '%%(field)s'\"),\n                    value,\n                    {'moreinfo': action})\n            if RelatedModel.browse(tentative_id).exists():\n                id = tentative_id\n        elif subfield == 'id':\n            field_type = _(u\"external id\")\n            if not self._str_to_boolean(model, field, value)[0]:\n                return False, field_type, warnings\n            if '.' in value:\n                xmlid = value\n            else:\n                xmlid = \"%s.%s\" % (self._context.get('_import_current_module', ''), value)\n            flush(xml_id=xmlid)\n            id = self._xmlid_to_record_id(xmlid, RelatedModel)\n        elif subfield is None:\n            field_type = _(u\"name\")\n            if value == '':\n                return False, field_type, warnings\n            flush(model=field.comodel_name)\n            ids = RelatedModel.name_search(name=value, operator='=')\n            if ids:\n                if len(ids) > 1:\n                    warnings.append(ImportWarning(_(\n                        \"Found multiple matches for value %r in field %%(field)r (%d matches)\",\n                        str(value).replace('%', '%%'),\n                        len(ids),\n                    )))\n                id, _name = ids[0]\n            else:\n                name_create_enabled_fields = self.env.context.get('name_create_enabled_fields') or {}\n                if name_create_enabled_fields.get(field.name):\n                    try:\n                        with self.env.cr.savepoint():\n                            id, _name = RelatedModel.name_create(name=value)\n                    except (Exception, psycopg2.IntegrityError):\n                        error_msg = _(\"Cannot create new '%s' records from their name alone. Please create those records manually and try importing again.\", RelatedModel._description)\n        else:\n            raise self._format_import_error(\n                Exception,\n                _(\"Unknown sub-field %r\", subfield)\n            )\n\n        set_empty = False\n        skip_record = False\n        if self.env.context.get('import_file'):\n            import_set_empty_fields = self.env.context.get('import_set_empty_fields') or []\n            field_path = \"/\".join((self.env.context.get('parent_fields_hierarchy', []) + [field.name]))\n            set_empty = field_path in import_set_empty_fields\n            skip_record = field_path in self.env.context.get('import_skip_records', [])\n        if id is None and not set_empty and not skip_record:\n            if error_msg:\n                message = _(\"No matching record found for %(field_type)s '%(value)s' in field '%%(field)s' and the following error was encountered when we attempted to create one: %(error_message)s\")\n            else:\n                message = _(\"No matching record found for %(field_type)s '%(value)s' in field '%%(field)s'\")\n\n            error_info_dict = {'moreinfo': action}\n            if self.env.context.get('import_file'):\n                # limit to 50 char to avoid too long error messages.\n                value = value[:50] if isinstance(value, str) else value\n                error_info_dict.update({'value': value, 'field_type': field_type})\n                if error_msg:\n                    error_info_dict['error_message'] = error_msg\n            raise self._format_import_error(\n                ValueError,\n                message,\n                {'field_type': field_type, 'value': value, 'error_message': error_msg},\n                error_info_dict)\n        return id, field_type, warnings",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_xmlid_to_record_id",
          "params": [
            "self",
            "xmlid",
            "model"
          ],
          "decorators": [],
          "source": "def _xmlid_to_record_id(self, xmlid, model):\n        \"\"\" Return the record id corresponding to the given external id,\n        provided that the record actually exists; otherwise return ``None``.\n        \"\"\"\n        import_cache = self.env.context.get('import_cache', {})\n        result = import_cache.get(xmlid)\n\n        if not result:\n            module, name = xmlid.split('.', 1)\n            query = \"\"\"\n                SELECT d.model, d.res_id\n                FROM ir_model_data d\n                JOIN \"{}\" r ON d.res_id = r.id\n                WHERE d.module = %s AND d.name = %s\n            \"\"\".format(model._table)\n            self.env.cr.execute(query, [module, name])\n            result = self.env.cr.fetchone()\n\n        if result:\n            res_model, res_id = import_cache[xmlid] = result\n            if res_model != model._name:\n                MSG = \"Invalid external ID %s: expected model %r, found %r\"\n                raise ValueError(MSG % (xmlid, model._name, res_model))\n            return res_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_referencing_subfield",
          "params": [
            "self",
            "record"
          ],
          "decorators": [],
          "source": "def _referencing_subfield(self, record):\n        \"\"\" Checks the record for the subfields allowing referencing (an\n        existing record in an other table), errors out if it finds potential\n        conflicts (multiple referencing subfields) or non-referencing subfields\n        returns the name of the correct subfield.\n\n        :param record:\n        :return: the record subfield to use for referencing and a list of warnings\n        :rtype: str, list\n        \"\"\"\n        # Can import by display_name, external id or database id\n        fieldset = set(record)\n        if fieldset - REFERENCING_FIELDS:\n            raise ValueError(\n                _(u\"Can not create Many-To-One records indirectly, import the field separately\"))\n        if len(fieldset) > 1:\n            raise ValueError(\n                _(u\"Ambiguous specification for field '%(field)s', only provide one of name, external id or database id\"))\n\n        # only one field left possible, unpack\n        [subfield] = fieldset\n        return subfield, []",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_many2one",
          "params": [
            "self",
            "model",
            "field",
            "values"
          ],
          "decorators": [],
          "source": "def _str_to_many2one(self, model, field, values):\n        # Should only be one record, unpack\n        [record] = values\n\n        subfield, w1 = self._referencing_subfield(record)\n\n        id, _, w2 = self.db_id_for(model, field, subfield, record[subfield])\n        return id, w1 + w2",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_many2one_reference",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_many2one_reference(self, model, field, value):\n        return self._str_to_integer(model, field, value)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_many2many",
          "params": [
            "self",
            "model",
            "field",
            "value"
          ],
          "decorators": [],
          "source": "def _str_to_many2many(self, model, field, value):\n        [record] = value\n\n        subfield, warnings = self._referencing_subfield(record)\n\n        ids = []\n        for reference in record[subfield].split(','):\n            id, _, ws = self.db_id_for(model, field, subfield, reference)\n            ids.append(id)\n            warnings.extend(ws)\n\n        if field.name in self._context.get('import_set_empty_fields', []) and any([id is None for id in ids]):\n            ids = [id for id in ids if id]\n        elif field.name in self._context.get('import_skip_records', []) and any([id is None for id in ids]):\n            return None, warnings\n\n        if self._context.get('update_many2many'):\n            return [Command.link(id) for id in ids], warnings\n        else:\n            return [Command.set(ids)], warnings",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_str_to_one2many",
          "params": [
            "self",
            "model",
            "field",
            "records"
          ],
          "decorators": [],
          "source": "def _str_to_one2many(self, model, field, records):\n        name_create_enabled_fields = self._context.get('name_create_enabled_fields') or {}\n        prefix = field.name + '/'\n        relative_name_create_enabled_fields = {\n            k[len(prefix):]: v\n            for k, v in name_create_enabled_fields.items()\n            if k.startswith(prefix)\n        }\n        commands = []\n        warnings = []\n\n        if len(records) == 1 and exclude_ref_fields(records[0]) == {}:\n            # only one row with only ref field, field=ref1,ref2,ref3 as in\n            # m2o/m2m\n            record = records[0]\n            subfield, ws = self._referencing_subfield(record)\n            warnings.extend(ws)\n            # transform [{subfield:ref1,ref2,ref3}] into\n            # [{subfield:ref1},{subfield:ref2},{subfield:ref3}]\n            records = ({subfield:item} for item in record[subfield].split(','))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "log",
          "params": [
            "f",
            "exception"
          ],
          "decorators": [],
          "source": "def log(f, exception):\n            if not isinstance(exception, Warning):\n                current_field_name = self.env[field.comodel_name]._fields[f].string\n                arg0 = exception.args[0].replace('%(field)s', '%(field)s/' + current_field_name)\n                exception.args = (arg0, *exception.args[1:])\n                raise exception\n            warnings.append(exception)\n\n        # Complete the field hierarchy path\n        # E.g. For \"parent/child/subchild\", field hierarchy path for \"subchild\" is ['parent', 'child']\n        parent_fields_hierarchy = self._context.get('parent_fields_hierarchy', []) + [field.name]\n\n        convert = self.with_context(\n            name_create_enabled_fields=relative_name_create_enabled_fields,\n            parent_fields_hierarchy=parent_fields_hierarchy\n        ).for_model(self.env[field.comodel_name])\n\n        for record in records:\n            id = None\n            refs = only_ref_fields(record)\n            writable = convert(exclude_ref_fields(record), log)\n            if refs:\n                subfield, w1 = self._referencing_subfield(refs)\n                warnings.extend(w1)\n                try:\n                    id, _, w2 = self.db_id_for(model, field, subfield, record[subfield])\n                    warnings.extend(w2)\n                except ValueError:\n                    if subfield != 'id':\n                        raise\n                    writable['id'] = record['id']\n\n            if id:\n                commands.append(Command.link(id))\n                commands.append(Command.update(id, writable))\n            else:\n                commands.append(Command.create(writable))\n\n        return commands, warnings",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_format_import_error (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "for_model (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "to_field (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_boolean (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_integer (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_float (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_date (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_input_tz (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_datetime (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_boolean_translations (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_selection_translations (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_selection (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "db_id_for (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_many2one (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_many2one_reference (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_many2many (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_str_to_one2many (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrFieldsConverter"
    },
    {
      "name": "ir.filters",
      "description": "Filters",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Filter Name"
        },
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "string": "User",
          "help": "The user this filter is private to. When left empty the filter is public "
        },
        {
          "name": "domain",
          "type": "Text",
          "required": true
        },
        {
          "name": "context",
          "type": "Text",
          "required": true
        },
        {
          "name": "sort",
          "type": "Text",
          "required": true
        },
        {
          "name": "model_id",
          "type": "Selection",
          "required": true,
          "string": "Model"
        },
        {
          "name": "is_default",
          "type": "Boolean",
          "string": "Default Filter"
        },
        {
          "name": "action_id",
          "type": "Many2one",
          "relation": "ir.actions.actions",
          "string": "Action",
          "help": "The menu action this filter applies to. "
        },
        {
          "name": "active",
          "type": "Boolean"
        }
      ],
      "methods": [
        {
          "name": "_list_all_models",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _list_all_models(self):\n        lang = self.env.lang or 'en_US'\n        self._cr.execute(\n            \"SELECT model, COALESCE(name->>%s, name->>'en_US') FROM ir_model ORDER BY 2\",\n            [lang],\n        )\n        return self._cr.fetchall()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        new_filter = super().write(vals)\n        self.check_access_rule('write')\n        return new_filter",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        self.ensure_one()\n        default = dict(default or {}, name=_('%s (copy)', self.name))\n        return super(IrFilters, self).copy(default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_eval_domain",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_eval_domain(self):\n        self.ensure_one()\n        return safe_eval(self.domain, {\n            'datetime': datetime,\n            'context_today': datetime.datetime.now,\n        })",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_action_domain",
          "params": [
            "self",
            "action_id=None"
          ],
          "decorators": [],
          "source": "def _get_action_domain(self, action_id=None):\n        \"\"\"Return a domain component for matching filters that are visible in the\n           same context (menu/view) as the given action.\"\"\"\n        if action_id:\n            # filters specific to this menu + global ones\n            return [('action_id', 'in', [action_id, False])]\n        # only global ones\n        return [('action_id', '=', False)]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_filters",
          "params": [
            "self",
            "model",
            "action_id=None"
          ],
          "decorators": [],
          "source": "def get_filters(self, model, action_id=None):\n        \"\"\"Obtain the list of filters available for the user on the given model.\n\n        :param int model: id of model to find filters for\n        :param action_id: optional ID of action to restrict filters to this action\n            plus global filters. If missing only global filters are returned.\n            The action does not have to correspond to the model, it may only be\n            a contextual action.\n        :return: list of :meth:`~osv.read`-like dicts containing the\n            ``name``, ``is_default``, ``domain``, ``user_id`` (m2o tuple),\n            ``action_id`` (m2o tuple) and ``context`` of the matching ``ir.filters``.\n        \"\"\"\n        # available filters: private filters (user_id=uid) and public filters (uid=NULL),\n        # and filters for the action (action_id=action_id) or global (action_id=NULL)\n        user_context = self.env['res.users'].context_get()\n        action_domain = self._get_action_domain(action_id)\n        return self.with_context(user_context).search_read(\n            action_domain + [('model_id', '=', model), ('user_id', 'in', [self._uid, False])],\n            ['name', 'is_default', 'domain', 'context', 'user_id', 'sort'],\n        )",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_global_default",
          "params": [
            "self",
            "vals",
            "matching_filters"
          ],
          "decorators": [],
          "source": "def _check_global_default(self, vals, matching_filters):\n        \"\"\" _check_global_default(dict, list(dict), dict) -> None\n\n        Checks if there is a global default for the model_id requested.\n\n        If there is, and the default is different than the record being written\n        (-> we're not updating the current global default), raise an error\n        to avoid users unknowingly overwriting existing global defaults (they\n        have to explicitly remove the current default before setting a new one)\n\n        This method should only be called if ``vals`` is trying to set\n        ``is_default``\n\n        :raises odoo.exceptions.UserError: if there is an existing default and\n                                            we're not updating it\n        \"\"\"\n        domain = self._get_action_domain(vals.get('action_id'))\n        defaults = self.search(domain + [\n            ('model_id', '=', vals['model_id']),\n            ('user_id', '=', False),\n            ('is_default', '=', True),\n        ])\n\n        if not defaults:\n            return\n        if matching_filters and (matching_filters[0]['id'] == defaults.id):\n            return\n\n        raise UserError(_(\"There is already a shared filter set as default for %(model)s, delete or change it before setting a new default\", model=vals.get('model_id')))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create_or_replace",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def create_or_replace(self, vals):\n        action_id = vals.get('action_id')\n        current_filters = self.get_filters(vals['model_id'], action_id)\n        matching_filters = [f for f in current_filters\n                            if f['name'].lower() == vals['name'].lower()\n                            # next line looks for matching user_ids (specific or global), i.e.\n                            # f.user_id is False and vals.user_id is False or missing,\n                            # or f.user_id.id == vals.user_id\n                            if (f['user_id'] and f['user_id'][0]) == vals.get('user_id')]\n\n        if vals.get('is_default'):\n            if vals.get('user_id'):\n                # Setting new default: any other default that belongs to the user\n                # should be turned off\n                domain = self._get_action_domain(action_id)\n                defaults = self.search(domain + [\n                    ('model_id', '=', vals['model_id']),\n                    ('user_id', '=', vals['user_id']),\n                    ('is_default', '=', True),\n                ])\n                if defaults:\n                    defaults.write({'is_default': False})\n            else:\n                self._check_global_default(vals, matching_filters)\n\n        # When a filter exists for the same (name, model, user) triple, we simply\n        # replace its definition (considering action_id irrelevant here)\n        if matching_filters:\n            matching_filter = self.browse(matching_filters[0]['id'])\n            matching_filter.write(vals)\n            return matching_filter\n\n        return self.create(vals)\n\n    _sql_constraints = [\n        # Partial constraint, complemented by unique index (see below). Still\n        # useful to keep because it provides a proper error message when a\n        # violation occurs, as it shares the same prefix as the unique index.\n        ('name_model_uid_unique', 'unique (model_id, user_id, action_id, name)', 'Filter names must be unique'),\n    ]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_auto_init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _auto_init(self):\n        result = super(IrFilters, self)._auto_init()\n        # Use unique index to implement unique constraint on the lowercase name (not possible using a constraint)\n        tools.create_unique_index(self._cr, 'ir_filters_name_model_uid_unique_action_index',\n            self._table, ['model_id', 'COALESCE(user_id,-1)', 'COALESCE(action_id,-1)', 'lower(name)'])\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_model_uid_unique",
          "definition": "unique (model_id, user_id, action_id, name)",
          "message": "Filter names must be unique"
        }
      ],
      "accessRules": [
        {
          "name": "_list_all_models (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_action_domain (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_filters (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_check_global_default (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rule",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrFilters"
    },
    {
      "name": "ir.http",
      "description": "HTTP Routing",
      "fields": [],
      "methods": [
        {
          "name": "_get_converters",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _get_converters(cls):\n        return {'model': ModelConverter, 'models': ModelsConverter, 'int': SignedIntConverter}",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_match",
          "params": [
            "cls",
            "path_info"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _match(cls, path_info):\n        rule, args = request.env['ir.http'].routing_map().bind_to_environ(request.httprequest.environ).match(path_info=path_info, return_rule=True)\n        return rule, args",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_get_public_users",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _get_public_users(cls):\n        return [request.env['ir.model.data']._xmlid_to_res_model_res_id('base.public_user')[1]]",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_auth_method_user",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _auth_method_user(cls):\n        if request.env.uid in [None] + cls._get_public_users():\n            raise http.SessionExpiredException(\"Session expired\")",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_auth_method_none",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _auth_method_none(cls):\n        request.env = api.Environment(request.env.cr, None, request.env.context)",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_auth_method_public",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _auth_method_public(cls):\n        if request.env.uid is None:\n            public_user = request.env.ref('base.public_user')\n            request.update_env(user=public_user.id)",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_authenticate",
          "params": [
            "cls",
            "endpoint"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _authenticate(cls, endpoint):\n        auth = 'none' if http.is_cors_preflight(request, endpoint) else endpoint.routing['auth']\n\n        try:\n            if request.session.uid is not None:\n                if not security.check_session(request.session, request.env):\n                    request.session.logout(keep_db=True)\n                    request.env = api.Environment(request.env.cr, None, request.session.context)\n            getattr(cls, f'_auth_method_{auth}')()\n        except (AccessDenied, http.SessionExpiredException, werkzeug.exceptions.HTTPException):\n            raise\n        except Exception:\n            _logger.info(\"Exception during request Authentication.\", exc_info=True)\n            raise AccessDenied()",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_geoip_resolve",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _geoip_resolve(cls):\n        return request._geoip_resolve()",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_pre_dispatch",
          "params": [
            "cls",
            "rule",
            "args"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _pre_dispatch(cls, rule, args):\n        ICP = request.env['ir.config_parameter'].with_user(SUPERUSER_ID)\n\n        # Change the default database-wide 128MiB upload limit on the\n        # ICP value. Do it before calling http's generic pre_dispatch\n        # so that the per-route limit @route(..., max_content_length=x)\n        # takes over.\n        try:\n            key = 'web.max_file_upload_size'\n            if (value := ICP.get_param(key, None)) is not None:\n                request.httprequest.max_content_length = int(value)\n        except ValueError:  # better not crash on ALL requests\n            _logger.error(\"invalid %s: %r, using %s instead\",\n                key, value, request.httprequest.max_content_length,\n            )\n\n        request.dispatcher.pre_dispatch(rule, args)\n\n        # Replace uid placeholder by the current request.env.uid\n        for key, val in list(args.items()):\n            if isinstance(val, models.BaseModel) and isinstance(val._uid, RequestUID):\n                args[key] = val.with_user(request.env.uid)\n\n        # verify the default language set in the context is valid,\n        # otherwise fallback on the company lang, english or the first\n        # lang installed\n        env = request.env if request.env.uid else request.env['base'].with_user(SUPERUSER_ID).env\n        request.update_context(lang=get_lang(env)._get_cached('code'))\n\n        for key, val in list(args.items()):\n            if not isinstance(val, models.BaseModel):\n                continue\n\n            try:\n                # explicitly crash now, instead of crashing later\n                args[key].check_access_rights('read')\n                args[key].check_access_rule('read')\n            except (odoo.exceptions.AccessError, odoo.exceptions.MissingError) as e:\n                # custom behavior in case a record is not accessible / has been removed\n                if handle_error := rule.endpoint.routing.get('handle_params_access_error'):\n                    if response := handle_error(e):\n                        werkzeug.exceptions.abort(response)\n                if isinstance(e, odoo.exceptions.MissingError):\n                    raise werkzeug.exceptions.NotFound() from e\n                raise",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_dispatch",
          "params": [
            "cls",
            "endpoint"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _dispatch(cls, endpoint):\n        result = endpoint(**request.params)\n        if isinstance(result, Response) and result.is_qweb:\n            result.flatten()\n        return result",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_post_dispatch",
          "params": [
            "cls",
            "response"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _post_dispatch(cls, response):\n        request.dispatcher.post_dispatch(response)",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_post_logout",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _post_logout(cls):\n        pass",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_handle_error",
          "params": [
            "cls",
            "exception"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _handle_error(cls, exception):\n        return request.dispatcher.handle_error(exception)",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_serve_fallback",
          "params": [
            "cls"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _serve_fallback(cls):\n        model = request.env['ir.attachment']\n        attach = model.sudo()._get_serve_attachment(request.httprequest.path)\n        if attach and (attach.store_fname or attach.db_datas):\n            return Stream.from_attachment(attach).get_response()",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_redirect",
          "params": [
            "cls",
            "location",
            "code=303"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _redirect(cls, location, code=303):\n        return werkzeug.utils.redirect(location, code=code, Response=Response)",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_generate_routing_rules",
          "params": [
            "self",
            "modules",
            "converters"
          ],
          "decorators": [],
          "source": "def _generate_routing_rules(self, modules, converters):\n        return http._generate_routing_rules(modules, False, converters)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "routing_map",
          "params": [
            "self",
            "key=None"
          ],
          "decorators": [],
          "source": "def routing_map(self, key=None):\n        _logger.info(\"Generating routing map for key %s\", str(key))\n        registry = Registry(threading.current_thread().dbname)\n        installed = registry._init_modules.union(odoo.conf.server_wide_modules)\n        if tools.config['test_enable'] and odoo.modules.module.current_test:\n            installed.add(odoo.modules.module.current_test)\n        mods = sorted(installed)\n        # Note : when routing map is generated, we put it on the class `cls`\n        # to make it available for all instance. Since `env` create an new instance\n        # of the model, each instance will regenared its own routing map and thus\n        # regenerate its EndPoint. The routing map should be static.\n        routing_map = werkzeug.routing.Map(strict_slashes=False, converters=self._get_converters())\n        for url, endpoint in self._generate_routing_rules(mods, converters=self._get_converters()):\n            routing = submap(endpoint.routing, ROUTING_KEYS)\n            if routing['methods'] is not None and 'OPTIONS' not in routing['methods']:\n                routing['methods'] = [*routing['methods'], 'OPTIONS']\n            rule = FasterRule(url, endpoint=endpoint, **routing)\n            rule.merge_slashes = False\n            routing_map.add(rule)\n        return routing_map",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_gc_sessions",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _gc_sessions(self):\n        if os.getenv(\"ODOO_SKIP_GC_SESSIONS\"):\n            return\n        ICP = self.env[\"ir.config_parameter\"]\n        max_lifetime = int(ICP.get_param('sessions.max_inactivity_seconds', http.SESSION_LIFETIME))\n        http.root.session_store.vacuum(max_lifetime=max_lifetime)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_translations_for_webclient",
          "params": [
            "self",
            "modules",
            "lang"
          ],
          "decorators": [],
          "source": "def get_translations_for_webclient(self, modules, lang):\n        if not modules:\n            modules = self.pool._init_modules\n        if not lang:\n            lang = self._context.get(\"lang\")\n        langs = self.env['res.lang']._lang_get(lang)\n        lang_params = None\n        if langs:\n            lang_params = {\n                \"name\": langs.name,\n                \"direction\": langs.direction,\n                \"date_format\": langs.date_format,\n                \"time_format\": langs.time_format,\n                \"grouping\": langs.grouping,\n                \"decimal_point\": langs.decimal_point,\n                \"thousands_sep\": langs.thousands_sep,\n                \"week_start\": langs.week_start,\n            }\n            lang_params['week_start'] = int(lang_params['week_start'])\n            lang_params['code'] = lang\n\n        # Regional languages (ll_CC) must inherit/override their parent lang (ll), but this is\n        # done server-side when the language is loaded, so we only need to load the user's lang.\n        translations_per_module = {}\n        for module in modules:\n            translations_per_module[module] = code_translations.get_web_translations(module, lang)\n\n        return translations_per_module, lang_params",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_web_translations_hash",
          "params": [
            "self",
            "modules",
            "lang"
          ],
          "decorators": [],
          "source": "def get_web_translations_hash(self, modules, lang):\n        translations, lang_params = self.get_translations_for_webclient(modules, lang)\n        translation_cache = {\n            'lang_parameters': lang_params,\n            'modules': translations,\n            'lang': lang,\n            'multi_lang': len(self.env['res.lang'].sudo().get_installed()) > 1,\n        }\n        return hashlib.sha1(json.dumps(translation_cache, sort_keys=True).encode()).hexdigest()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_allowed_cookie",
          "params": [
            "cls",
            "cookie_type"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _is_allowed_cookie(cls, cookie_type):\n        return True",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_verify_request_recaptcha_token",
          "params": [
            "self",
            "action"
          ],
          "decorators": [],
          "source": "def _verify_request_recaptcha_token(self, action):\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_translations_for_webclient (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_verify_request_recaptcha_token (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrHttp"
    },
    {
      "name": "ir.logging",
      "description": "Logging",
      "fields": [
        {
          "name": "create_uid",
          "type": "Integer",
          "readonly": true,
          "string": "Created by"
        },
        {
          "name": "create_date",
          "type": "Datetime",
          "readonly": true,
          "string": "Created on"
        },
        {
          "name": "write_uid",
          "type": "Integer",
          "readonly": true,
          "string": "Last Updated by"
        },
        {
          "name": "write_date",
          "type": "Datetime",
          "readonly": true,
          "string": "Last Updated on"
        },
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "type",
          "type": "Selection"
        },
        {
          "name": "dbname",
          "type": "Char",
          "string": "Database Name"
        },
        {
          "name": "level",
          "type": "Char"
        },
        {
          "name": "message",
          "type": "Text",
          "required": true
        },
        {
          "name": "path",
          "type": "Char",
          "required": true
        },
        {
          "name": "func",
          "type": "Char",
          "required": true,
          "string": "Function"
        },
        {
          "name": "line",
          "type": "Char",
          "required": true
        }
      ],
      "methods": [
        {
          "name": "init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def init(self):\n        super(IrLogging, self).init()\n        self._cr.execute(\"select 1 from information_schema.constraint_column_usage where table_name = 'ir_logging' and constraint_name = 'ir_logging_write_uid_fkey'\")\n        if self._cr.rowcount:\n            # DROP CONSTRAINT unconditionally takes an ACCESS EXCLUSIVE lock\n            # on the table, even \"IF EXISTS\" is set and not matching; disabling\n            # the relevant trigger instead acquires SHARE ROW EXCLUSIVE, which\n            # still conflicts with the ROW EXCLUSIVE needed for an insert\n            self._cr.execute(\"ALTER TABLE ir_logging DROP CONSTRAINT ir_logging_write_uid_fkey\")",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "IrLogging"
    },
    {
      "name": "ir.mail_server",
      "description": "Mail Server",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Name"
        },
        {
          "name": "from_filter",
          "type": "Char",
          "help": "Comma-separated list of addresses or domains for which this server can be used.\\n"
        },
        {
          "name": "smtp_host",
          "type": "Char",
          "string": "SMTP Server",
          "help": "Hostname or IP of SMTP server"
        },
        {
          "name": "smtp_port",
          "type": "Integer",
          "string": "SMTP Port",
          "help": "SMTP Port. Usually 465 for SSL, and 25 or 587 for other cases."
        },
        {
          "name": "smtp_authentication",
          "type": "Selection"
        },
        {
          "name": "smtp_authentication_info",
          "type": "Text"
        },
        {
          "name": "smtp_user",
          "type": "Char",
          "string": "Username",
          "help": "Optional username for SMTP authentication"
        },
        {
          "name": "smtp_pass",
          "type": "Char",
          "string": "Password",
          "help": "Optional password for SMTP authentication"
        },
        {
          "name": "smtp_encryption",
          "type": "Selection"
        },
        {
          "name": "smtp_ssl_certificate",
          "type": "Binary",
          "help": "SSL certificate used for authentication"
        },
        {
          "name": "smtp_ssl_private_key",
          "type": "Binary",
          "help": "SSL private key used for authentication"
        },
        {
          "name": "smtp_debug",
          "type": "Boolean",
          "string": "Debugging",
          "help": "If enabled, the full output of SMTP sessions will "
        },
        {
          "name": "sequence",
          "type": "Integer",
          "string": "Priority",
          "help": "When no specific mail server is requested for a mail, the highest priority one "
        },
        {
          "name": "active",
          "type": "Boolean"
        }
      ],
      "methods": [
        {
          "name": "_compute_smtp_authentication_info",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_smtp_authentication_info(self):\n        for server in self:\n            if server.smtp_authentication == 'login':\n                server.smtp_authentication_info = _(\n                    'Connect to your server through your usual username and password. \\n'\n                    'This is the most basic SMTP authentication process and '\n                    'may not be accepted by all providers. \\n')\n            elif server.smtp_authentication == 'certificate':\n                server.smtp_authentication_info = _(\n                    'Authenticate by using SSL certificates, belonging to your domain name. \\n'\n                    'SSL certificates allow you to authenticate your mail server for the entire domain name.')\n            elif server.smtp_authentication == 'cli':\n                server.smtp_authentication_info = _(\n                    'Use the SMTP configuration set in the \"Command Line Interface\" arguments.')\n            else:\n                server.smtp_authentication = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_smtp_ssl_files",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_smtp_ssl_files(self):\n        for mail_server in self:\n            if mail_server.smtp_authentication == 'certificate':\n                if not mail_server.smtp_ssl_private_key:\n                    raise UserError(_('SSL private key is missing for %s.', mail_server.name))\n                if not mail_server.smtp_ssl_certificate:\n                    raise UserError(_('SSL certificate is missing for %s.', mail_server.name))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        \"\"\"Ensure we cannot archive a server in-use\"\"\"\n        usages_per_server = {}\n        if not vals.get('active', True):\n            usages_per_server = self._active_usages_compute()\n\n        if not usages_per_server:\n            return super().write(vals)\n\n        # Write cannot be performed as some server are used, build detailed usage per server\n        usage_details_per_server = {}\n        is_multiple_server_usage = len(usages_per_server) > 1\n        for server in self:\n            if server.id not in usages_per_server:\n                continue\n            usage_details = []\n            if is_multiple_server_usage:\n                usage_details.append(_('%s (Dedicated Outgoing Mail Server):', server.display_name))\n            usage_details.extend(map(lambda u: f'- {u}', usages_per_server[server.id]))\n            usage_details_per_server[server] = usage_details\n\n        # Raise the error with the ordered list of servers and concatenated detailed usages\n        servers_ordered_by_name = sorted(usage_details_per_server.keys(), key=lambda r: r.display_name)\n        error_server_usage = ', '.join(server.display_name for server in servers_ordered_by_name)\n        error_usage_details = '\\n'.join(line\n                                        for server in servers_ordered_by_name\n                                        for line in usage_details_per_server[server])\n        if is_multiple_server_usage:\n            raise UserError(\n                _('You cannot archive these Outgoing Mail Servers (%s) because they are still used in the following case(s):\\n%s',\n                  error_server_usage, error_usage_details))\n        raise UserError(\n            _('You cannot archive this Outgoing Mail Server (%s) because it is still used in the following case(s):\\n%s',\n              error_server_usage, error_usage_details))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_active_usages_compute",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _active_usages_compute(self):\n        \"\"\"Compute a dict server id to list of user-friendly outgoing mail servers usage of this record set.\n\n        This method must be overridden by all modules that uses this class in order to complete the list with\n        user-friendly string describing the active elements that could send mail through the instance of this class.\n        :return dict: { ir_mail_server.id: usage_str_list }.\n        \"\"\"\n        return dict()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_test_email_from",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_test_email_from(self):\n        self.ensure_one()\n        email_from = False\n        if from_filter_parts := [part.strip() for part in (self.from_filter or '').split(\",\") if part.strip()]:\n            # find first found complete email in filter parts\n            email_from = next((email for email in from_filter_parts if \"@\" in email), False)\n            # no complete email -> consider noreply\n            if not email_from:\n                email_from = f\"noreply@{from_filter_parts[0]}\"\n        if not email_from:\n            # Fallback to current user email if there's no from filter\n            email_from = self.env.user.email\n        if not email_from or \"@\" not in email_from:\n            raise UserError(_('Please configure an email on the current user to simulate '\n                              'sending an email message via this outgoing server'))\n        return email_from",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_test_email_to",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_test_email_to(self):\n        return \"noreply@odoo.com\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "test_smtp_connection",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def test_smtp_connection(self):\n        for server in self:\n            smtp = False\n            try:\n                smtp = self.connect(mail_server_id=server.id, allow_archived=True)\n                # simulate sending an email from current user's address - without sending it!\n                email_from = server._get_test_email_from()\n                email_to = server._get_test_email_to()\n                # Testing the MAIL FROM step should detect sender filter problems\n                (code, repl) = smtp.mail(email_from)\n                if code != 250:\n                    raise UserError(_('The server refused the sender address (%(email_from)s) with error %(repl)s', email_from=email_from, repl=repl))  # noqa: TRY301\n                # Testing the RCPT TO step should detect most relaying problems\n                (code, repl) = smtp.rcpt(email_to)\n                if code not in (250, 251):\n                    raise UserError(_('The server refused the test recipient (%(email_to)s) with error %(repl)s', email_to=email_to, repl=repl))  # noqa: TRY301\n                # Beginning the DATA step should detect some deferred rejections\n                # Can't use self.data() as it would actually send the mail!\n                smtp.putcmd(\"data\")\n                (code, repl) = smtp.getreply()\n                if code != 354:\n                    raise UserError(_('The server refused the test connection with error %(repl)s', repl=repl))  # noqa: TRY301\n            except (UnicodeError, idna.core.InvalidCodepoint) as e:\n                raise UserError(_(\"Invalid server name!\\n %s\", e)) from e\n            except (gaierror, timeout) as e:\n                raise UserError(_(\"No response received. Check server address and port number.\\n %s\", e)) from e\n            except smtplib.SMTPServerDisconnected as e:\n                raise UserError(_(\"The server has closed the connection unexpectedly. Check configuration served on this port number.\\n %s\", e)) from e\n            except smtplib.SMTPResponseException as e:\n                raise UserError(_(\"Server replied with following exception:\\n %s\", e)) from e\n            except smtplib.SMTPNotSupportedError as e:\n                raise UserError(_(\"An option is not supported by the server:\\n %s\", e)) from e\n            except smtplib.SMTPException as e:\n                raise UserError(_(\"An SMTP exception occurred. Check port number and connection security type.\\n %s\", e)) from e\n            except (ssl.SSLError, SSLError) as e:\n                raise UserError(_(\"An SSL exception occurred. Check connection security type.\\n %s\", e)) from e\n            except UserError:\n                raise\n            except Exception as e:\n                _logger.warning(\"Connection test on %s failed with a generic error.\", server, exc_info=True)\n                raise UserError(_(\"Connection Test Failed! Here is what we got instead:\\n %s\", e)) from e\n            finally:\n                try:\n                    if smtp:\n                        smtp.close()\n                except Exception:\n                    # ignored, just a consequence of the previous exception\n                    pass\n\n        message = _(\"Connection Test Successful!\")\n        return {\n            'type': 'ir.actions.client',\n            'tag': 'display_notification',\n            'params': {\n                'message': message,\n                'type': 'success',\n                'sticky': False,\n            }\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_smtp_login",
          "params": [
            "self",
            "connection",
            "smtp_user",
            "smtp_password"
          ],
          "decorators": [],
          "source": "def _smtp_login(self, connection, smtp_user, smtp_password):\n        \"\"\"Authenticate the SMTP connection.\n\n        Can be overridden in other module for different authentication methods.Can be\n        called on the model itself or on a singleton.\n\n        :param connection: The SMTP connection to authenticate\n        :param smtp_user: The user to used for the authentication\n        :param smtp_password: The password to used for the authentication\n        \"\"\"\n        connection.login(smtp_user, smtp_password)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_bounce_address",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_bounce_address(self):\n        \"\"\" Computes the default bounce address. It is used to set the envelop\n        address if no envelop address is provided in the message.\n\n        :return str/None: defaults to the ``--email-from`` CLI/config parameter.\n        \"\"\"\n        return tools.config.get(\"email_from\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_from_address",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_from_address(self):\n        \"\"\" Computes the default from address. It is used for the \"header from\"\n        address when no other has been received.\n\n        :return str/None: defaults to the ``--email-from`` CLI/config parameter.\n        \"\"\"\n        return tools.config.get(\"email_from\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_from_filter",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_from_filter(self):\n        \"\"\" Computes the default from_filter. It is used when no specific\n        ir.mail_server is used when sending emails, hence having no value for\n        from_filter.\n\n        :return str/None: defaults to 'mail.default.from_filter', then\n          ``--from-filter`` CLI/config parameter.\n        \"\"\"\n        return self.env['ir.config_parameter'].sudo().get_param(\n            'mail.default.from_filter', tools.config.get('from_filter')\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_prepare_email_message",
          "params": [
            "self",
            "message",
            "smtp_session"
          ],
          "decorators": [],
          "source": "def _prepare_email_message(self, message, smtp_session):\n        \"\"\"Prepare the SMTP information (from, to, message) before sending.\n\n        :param message: the email.message.Message to send, information like the\n            Return-Path, the From, etc... will be used to find the smtp_from and to smtp_to\n        :param smtp_session: the opened SMTP session to use to authenticate the sender\n        :return: smtp_from, smtp_to_list, message\n            smtp_from: email to used during the authentication to the mail server\n            smtp_to_list: list of email address which will receive the email\n            message: the email.message.Message to send\n        \"\"\"\n        # Use the default bounce address **only if** no Return-Path was\n        # provided by caller.  Caller may be using Variable Envelope Return\n        # Path (VERP) to detect no-longer valid email addresses.\n        # context may force a value, e.g. mail.alias.domain usage\n        bounce_address = self.env.context.get('domain_bounce_address') or message['Return-Path'] or self._get_default_bounce_address() or message['From']\n\n        smtp_from = message['From'] or bounce_address\n        assert smtp_from, self.NO_FOUND_SMTP_FROM\n\n        email_to = message['To']\n        email_cc = message['Cc']\n        email_bcc = message['Bcc']\n        del message['Bcc']\n\n        # All recipient addresses must only contain ASCII characters; support\n        # optional pre-validated To list, used notably when formatted emails may\n        # create fake emails using extract_rfc2822_addresses, e.g.\n        # '\"Bike@Home\" <email@domain.com>' which can be considered as containing\n        # 2 emails by extract_rfc2822_addresses\n        validated_to = self.env.context.get('send_validated_to') or []\n        smtp_to_list = [\n            address\n            for base in [email_to, email_cc, email_bcc]\n            # be sure a given address does not return duplicates (but duplicates\n            # in final smtp to list is still ok)\n            for address in tools.misc.unique(extract_rfc2822_addresses(base))\n            if address and (not validated_to or address in validated_to)\n        ]\n        assert smtp_to_list, self.NO_VALID_RECIPIENT\n\n        x_forge_to = message['X-Forge-To']\n        if x_forge_to:\n            # `To:` header forged, e.g. for posting on discuss.channels, to avoid confusion\n            del message['X-Forge-To']\n            del message['To']           # avoid multiple To: headers!\n            message['To'] = x_forge_to\n\n        # Try to not spoof the mail from headers; fetch session-based or contextualized\n        # values for encapsulation computation\n        from_filter = getattr(smtp_session, 'from_filter', False)\n        smtp_from = getattr(smtp_session, 'smtp_from', False) or smtp_from\n        notifications_email = email_normalize(\n            self.env.context.get('domain_notifications_email') or self._get_default_from_address()\n        )\n        if notifications_email and email_normalize(smtp_from) == notifications_email and email_normalize(message['From']) != notifications_email:\n            smtp_from = encapsulate_email(message['From'], notifications_email)\n\n        if message['From'] != smtp_from:\n            del message['From']\n            message['From'] = smtp_from\n\n        # Check if it's still possible to put the bounce address as smtp_from\n        if self._match_from_filter(bounce_address, from_filter):\n            # Mail headers FROM will be spoofed to be able to receive bounce notifications\n            # Because the mail server support the domain of the bounce address\n            smtp_from = bounce_address\n\n        # The email's \"Envelope From\" (Return-Path) must only contain ASCII characters.\n        smtp_from_rfc2822 = extract_rfc2822_addresses(smtp_from)\n        if not smtp_from_rfc2822:\n            raise AssertionError(\n                self.NO_VALID_FROM,\n                f\"Malformed 'Return-Path' or 'From' address: {smtp_from} - \"\n                \"It should contain one valid plain ASCII email\"\n            )\n        smtp_from = smtp_from_rfc2822[-1]\n\n        return smtp_from, smtp_to_list, message",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_find_mail_server",
          "params": [
            "self",
            "email_from",
            "mail_servers=None"
          ],
          "decorators": [],
          "source": "def _find_mail_server(self, email_from, mail_servers=None):\n        \"\"\"Find the appropriate mail server for the given email address.\n\n        Returns: Record<ir.mail_server>, email_from\n        - Mail server to use to send the email (None if we use the odoo-bin arguments)\n        - Email FROM to use to send the email (in some case, it might be impossible\n          to use the given email address directly if no mail server is configured for)\n        \"\"\"\n        email_from_normalized = email_normalize(email_from)\n        email_from_domain = email_domain_extract(email_from_normalized)\n        notifications_email = self.env.context.get('domain_notifications_email') or email_normalize(self._get_default_from_address())\n        notifications_domain = email_domain_extract(notifications_email)\n\n        if mail_servers is None:\n            mail_servers = self.sudo().search([], order='sequence')\n        # 0. Archived mail server should never be used\n        mail_servers = mail_servers.filtered('active')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "first_match",
          "params": [
            "target",
            "normalize_method"
          ],
          "decorators": [],
          "source": "def first_match(target, normalize_method):\n            for mail_server in mail_servers:\n                if mail_server.from_filter and any(\n                    normalize_method(email.strip()) == target\n                    for email in mail_server.from_filter.split(',')\n                ):\n                    return mail_server\n\n        # 1. Try to find a mail server for the right mail from\n        # Skip if passed email_from is False (example Odoobot has no email address)\n        if email_from_normalized:\n            if mail_server := first_match(email_from_normalized, email_normalize):\n                return mail_server, email_from\n\n            if mail_server := first_match(email_from_domain, email_domain_normalize):\n                return mail_server, email_from\n\n        # 2. Try to find a mail server for <notifications@domain.com>\n        if notifications_email:\n            if mail_server := first_match(notifications_email, email_normalize):\n                return mail_server, notifications_email\n\n            if mail_server := first_match(notifications_domain, email_domain_normalize):\n                return mail_server, notifications_email\n\n        # 3. Take the first mail server without \"from_filter\" because\n        # nothing else has been found... Will spoof the FROM because\n        # we have no other choices (will use the notification email if available\n        # otherwise we will use the user email)\n        if mail_server := mail_servers.filtered(lambda m: not m.from_filter):\n            return mail_server[0], notifications_email or email_from\n\n        # 4. Return the first mail server even if it was configured for another domain\n        if mail_servers:\n            _logger.warning(\n                \"No mail server matches the from_filter, using %s as fallback\",\n                notifications_email or email_from)\n            return mail_servers[0], notifications_email or email_from\n\n        # 5: SMTP config in odoo-bin arguments\n        from_filter = self.env['ir.mail_server']._get_default_from_filter()\n\n        if self._match_from_filter(email_from, from_filter):\n            return None, email_from\n\n        if notifications_email and self._match_from_filter(notifications_email, from_filter):\n            return None, notifications_email\n\n        _logger.warning(\n            \"The from filter of the CLI configuration does not match the notification email \"\n            \"or the user email, using %s as fallback\",\n            notifications_email or email_from)\n        return None, notifications_email or email_from",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_match_from_filter",
          "params": [
            "self",
            "email_from",
            "from_filter"
          ],
          "decorators": [],
          "source": "def _match_from_filter(self, email_from, from_filter):\n        \"\"\"Return True is the given email address match the \"from_filter\" field.\n\n        The from filter can be Falsy (always match),\n        a domain name or an full email address.\n        \"\"\"\n        if not from_filter:\n            return True\n\n        normalized_mail_from = email_normalize(email_from)\n        normalized_domain = email_domain_extract(normalized_mail_from)\n\n        for email_filter in [part.strip() for part in (from_filter or '').split(',') if part.strip()]:\n            if '@' in email_filter and email_normalize(email_filter) == normalized_mail_from:\n                return True\n            if '@' not in email_filter and email_domain_normalize(email_filter) == normalized_domain:\n                return True\n        return False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_encryption",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_encryption(self):\n        result = {}\n        if self.smtp_encryption == 'ssl':\n            self.smtp_port = 465\n            if not 'SMTP_SSL' in smtplib.__all__:\n                result['warning'] = {\n                    'title': _('Warning'),\n                    'message': _('Your server does not seem to support SSL, you may want to try STARTTLS instead'),\n                }\n        else:\n            self.smtp_port = 25\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_test_mode",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _is_test_mode(self):\n        \"\"\"Return True if we are running the tests, so we do not send real emails.\n\n        Can be overridden in tests after mocking the SMTP lib to test in depth the\n        outgoing mail server.\n        \"\"\"\n        return getattr(threading.current_thread(), 'testing', False) or self.env.registry.in_test_mode()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_smtp_ssl_files",
          "definition": "@api.constrains('smtp_authentication', 'smtp_ssl_certificate', 'smtp_ssl_private_key')\n    def _check_smtp_ssl_files(self):\n        for mail_server in self:\n            if mail_server.smtp_authentication == 'certificate':\n                if not mail_server.smtp_ssl_private_key:\n                    raise UserError(_('SSL private key is missing for %s.', mail_server.name))\n                if not mail_server.smtp_ssl_certificate:\n                    raise UserError(_('SSL certificate is missing for %s.', mail_server.name))",
          "message": "'smtp_authentication', 'smtp_ssl_certificate', 'smtp_ssl_private_key'"
        }
      ],
      "accessRules": [
        {
          "name": "_get_default_bounce_address (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_from_address (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_from_filter (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "send_email (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_match_from_filter (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrMailServer"
    },
    {
      "name": "base",
      "description": "Base",
      "fields": [],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "Base"
    },
    {
      "name": "_unknown",
      "description": "Unknown",
      "fields": [],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "Unknown"
    },
    {
      "name": "ir.model",
      "description": "Models",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Model Description"
        },
        {
          "name": "model",
          "type": "Char",
          "required": true
        },
        {
          "name": "order",
          "type": "Char",
          "required": true,
          "string": "Order",
          "help": "SQL expression for ordering records in the model; e.g. "
        },
        {
          "name": "info",
          "type": "Text",
          "string": "Information"
        },
        {
          "name": "field_id",
          "type": "One2many",
          "relation": "ir.model.fields",
          "required": true,
          "string": "Fields"
        },
        {
          "name": "inherited_model_ids",
          "type": "Many2many",
          "relation": "ir.model",
          "string": "Inherited models",
          "help": "The list of models that extends the current model."
        },
        {
          "name": "state",
          "type": "Selection"
        },
        {
          "name": "access_ids",
          "type": "One2many",
          "relation": "ir.model.access",
          "string": "Access"
        },
        {
          "name": "rule_ids",
          "type": "One2many",
          "relation": "ir.rule",
          "string": "Record Rules"
        },
        {
          "name": "transient",
          "type": "Boolean",
          "string": "Transient Model"
        },
        {
          "name": "modules",
          "type": "Char",
          "string": "In Apps",
          "help": "List of modules in which the object is defined or inherited"
        },
        {
          "name": "view_ids",
          "type": "One2many",
          "relation": "ir.ui.view",
          "string": "Views"
        },
        {
          "name": "count",
          "type": "Integer"
        }
      ],
      "methods": [
        {
          "name": "_default_field_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _default_field_id(self):\n        if self.env.context.get('install_mode'):\n            return []                   # no default field when importing\n        return [Command.create({'name': 'x_name', 'field_description': 'Name', 'ttype': 'char', 'copied': True})]\n\n    name = fields.Char(string='Model Description', translate=True, required=True)\n    model = fields.Char(default='x_', required=True)\n    order = fields.Char(string='Order', default='id', required=True,\n                        help='SQL expression for ordering records in the model; e.g. \"x_sequence asc, id desc\"')\n    info = fields.Text(string='Information')\n    field_id = fields.One2many('ir.model.fields', 'model_id', string='Fields', required=True, copy=True,\n                               default=_default_field_id)\n    inherited_model_ids = fields.Many2many('ir.model', compute='_inherited_models', string=\"Inherited models\",\n                                           help=\"The list of models that extends the current model.\")\n    state = fields.Selection([('manual', 'Custom Object'), ('base', 'Base Object')], string='Type', default='manual', readonly=True)\n    access_ids = fields.One2many('ir.model.access', 'model_id', string='Access')\n    rule_ids = fields.One2many('ir.rule', 'model_id', string='Record Rules')\n    transient = fields.Boolean(string=\"Transient Model\")\n    modules = fields.Char(compute='_in_modules', string='In Apps', help='List of modules in which the object is defined or inherited')\n    view_ids = fields.One2many('ir.ui.view', compute='_view_ids', string='Views')\n    count = fields.Integer(compute='_compute_count', string=\"Count (Incl. Archived)\",\n                           help=\"Total number of records in this model\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inherited_models",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inherited_models(self):\n        self.inherited_model_ids = False\n        for model in self:\n            parent_names = list(self.env[model.model]._inherits)\n            if parent_names:\n                model.inherited_model_ids = self.search([('model', 'in', parent_names)])\n            else:\n                model.inherited_model_ids = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_in_modules",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _in_modules(self):\n        installed_modules = self.env['ir.module.module'].search([('state', '=', 'installed')])\n        installed_names = set(installed_modules.mapped('name'))\n        xml_ids = models.Model._get_external_ids(self)\n        for model in self:\n            module_names = set(xml_id.split('.')[0] for xml_id in xml_ids[model.id])\n            model.modules = \", \".join(sorted(installed_names & module_names))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_view_ids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _view_ids(self):\n        for model in self:\n            model.view_ids = self.env['ir.ui.view'].search([('model', '=', model.model)])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_count",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_count(self):\n        cr = self.env.cr\n        self.count = 0\n        for model in self:\n            records = self.env[model.model]\n            if not records._abstract and records._auto:\n                cr.execute(sql.SQL('SELECT COUNT(*) FROM {}').format(sql.Identifier(records._table)))\n                model.count = cr.fetchone()[0]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_model_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_model_name(self):\n        for model in self:\n            if model.state == 'manual':\n                self._check_manual_name(model.model)\n            if not models.check_object_name(model.model):\n                raise ValidationError(_(\"The model name can only contain lowercase characters, digits, underscores and dots.\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_order",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_order(self):\n        for model in self:\n            try:\n                model._check_qorder(model.order)  # regex check for the whole clause ('is it valid sql?')\n            except UserError as e:\n                raise ValidationError(str(e))\n            # add MAGIC_COLUMNS to 'stored_fields' in case 'model' has not been\n            # initialized yet, or 'field_id' is not up-to-date in cache\n            stored_fields = set(\n                model.field_id.filtered('store').mapped('name') + models.MAGIC_COLUMNS\n            )\n            if model.model in self.env:\n                # add fields inherited from models specified via code if they are already loaded\n                stored_fields.update(\n                    fname\n                    for fname, fval in self.env[model.model]._fields.items()\n                    if fval.inherited and fval.base_field.store\n                )\n\n            order_fields = RE_ORDER_FIELDS.findall(model.order)\n            for field in order_fields:\n                if field not in stored_fields:\n                    raise ValidationError(_(\"Unable to order by %s: fields used for ordering must be present on the model and stored.\", field))\n\n    _sql_constraints = [\n        ('obj_name_uniq', 'unique (model)', 'Each model must have a unique name.'),\n    ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def _get(self, name):\n        \"\"\" Return the (sudoed) `ir.model` record with the given name.\n        The result may be an empty recordset if the model is not found.\n        \"\"\"\n        model_id = self._get_id(name) if name else False\n        return self.sudo().browse(model_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_id",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def _get_id(self, name):\n        self.env.cr.execute(\"SELECT id FROM ir_model WHERE model=%s\", (name,))\n        result = self.env.cr.fetchone()\n        return result and result[0]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_drop_table",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _drop_table(self):\n        for model in self:\n            current_model = self.env.get(model.model)\n            if current_model is not None:\n                if current_model._abstract:\n                    continue\n\n                table = current_model._table\n                kind = tools.table_kind(self._cr, table)\n                if kind == tools.TableKind.View:\n                    self._cr.execute(sql.SQL('DROP VIEW {}').format(sql.Identifier(table)))\n                elif kind == tools.TableKind.Regular:\n                    self._cr.execute(sql.SQL('DROP TABLE {} CASCADE').format(sql.Identifier(table)))\n                elif kind is not None:\n                    _logger.warning(\n                        \"Unable to drop table %r of model %r: unmanaged or unknown tabe type %r\",\n                        table, model.model, kind\n                    )\n            else:\n                _logger.runbot('The model %s could not be dropped because it did not exist in the registry.', model.model)\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_if_manual",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_if_manual(self):\n        # Prevent manual deletion of module tables\n        for model in self:\n            if model.state != 'manual':\n                raise UserError(_(\"Model %r contains module data and cannot be removed.\", model.name))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        # prevent screwing up fields that depend on these models' fields\n        manual_models = self.filtered(lambda model: model.state == 'manual')\n        manual_models.field_id.filtered(lambda f: f.state == 'manual')._prepare_update()\n        (self - manual_models).field_id._prepare_update()\n\n        # delete fields whose comodel is being removed\n        self.env['ir.model.fields'].search([('relation', 'in', self.mapped('model'))]).unlink()\n\n        # delete ir_crons created by user\n        crons = self.env['ir.cron'].with_context(active_test=False).search([('model_id', 'in', self.ids)])\n        if crons:\n            crons.unlink()\n\n        self._drop_table()\n        res = super(IrModel, self).unlink()\n\n        # Reload registry for normal unlink only. For module uninstall, the\n        # reload is done independently in odoo.modules.loading.\n        if not self._context.get(MODULE_UNINSTALL_FLAG):\n            # setup models; this automatically removes model from registry\n            self.env.flush_all()\n            self.pool.setup_models(self._cr)\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if 'model' in vals and any(rec.model != vals['model'] for rec in self):\n            raise UserError(_('Field \"Model\" cannot be modified on models.'))\n        if 'state' in vals and any(rec.state != vals['state'] for rec in self):\n            raise UserError(_('Field \"Type\" cannot be modified on models.'))\n        if 'transient' in vals and any(rec.transient != vals['transient'] for rec in self):\n            raise UserError(_('Field \"Transient Model\" cannot be modified on models.'))\n        # Filter out operations 4 from field id, because the web client always\n        # writes (4,id,False) even for non dirty items.\n        if 'field_id' in vals:\n            vals['field_id'] = [op for op in vals['field_id'] if op[0] != 4]\n        res = super(IrModel, self).write(vals)\n        # ordering has been changed, reload registry to reflect update + signaling\n        if 'order' in vals:\n            self.env.flush_all()  # setup_models need to fetch the updated values from the db\n            self.pool.setup_models(self._cr)\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        res = super(IrModel, self).create(vals_list)\n        manual_models = [\n            vals['model'] for vals in vals_list if vals.get('state', 'manual') == 'manual'\n        ]\n        if manual_models:\n            # setup models; this automatically adds model in registry\n            self.env.flush_all()\n            self.pool.setup_models(self._cr)\n            # update database schema\n            self.pool.init_models(self._cr, manual_models, dict(self._context, update_custom_fields=True))\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "name_create",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def name_create(self, name):\n        \"\"\" Infer the model from the name. E.g.: 'My New Model' should become 'x_my_new_model'. \"\"\"\n        ir_model = self.create({\n            'name': name,\n            'model': 'x_' + '_'.join(name.lower().split(' ')),\n        })\n        return ir_model.id, ir_model.display_name",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_model_params",
          "params": [
            "self",
            "model"
          ],
          "decorators": [],
          "source": "def _reflect_model_params(self, model):\n        \"\"\" Return the values to write to the database for the given model. \"\"\"\n        return {\n            'model': model._name,\n            'name': model._description,\n            'order': model._order,\n            'info': next(cls.__doc__ for cls in self.env.registry[model._name].mro() if cls.__doc__),\n            'state': 'manual' if model._custom else 'base',\n            'transient': model._transient,\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_models",
          "params": [
            "self",
            "model_names"
          ],
          "decorators": [],
          "source": "def _reflect_models(self, model_names):\n        \"\"\" Reflect the given models. \"\"\"\n        # determine expected and existing rows\n        rows = [\n            self._reflect_model_params(self.env[model_name])\n            for model_name in model_names\n        ]\n        cols = list(unique(['model'] + list(rows[0])))\n        expected = [tuple(row[col] for col in cols) for row in rows]\n\n        model_ids = {}\n        existing = {}\n        for row in select_en(self, ['id'] + cols, \"model IN %s\", [tuple(model_names)]):\n            model_ids[row[1]] = row[0]\n            existing[row[1]] = row[1:]\n\n        # create or update rows\n        rows = [row for row in expected if existing.get(row[0]) != row]\n        if rows:\n            ids = upsert_en(self, cols, rows, ['model'])\n            for row, id_ in zip(rows, ids):\n                model_ids[row[0]] = id_\n            self.pool.post_init(mark_modified, self.browse(ids), cols[1:])\n\n        # update their XML id\n        module = self._context.get('module')\n        if not module:\n            return\n\n        data_list = []\n        for model_name, model_id in model_ids.items():\n            model = self.env[model_name]\n            if model._module == module:\n                # model._module is the name of the module that last extended model\n                xml_id = model_xmlid(module, model_name)\n                record = self.browse(model_id)\n                data_list.append({'xml_id': xml_id, 'record': record})\n        self.env['ir.model.data']._update_xmlids(data_list)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_instanciate",
          "params": [
            "self",
            "model_data"
          ],
          "decorators": [],
          "source": "def _instanciate(self, model_data):\n        \"\"\" Return a class for the custom model given by parameters ``model_data``. \"\"\"\n        models.check_pg_name(model_data[\"model\"].replace(\".\", \"_\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "obj_name_uniq",
          "definition": "unique (model)",
          "message": "Each model must have a unique name."
        },
        {
          "type": "python",
          "name": "_check_model_name",
          "definition": "@api.constrains('model')\n    def _check_model_name(self):\n        for model in self:\n            if model.state == 'manual':\n                self._check_manual_name(model.model)\n            if not models.check_object_name(model.model):\n                raise ValidationError(_(\"The model name can only contain lowercase characters, digits, underscores and dots.\"))",
          "message": "'model'"
        },
        {
          "type": "python",
          "name": "_check_order",
          "definition": "@api.constrains('order', 'field_id')\n    def _check_order(self):\n        for model in self:\n            try:\n                model._check_qorder(model.order)  # regex check for the whole clause ('is it valid sql?')\n            except UserError as e:\n                raise ValidationError(str(e))\n            # add MAGIC_COLUMNS to 'stored_fields' in case 'model' has not been\n            # initialized yet, or 'field_id' is not up-to-date in cache\n            stored_fields = set(\n                model.field_id.filtered('store').mapped('name') + models.MAGIC_COLUMNS\n            )\n            if model.model in self.env:\n                # add fields inherited from models specified via code if they are already loaded\n                stored_fields.update(\n                    fname\n                    for fname, fval in self.env[model.model]._fields.items()\n                    if fval.inherited and fval.base_field.store\n                )\n\n            order_fields = RE_ORDER_FIELDS.findall(model.order)\n            for field in order_fields:\n                if field not in stored_fields:\n                    raise ValidationError(_(\"Unable to order by %s: fields used for ordering must be present on the model and stored.\", field))\n\n    _sql_constraints = [\n        ('obj_name_uniq', 'unique (model)', 'Each model must have a unique name.'),\n    ]",
          "message": "'order', 'field_id'"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "name_create (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_instanciate (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrModel"
    },
    {
      "name": "custommodel",
      "description": "",
      "fields": [],
      "methods": [
        {
          "name": "_is_manual_name",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def _is_manual_name(self, name):\n        return name.startswith('x_')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_manual_name",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def _check_manual_name(self, name):\n        if not self._is_manual_name(name):\n            raise ValidationError(_(\"The model name must start with 'x_'.\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_add_manual_models",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _add_manual_models(self):\n        \"\"\" Add extra models to the registry. \"\"\"\n        # clean up registry first\n        for name, Model in list(self.pool.items()):\n            if Model._custom:\n                del self.pool.models[name]\n                # remove the model's name from its parents' _inherit_children\n                for Parent in Model.__bases__:\n                    if hasattr(Parent, 'pool'):\n                        Parent._inherit_children.discard(name)\n        # add manual models\n        cr = self.env.cr\n        # we cannot use self._fields to determine translated fields, as it has not been set up yet\n        cr.execute(\"SELECT *, name->>'en_US' AS name FROM ir_model WHERE state = 'manual'\")\n        for model_data in cr.dictfetchall():\n            model_class = self._instanciate(model_data)\n            Model = model_class._build_model(self.pool, cr)\n            kind = tools.table_kind(cr, Model._table)\n            if kind not in (tools.TableKind.Regular, None):\n                _logger.info(\n                    \"Model %r is backed by table %r which is not a regular table (%r), disabling automatic schema management\",\n                    Model._name, Model._table, kind,\n                )\n                Model._auto = False\n                cr.execute(\n                    '''\n                    SELECT a.attname\n                      FROM pg_attribute a\n                      JOIN pg_class t\n                        ON a.attrelid = t.oid\n                       AND t.relname = %s\n                     WHERE a.attnum > 0 -- skip system columns\n                    ''',\n                    [Model._table]\n                )\n                columns = {colinfo[0] for colinfo in cr.fetchall()}\n                Model._log_access = set(models.LOG_ACCESS_COLUMNS) <= columns\n\n\n# retrieve field types defined by the framework only (not extensions)\nFIELD_TYPES = [(key, key) for key in sorted(fields.Field.by_type)]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_is_manual_name (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_check_manual_name (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "CustomModel"
    },
    {
      "name": "ir.model.fields",
      "description": "Fields",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Field Name"
        },
        {
          "name": "complete_name",
          "type": "Char"
        },
        {
          "name": "model",
          "type": "Char",
          "required": true,
          "string": "Model Name",
          "help": "The technical name of the model this field belongs to"
        },
        {
          "name": "relation",
          "type": "Char",
          "string": "Related Model",
          "help": "For relationship fields, the technical name of the target model"
        },
        {
          "name": "relation_field",
          "type": "Char",
          "help": "For one2many fields, the field on the target model that implement the opposite many2one relationship"
        },
        {
          "name": "relation_field_id",
          "type": "Many2one",
          "relation": "ir.model.fields",
          "string": "Relation field"
        },
        {
          "name": "model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true,
          "string": "Model",
          "help": "The model this field belongs to"
        },
        {
          "name": "field_description",
          "type": "Char",
          "required": true,
          "string": "Field Label"
        },
        {
          "name": "help",
          "type": "Text",
          "string": "Field Help"
        },
        {
          "name": "ttype",
          "type": "Selection",
          "required": true,
          "string": "Field Type"
        },
        {
          "name": "selection",
          "type": "Char"
        },
        {
          "name": "selection_ids",
          "type": "One2many",
          "relation": "ir.model.fields.selection",
          "string": "Selection Options"
        },
        {
          "name": "copied",
          "type": "Boolean",
          "string": "Copied",
          "help": "Whether the value is copied when duplicating a record."
        },
        {
          "name": "related",
          "type": "Char",
          "string": "Related Field",
          "help": "The corresponding related field, if any. This must be a dot-separated list of field names."
        },
        {
          "name": "related_field_id",
          "type": "Many2one",
          "relation": "ir.model.fields",
          "string": "Related field"
        },
        {
          "name": "required",
          "type": "Boolean"
        },
        {
          "name": "readonly",
          "type": "Boolean"
        },
        {
          "name": "index",
          "type": "Boolean",
          "string": "Indexed"
        },
        {
          "name": "translate",
          "type": "Boolean",
          "string": "Translatable"
        },
        {
          "name": "size",
          "type": "Integer"
        },
        {
          "name": "state",
          "type": "Selection"
        },
        {
          "name": "on_delete",
          "type": "Selection"
        },
        {
          "name": "domain",
          "type": "Char",
          "help": "The optional domain to restrict possible values for relationship fields, "
        },
        {
          "name": "groups",
          "type": "Many2many",
          "relation": "res.groups"
        },
        {
          "name": "group_expand",
          "type": "Boolean",
          "string": "Expand Groups",
          "help": "If checked, all the records of the target model will be included\\n"
        },
        {
          "name": "selectable",
          "type": "Boolean"
        },
        {
          "name": "modules",
          "type": "Char",
          "string": "In Apps",
          "help": "List of modules in which the field is defined"
        },
        {
          "name": "relation_table",
          "type": "Char",
          "help": "Used for custom many2many fields to define a custom relation table name"
        },
        {
          "name": "column1",
          "type": "Char",
          "string": "Column 1",
          "help": "Column referring to the record in the model table"
        },
        {
          "name": "column2",
          "type": "Char",
          "string": "Column 2",
          "help": "Column referring to the record in the comodel table"
        },
        {
          "name": "compute",
          "type": "Text",
          "help": "Code to compute the value of the field.\\n"
        },
        {
          "name": "depends",
          "type": "Char",
          "string": "Dependencies",
          "help": "Dependencies of compute method; "
        },
        {
          "name": "store",
          "type": "Boolean",
          "string": "Stored",
          "help": "Whether the value is stored in the database."
        },
        {
          "name": "currency_field",
          "type": "Char",
          "string": "Currency field",
          "help": "Name of the Many2one field holding the res.currency"
        },
        {
          "name": "sanitize",
          "type": "Boolean",
          "string": "Sanitize HTML"
        },
        {
          "name": "sanitize_overridable",
          "type": "Boolean",
          "string": "Sanitize HTML overridable"
        },
        {
          "name": "sanitize_tags",
          "type": "Boolean",
          "string": "Sanitize HTML Tags"
        },
        {
          "name": "sanitize_attributes",
          "type": "Boolean",
          "string": "Sanitize HTML Attributes"
        },
        {
          "name": "sanitize_style",
          "type": "Boolean",
          "string": "Sanitize HTML Style"
        },
        {
          "name": "sanitize_form",
          "type": "Boolean",
          "string": "Sanitize HTML Form"
        },
        {
          "name": "strip_style",
          "type": "Boolean",
          "string": "Strip Style Attribute"
        },
        {
          "name": "strip_classes",
          "type": "Boolean",
          "string": "Strip Class Attribute"
        }
      ],
      "methods": [
        {
          "name": "_compute_relation_field_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_relation_field_id(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.relation_field:\n                rec.relation_field_id = self._get(rec.relation, rec.relation_field)\n            else:\n                rec.relation_field_id = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_related_field_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_related_field_id(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.related:\n                rec.related_field_id = rec._related_field()\n            else:\n                rec.related_field_id = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_selection",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_selection(self):\n        for rec in self:\n            if rec.ttype in ('selection', 'reference'):\n                rec.selection = str(self.env['ir.model.fields.selection']._get_selection(rec.id))\n            else:\n                rec.selection = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_selection",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_selection(self):\n        for rec in self:\n            selection = literal_eval(rec.selection or \"[]\")\n            self.env['ir.model.fields.selection']._update_selection(rec.model, rec.name, selection)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_copied",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_copied(self):\n        for rec in self:\n            rec.copied = (rec.ttype != 'one2many') and not (rec.related or rec.compute)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_in_modules",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _in_modules(self):\n        installed_modules = self.env['ir.module.module'].search([('state', '=', 'installed')])\n        installed_names = set(installed_modules.mapped('name'))\n        xml_ids = models.Model._get_external_ids(self)\n        for field in self:\n            module_names = set(xml_id.split('.')[0] for xml_id in xml_ids[field.id])\n            field.modules = \", \".join(sorted(installed_names & module_names))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_domain",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_domain(self):\n        for field in self:\n            safe_eval(field.domain or '[]')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_name(self):\n        for field in self:\n            try:\n                models.check_pg_name(field.name)\n            except ValidationError:\n                msg = _(\"Field names can only contain characters, digits and underscores (up to 63).\")\n                raise ValidationError(msg)\n\n    _sql_constraints = [\n        ('name_unique', 'UNIQUE(model, name)', \"Field names must be unique per model.\"),\n        ('size_gt_zero', 'CHECK (size>=0)', 'Size of the field cannot be negative.'),\n        (\n            \"name_manual_field\",\n            \"CHECK (state != 'manual' OR name LIKE 'x\\\\_%')\",\n            \"Custom fields must have a name that starts with 'x_'!\"\n        ),\n    ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_related_field",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _related_field(self):\n        \"\"\" Return the ``ir.model.fields`` record corresponding to ``self.related``. \"\"\"\n        names = self.related.split(\".\")\n        last = len(names) - 1\n        model_name = self.model or self.model_id.model\n        for index, name in enumerate(names):\n            field = self._get(model_name, name)\n            if not field:\n                raise UserError(_(\"Unknown field name %r in related field %r\", name, self.related))\n            model_name = field.relation\n            if index < last and not field.relation:\n                raise UserError(_(\"Non-relational field name %r in related field %r\", name, self.related))\n        return field",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_related",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_related(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.related:\n                field = rec._related_field()\n                if field.ttype != rec.ttype:\n                    raise ValidationError(_(\"Related field %r does not have type %r\", rec.related, rec.ttype))\n                if field.relation != rec.relation:\n                    raise ValidationError(_(\"Related field %r does not have comodel %r\", rec.related, rec.relation))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_related",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_related(self):\n        if self.related:\n            try:\n                field = self._related_field()\n            except UserError as e:\n                return {'warning': {'title': _(\"Warning\"), 'message': e}}\n            self.ttype = field.ttype\n            self.relation = field.relation\n            self.readonly = True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_relation",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_relation(self):\n        try:\n            self._check_relation()\n        except ValidationError as e:\n            return {'warning': {'title': _(\"Model %s does not exist\", self.relation), 'message': e}}",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_relation",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_relation(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.relation and not rec.env['ir.model']._get_id(rec.relation):\n                raise ValidationError(_(\"Unknown model name '%s' in Related Model\", rec.relation))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_depends",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_depends(self):\n        \"\"\" Check whether all fields in dependencies are valid. \"\"\"\n        for record in self:\n            if not record.depends:\n                continue\n            for seq in record.depends.split(\",\"):\n                if not seq.strip():\n                    raise UserError(_(\"Empty dependency in %r\", record.depends))\n                model = self.env[record.model]\n                names = seq.strip().split(\".\")\n                last = len(names) - 1\n                for index, name in enumerate(names):\n                    if name == 'id':\n                        raise UserError(_(\"Compute method cannot depend on field 'id'\"))\n                    field = model._fields.get(name)\n                    if field is None:\n                        raise UserError(_(\"Unknown field %r in dependency %r\", name, seq.strip()))\n                    if index < last and not field.relational:\n                        raise UserError(_(\"Non-relational field %r in dependency %r\", name, seq.strip()))\n                    model = model[name]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_compute",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_compute(self):\n        if self.compute:\n            self.readonly = True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_relation_table",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_relation_table(self):\n        for rec in self:\n            if rec.relation_table:\n                models.check_pg_name(rec.relation_table)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_currency_field",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_currency_field(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.ttype == 'monetary':\n                if not rec.currency_field:\n                    currency_field = self._get(rec.model, 'currency_id') or self._get(rec.model, 'x_currency_id')\n                    if not currency_field:\n                        raise ValidationError(_(\"Currency field is empty and there is no fallback field in the model\"))\n                else:\n                    currency_field = self._get(rec.model, rec.currency_field)\n                    if not currency_field:\n                        raise ValidationError(_(\"Unknown field name %r in currency_field\", rec.currency_field))\n\n                if currency_field.ttype != 'many2one':\n                    raise ValidationError(_(\"Currency field does not have type many2one\"))\n                if currency_field.relation != 'res.currency':\n                    raise ValidationError(_(\"Currency field should have a res.currency relation\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_custom_many2many_names",
          "params": [
            "self",
            "model_name",
            "comodel_name"
          ],
          "decorators": [],
          "source": "def _custom_many2many_names(self, model_name, comodel_name):\n        \"\"\" Return default names for the table and columns of a custom many2many field. \"\"\"\n        rel1 = self.env[model_name]._table\n        rel2 = self.env[comodel_name]._table\n        table = 'x_%s_%s_rel' % tuple(sorted([rel1, rel2]))\n        if rel1 == rel2:\n            return (table, 'id1', 'id2')\n        else:\n            return (table, '%s_id' % rel1, '%s_id' % rel2)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_ttype",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_ttype(self):\n        if self.ttype == 'many2many' and self.model_id and self.relation:\n            if self.relation not in self.env:\n                return\n            names = self._custom_many2many_names(self.model_id.model, self.relation)\n            self.relation_table, self.column1, self.column2 = names\n        else:\n            self.relation_table = False\n            self.column1 = False\n            self.column2 = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_relation_table",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_relation_table(self):\n        if self.relation_table:\n            # check whether other fields use the same table\n            others = self.search([('ttype', '=', 'many2many'),\n                                  ('relation_table', '=', self.relation_table),\n                                  ('id', 'not in', self.ids)])\n            if others:\n                for other in others:\n                    if (other.model, other.relation) == (self.relation, self.model):\n                        # other is a candidate inverse field\n                        self.column1 = other.column2\n                        self.column2 = other.column1\n                        return\n                return {'warning': {\n                    'title': _(\"Warning\"),\n                    'message': _(\"The table %r if used for other, possibly incompatible fields.\", self.relation_table),\n                }}",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_on_delete_required_m2o",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_on_delete_required_m2o(self):\n        for rec in self:\n            if rec.ttype == 'many2one' and rec.required and rec.on_delete == 'set null':\n                raise ValidationError(_(\n                    \"The m2o field %s is required but declares its ondelete policy \"\n                    \"as being 'set null'. Only 'restrict' and 'cascade' make sense.\", rec.name,\n                ))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get",
          "params": [
            "self",
            "model_name",
            "name"
          ],
          "decorators": [],
          "source": "def _get(self, model_name, name):\n        \"\"\" Return the (sudoed) `ir.model.fields` record with the given model and name.\n        The result may be an empty recordset if the model is not found.\n        \"\"\"\n        field_id = model_name and name and self._get_ids(model_name).get(name)\n        return self.sudo().browse(field_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_ids",
          "params": [
            "self",
            "model_name"
          ],
          "decorators": [],
          "source": "def _get_ids(self, model_name):\n        cr = self.env.cr\n        cr.execute(\"SELECT name, id FROM ir_model_fields WHERE model=%s\", [model_name])\n        return dict(cr.fetchall())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_drop_column",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _drop_column(self):\n        tables_to_drop = set()\n\n        for field in self:\n            if field.name in models.MAGIC_COLUMNS:\n                continue\n            model = self.env.get(field.model)\n            is_model = model is not None\n            if field.store:\n                # TODO: Refactor this brol in master\n                if is_model and tools.column_exists(self._cr, model._table, field.name) and \\\n                        tools.table_kind(self._cr, model._table) == tools.TableKind.Regular:\n                    self._cr.execute(sql.SQL('ALTER TABLE {} DROP COLUMN {} CASCADE').format(\n                        sql.Identifier(model._table), sql.Identifier(field.name),\n                    ))\n                if field.state == 'manual' and field.ttype == 'many2many':\n                    rel_name = field.relation_table or (is_model and model._fields[field.name].relation)\n                    tables_to_drop.add(rel_name)\n            if field.state == 'manual' and is_model:\n                model._pop_field(field.name)\n\n        if tables_to_drop:\n            # drop the relation tables that are not used by other fields\n            self._cr.execute(\"\"\"SELECT relation_table FROM ir_model_fields\n                                WHERE relation_table IN %s AND id NOT IN %s\"\"\",\n                             (tuple(tables_to_drop), tuple(self.ids)))\n            tables_to_keep = set(row[0] for row in self._cr.fetchall())\n            for rel_name in tables_to_drop - tables_to_keep:\n                self._cr.execute(sql.SQL('DROP TABLE {}').format(sql.Identifier(rel_name)))\n\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_prepare_update",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _prepare_update(self):\n        \"\"\" Check whether the fields in ``self`` may be modified or removed.\n            This method prevents the modification/deletion of many2one fields\n            that have an inverse one2many, for instance.\n        \"\"\"\n        uninstalling = self._context.get(MODULE_UNINSTALL_FLAG)\n        if not uninstalling and any(record.state != 'manual' for record in self):\n            raise UserError(_(\"This column contains module data and cannot be removed!\"))\n\n        records = self              # all the records to delete\n        fields_ = OrderedSet()      # all the fields corresponding to 'records'\n        failed_dependencies = []    # list of broken (field, dependent_field)\n\n        for record in self:\n            model = self.env.get(record.model)\n            if model is None:\n                continue\n            field = model._fields.get(record.name)\n            if field is None:\n                continue\n            fields_.add(field)\n            for dep in self.pool.get_dependent_fields(field):\n                if dep.manual:\n                    failed_dependencies.append((field, dep))\n                elif dep.inherited:\n                    fields_.add(dep)\n                    records |= self._get(dep.model_name, dep.name)\n\n        for field in fields_:\n            for inverse in model.pool.field_inverses[field]:\n                if inverse.manual and inverse.type == 'one2many':\n                    failed_dependencies.append((field, inverse))\n\n        self = records\n\n        if failed_dependencies:\n            if not uninstalling:\n                field, dep = failed_dependencies[0]\n                raise UserError(_(\n                    \"The field '%s' cannot be removed because the field '%s' depends on it.\",\n                    field, dep,\n                ))\n            else:\n                self = self.union(*[\n                    self._get(dep.model_name, dep.name)\n                    for field, dep in failed_dependencies\n                ])\n\n        records = self.filtered(lambda record: record.state == 'manual')\n        if not records:\n            return self\n\n        # remove pending write of this field\n        # DLE P16: if there are pending updates of the field we currently try to unlink, pop them out from the cache\n        # test `test_unlink_with_dependant`\n        for record in records:\n            model = self.env.get(record.model)\n            field = model and model._fields.get(record.name)\n            if field:\n                self.env.cache.clear_dirty_field(field)\n        # remove fields from registry, and check that views are not broken\n        fields = [self.env[record.model]._pop_field(record.name) for record in records]\n        domain = expression.OR([('arch_db', 'like', record.name)] for record in records)\n        views = self.env['ir.ui.view'].search(domain)\n        try:\n            for view in views:\n                view._check_xml()\n        except Exception:\n            if not uninstalling:\n                raise UserError(_(\n                    \"Cannot rename/delete fields that are still present in views:\\nFields: %s\\nView: %s\",\n                    \", \".join(str(f) for f in fields),\n                    view.name,\n                ))\n            else:\n                # uninstall mode\n                _logger.warning(\n                    \"The following fields were force-deleted to prevent a registry crash %s the following view might be broken %s\",\n                    \", \".join(str(f) for f in fields),\n                    view.name)\n        finally:\n            if not uninstalling:\n                # the registry has been modified, restore it\n                self.pool.setup_models(self._cr)\n\n        return self",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        if not self:\n            return True\n\n        # prevent screwing up fields that depend on these fields\n        self = self._prepare_update()\n\n        # determine registry fields corresponding to self\n        fields = OrderedSet()\n        for record in self:\n            try:\n                fields.add(self.pool[record.model]._fields[record.name])\n            except KeyError:\n                pass\n\n        # clean the registry from the fields to remove\n        self.pool.registry_invalidated = True\n        self.pool._discard_fields(fields)\n\n        # discard the removed fields from fields to compute\n        for field in fields:\n            self.env.all.tocompute.pop(field, None)\n\n        model_names = self.mapped('model')\n        self._drop_column()\n        res = super(IrModelFields, self).unlink()\n\n        # The field we just deleted might be inherited, and the registry is\n        # inconsistent in this case; therefore we reload the registry.\n        if not self._context.get(MODULE_UNINSTALL_FLAG):\n            # setup models; this re-initializes models in registry\n            self.env.flush_all()\n            self.pool.setup_models(self._cr)\n            # update database schema of model and its descendant models\n            models = self.pool.descendants(model_names, '_inherits')\n            self.pool.init_models(self._cr, models, dict(self._context, update_custom_fields=True))\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        IrModel = self.env['ir.model']\n        models = set()\n        for vals in vals_list:\n            if 'model_id' in vals:\n                vals['model'] = IrModel.browse(vals['model_id']).model\n\n        # for self._get_ids() in _update_selection()\n        self.env.registry.clear_cache()\n\n        res = super(IrModelFields, self).create(vals_list)\n        models = set(res.mapped('model'))\n\n        for vals in vals_list:\n            if vals.get('state', 'manual') == 'manual':\n                relation = vals.get('relation')\n                if relation and not IrModel._get_id(relation):\n                    raise UserError(_(\"Model %s does not exist!\", vals['relation']))\n\n                if vals.get('ttype') == 'one2many' and not self.search_count([\n                    ('ttype', '=', 'many2one'),\n                    ('model', '=', vals['relation']),\n                    ('name', '=', vals['relation_field']),\n                ]):\n                    raise UserError(_(\"Many2one %s on model %s does not exist!\", vals['relation_field'], vals['relation']))\n\n        if any(model in self.pool for model in models):\n            # setup models; this re-initializes model in registry\n            self.env.flush_all()\n            self.pool.setup_models(self._cr)\n            # update database schema of models and their descendants\n            models = self.pool.descendants(models, '_inherits')\n            self.pool.init_models(self._cr, models, dict(self._context, update_custom_fields=True))\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if not self:\n            return True\n\n        # if set, *one* column can be renamed here\n        column_rename = None\n\n        # names of the models to patch\n        patched_models = set()\n        translate_only = all(self._fields[field_name].translate for field_name in vals)\n        if vals and self and not translate_only:\n            for item in self:\n                if item.state != 'manual':\n                    raise UserError(_('Properties of base fields cannot be altered in this manner! '\n                                      'Please modify them through Python code, '\n                                      'preferably through a custom addon!'))\n\n                if vals.get('model_id', item.model_id.id) != item.model_id.id:\n                    raise UserError(_(\"Changing the model of a field is forbidden!\"))\n\n                if vals.get('ttype', item.ttype) != item.ttype:\n                    raise UserError(_(\"Changing the type of a field is not yet supported. \"\n                                      \"Please drop it and create it again!\"))\n\n                obj = self.pool.get(item.model)\n                field = getattr(obj, '_fields', {}).get(item.name)\n\n                if vals.get('name', item.name) != item.name:\n                    # We need to rename the field\n                    item._prepare_update()\n                    if item.ttype in ('one2many', 'many2many', 'binary'):\n                        # those field names are not explicit in the database!\n                        pass\n                    else:\n                        if column_rename:\n                            raise UserError(_('Can only rename one field at a time!'))\n                        column_rename = (obj._table, item.name, vals['name'], item.index, item.store)\n\n                # We don't check the 'state', because it might come from the context\n                # (thus be set for multiple fields) and will be ignored anyway.\n                if obj is not None and field is not None:\n                    patched_models.add(obj._name)\n\n        # These shall never be written (modified)\n        for column_name in ('model_id', 'model', 'state'):\n            if column_name in vals:\n                del vals[column_name]\n\n        res = super(IrModelFields, self).write(vals)\n\n        self.env.flush_all()\n\n        if column_rename:\n            # rename column in database, and its corresponding index if present\n            table, oldname, newname, index, stored = column_rename\n            if stored:\n                self._cr.execute(\n                    sql.SQL('ALTER TABLE {} RENAME COLUMN {} TO {}').format(\n                        sql.Identifier(table),\n                        sql.Identifier(oldname),\n                        sql.Identifier(newname)\n                    ))\n                if index:\n                    self._cr.execute(\n                        sql.SQL('ALTER INDEX {} RENAME TO {}').format(\n                            sql.Identifier(f'{table}_{oldname}_index'),\n                            sql.Identifier(f'{table}_{newname}_index'),\n                        ))\n\n        if column_rename or patched_models or translate_only:\n            # setup models, this will reload all manual fields in registry\n            self.env.flush_all()\n            self.pool.setup_models(self._cr)\n\n        if patched_models:\n            # update the database schema of the models to patch\n            models = self.pool.descendants(patched_models, '_inherits')\n            self.pool.init_models(self._cr, models, dict(self._context, update_custom_fields=True))\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        IrModel = self.env[\"ir.model\"]\n        for field in self:\n            if self.env.context.get('hide_model'):\n                field.display_name = field.field_description\n                continue\n            model_string = IrModel._get(field.model).name\n            field.display_name = f'{field.field_description} ({model_string})'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_field_params",
          "params": [
            "self",
            "field",
            "model_id"
          ],
          "decorators": [],
          "source": "def _reflect_field_params(self, field, model_id):\n        \"\"\" Return the values to write to the database for the given field. \"\"\"\n        return {\n            'model_id': model_id,\n            'model': field.model_name,\n            'name': field.name,\n            'field_description': field.string,\n            'help': field.help or None,\n            'ttype': field.type,\n            'state': 'manual' if field.manual else 'base',\n            'relation': field.comodel_name or None,\n            'index': bool(field.index),\n            'store': bool(field.store),\n            'copied': bool(field.copy),\n            'on_delete': field.ondelete if field.type == 'many2one' else None,\n            'related': field.related or None,\n            'readonly': bool(field.readonly),\n            'required': bool(field.required),\n            'selectable': bool(field.search or field.store),\n            'size': getattr(field, 'size', None),\n            'translate': bool(field.translate),\n            'relation_field': field.inverse_name if field.type == 'one2many' else None,\n            'relation_table': field.relation if field.type == 'many2many' else None,\n            'column1': field.column1 if field.type == 'many2many' else None,\n            'column2': field.column2 if field.type == 'many2many' else None,\n            'currency_field': field.currency_field if field.type == 'monetary' else None,\n            # html sanitization attributes (useless for other fields)\n            'sanitize': field.sanitize if field.type == 'html' else None,\n            'sanitize_overridable': field.sanitize_overridable if field.type == 'html' else None,\n            'sanitize_tags': field.sanitize_tags if field.type == 'html' else None,\n            'sanitize_attributes': field.sanitize_attributes if field.type == 'html' else None,\n            'sanitize_style': field.sanitize_style if field.type == 'html' else None,\n            'sanitize_form': field.sanitize_form if field.type == 'html' else None,\n            'strip_style': field.strip_style if field.type == 'html' else None,\n            'strip_classes': field.strip_classes if field.type == 'html' else None,\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_fields",
          "params": [
            "self",
            "model_names"
          ],
          "decorators": [],
          "source": "def _reflect_fields(self, model_names):\n        \"\"\" Reflect the fields of the given models. \"\"\"\n        cr = self.env.cr\n\n        for model_name in model_names:\n            model = self.env[model_name]\n            by_label = {}\n            for field in model._fields.values():\n                if field.string in by_label:\n                    other = by_label[field.string]\n                    _logger.warning('Two fields (%s, %s) of %s have the same label: %s. [Modules: %s and %s]',\n                                    field.name, other.name, model, field.string, field._module, other._module)\n                else:\n                    by_label[field.string] = field\n\n        # determine expected and existing rows\n        rows = []\n        for model_name in model_names:\n            model_id = self.env['ir.model']._get_id(model_name)\n            for field in self.env[model_name]._fields.values():\n                rows.append(self._reflect_field_params(field, model_id))\n        if not rows:\n            return\n        cols = list(unique(['model', 'name'] + list(rows[0])))\n        expected = [tuple(row[col] for col in cols) for row in rows]\n\n        field_ids = {}\n        existing = {}\n        for row in select_en(self, ['id'] + cols, \"model IN %s\", [tuple(model_names)]):\n            field_ids[row[1:3]] = row[0]\n            existing[row[1:3]] = row[1:]\n\n        # create or update rows\n        rows = [row for row in expected if existing.get(row[:2]) != row]\n        if rows:\n            ids = upsert_en(self, cols, rows, ['model', 'name'])\n            for row, id_ in zip(rows, ids):\n                field_ids[row[:2]] = id_\n            self.pool.post_init(mark_modified, self.browse(ids), cols[2:])\n\n        # update their XML id\n        module = self._context.get('module')\n        if not module:\n            return\n\n        data_list = []\n        for (field_model, field_name), field_id in field_ids.items():\n            model = self.env[field_model]\n            field = model._fields.get(field_name)\n            if field and (\n                module == model._original_module\n                or module in field._modules\n                or any(\n                    # module introduced field on model by inheritance\n                    field_name in self.env[parent]._fields\n                    for parent, parent_module in model._inherit_module.items()\n                    if module == parent_module\n                )\n            ):\n                xml_id = field_xmlid(module, field_model, field_name)\n                record = self.browse(field_id)\n                data_list.append({'xml_id': xml_id, 'record': record})\n        self.env['ir.model.data']._update_xmlids(data_list)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_all_manual_field_data",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _all_manual_field_data(self):\n        cr = self._cr\n        # we cannot use self._fields to determine translated fields, as it has not been set up yet\n        cr.execute(\"\"\"\n            SELECT *, field_description->>'en_US' AS field_description, help->>'en_US' AS help\n            FROM ir_model_fields\n            WHERE state = 'manual'\n        \"\"\")\n        result = defaultdict(dict)\n        for row in cr.dictfetchall():\n            result[row['model']][row['name']] = row\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_manual_field_data",
          "params": [
            "self",
            "model_name"
          ],
          "decorators": [],
          "source": "def _get_manual_field_data(self, model_name):\n        \"\"\" Return the given model's manual field data. \"\"\"\n        return self._all_manual_field_data().get(model_name, {})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_instanciate_attrs",
          "params": [
            "self",
            "field_data"
          ],
          "decorators": [],
          "source": "def _instanciate_attrs(self, field_data):\n        \"\"\" Return the parameters for a field instance for ``field_data``. \"\"\"\n        attrs = {\n            'manual': True,\n            'string': field_data['field_description'],\n            'help': field_data['help'],\n            'index': bool(field_data['index']),\n            'copy': bool(field_data['copied']),\n            'related': field_data['related'],\n            'required': bool(field_data['required']),\n            'readonly': bool(field_data['readonly']),\n            'store': bool(field_data['store']),\n        }\n        if field_data['ttype'] in ('char', 'text', 'html'):\n            attrs['translate'] = bool(field_data['translate'])\n            if field_data['ttype'] == 'char':\n                attrs['size'] = field_data['size'] or None\n            elif field_data['ttype'] == 'html':\n                attrs['sanitize'] = field_data['sanitize']\n                attrs['sanitize_overridable'] = field_data['sanitize_overridable']\n                attrs['sanitize_tags'] = field_data['sanitize_tags']\n                attrs['sanitize_attributes'] = field_data['sanitize_attributes']\n                attrs['sanitize_style'] = field_data['sanitize_style']\n                attrs['sanitize_form'] = field_data['sanitize_form']\n                attrs['strip_style'] = field_data['strip_style']\n                attrs['strip_classes'] = field_data['strip_classes']\n        elif field_data['ttype'] in ('selection', 'reference'):\n            attrs['selection'] = self.env['ir.model.fields.selection']._get_selection_data(field_data['id'])\n            if field_data['ttype'] == 'selection':\n                attrs['group_expand'] = field_data['group_expand']\n        elif field_data['ttype'] == 'many2one':\n            if not self.pool.loaded and field_data['relation'] not in self.env:\n                return\n            attrs['comodel_name'] = field_data['relation']\n            attrs['ondelete'] = field_data['on_delete']\n            attrs['domain'] = safe_eval(field_data['domain'] or '[]')\n            attrs['group_expand'] = '_read_group_expand_full' if field_data['group_expand'] else None\n        elif field_data['ttype'] == 'one2many':\n            if not self.pool.loaded and not (\n                field_data['relation'] in self.env and (\n                    field_data['relation_field'] in self.env[field_data['relation']]._fields or\n                    field_data['relation_field'] in self._get_manual_field_data(field_data['relation'])\n            )):\n                return\n            attrs['comodel_name'] = field_data['relation']\n            attrs['inverse_name'] = field_data['relation_field']\n            attrs['domain'] = safe_eval(field_data['domain'] or '[]')\n        elif field_data['ttype'] == 'many2many':\n            if not self.pool.loaded and field_data['relation'] not in self.env:\n                return\n            attrs['comodel_name'] = field_data['relation']\n            rel, col1, col2 = self._custom_many2many_names(field_data['model'], field_data['relation'])\n            attrs['relation'] = field_data['relation_table'] or rel\n            attrs['column1'] = field_data['column1'] or col1\n            attrs['column2'] = field_data['column2'] or col2\n            attrs['domain'] = safe_eval(field_data['domain'] or '[]')\n        elif field_data['ttype'] == 'monetary':\n            # be sure that custom monetary field are always instanciated\n            if not self.pool.loaded and \\\n                field_data['currency_field'] and not self._is_manual_name(field_data['currency_field']):\n                return\n            attrs['currency_field'] = field_data['currency_field']\n        # add compute function if given\n        if field_data['compute']:\n            attrs['compute'] = make_compute(field_data['compute'], field_data['depends'])\n        return attrs",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_instanciate",
          "params": [
            "self",
            "field_data"
          ],
          "decorators": [],
          "source": "def _instanciate(self, field_data):\n        \"\"\" Return a field instance corresponding to parameters ``field_data``. \"\"\"\n        attrs = self._instanciate_attrs(field_data)\n        if attrs:\n            return fields.Field.by_type[field_data['ttype']](**attrs)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_manual_name",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def _is_manual_name(self, name):\n        return name.startswith('x_')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_add_manual_fields",
          "params": [
            "self",
            "model"
          ],
          "decorators": [],
          "source": "def _add_manual_fields(self, model):\n        \"\"\" Add extra fields on model. \"\"\"\n        fields_data = self._get_manual_field_data(model._name)\n        for name, field_data in fields_data.items():\n            if name not in model._fields and field_data['state'] == 'manual':\n                try:\n                    field = self._instanciate(field_data)\n                    if field:\n                        model._add_field(name, field)\n                except Exception:\n                    _logger.exception(\"Failed to load field %s.%s: skipped\", model._name, field_data['name'])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_field_string",
          "params": [
            "self",
            "model_name"
          ],
          "decorators": [],
          "source": "def get_field_string(self, model_name):\n        \"\"\" Return the translation of fields strings in the context's language.\n        Note that the result contains the available translations only.\n\n        :param model_name: the name of a model\n        :return: the model's fields' strings as a dictionary `{field_name: field_string}`\n        \"\"\"\n        fields = self.sudo().search([('model', '=', model_name)])\n        return {field.name: field.field_description for field in fields}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_field_help",
          "params": [
            "self",
            "model_name"
          ],
          "decorators": [],
          "source": "def get_field_help(self, model_name):\n        \"\"\" Return the translation of fields help in the context's language.\n        Note that the result contains the available translations only.\n\n        :param model_name: the name of a model\n        :return: the model's fields' help as a dictionary `{field_name: field_help}`\n        \"\"\"\n        fields = self.sudo().search([('model', '=', model_name)])\n        return {field.name: field.help for field in fields}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_field_selection",
          "params": [
            "self",
            "model_name",
            "field_name"
          ],
          "decorators": [],
          "source": "def get_field_selection(self, model_name, field_name):\n        \"\"\" Return the translation of a field's selection in the context's language.\n        Note that the result contains the available translations only.\n\n        :param model_name: the name of the field's model\n        :param field_name: the name of the field\n        :return: the fields' selection as a list\n        \"\"\"\n        field = self._get(model_name, field_name)\n        return [(sel.value, sel.name) for sel in field.selection_ids]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_unique",
          "definition": "UNIQUE(model, name)",
          "message": "Field names must be unique per model."
        },
        {
          "type": "sql",
          "name": "size_gt_zero",
          "definition": "CHECK (size>=0)",
          "message": "Size of the field cannot be negative."
        },
        {
          "type": "python",
          "name": "_check_domain",
          "definition": "@api.constrains('domain')\n    def _check_domain(self):\n        for field in self:\n            safe_eval(field.domain or '[]')",
          "message": "'domain'"
        },
        {
          "type": "python",
          "name": "_check_name",
          "definition": "@api.constrains('name')\n    def _check_name(self):\n        for field in self:\n            try:\n                models.check_pg_name(field.name)\n            except ValidationError:\n                msg = _(\"Field names can only contain characters, digits and underscores (up to 63).\")\n                raise ValidationError(msg)\n\n    _sql_constraints = [\n        ('name_unique', 'UNIQUE(model, name)', \"Field names must be unique per model.\"),\n        ('size_gt_zero', 'CHECK (size>=0)', 'Size of the field cannot be negative.'),\n        (\n            \"name_manual_field\",\n            \"CHECK (state != 'manual' OR name LIKE 'x\\\\_%')\",\n            \"Custom fields must have a name that starts with 'x_'!\"\n        ),\n    ]",
          "message": "'name'"
        },
        {
          "type": "python",
          "name": "_check_related",
          "definition": "@api.constrains('related')\n    def _check_related(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.related:\n                field = rec._related_field()\n                if field.ttype != rec.ttype:\n                    raise ValidationError(_(\"Related field %r does not have type %r\", rec.related, rec.ttype))\n                if field.relation != rec.relation:\n                    raise ValidationError(_(\"Related field %r does not have comodel %r\", rec.related, rec.relation))",
          "message": "'related'"
        },
        {
          "type": "python",
          "name": "_check_relation",
          "definition": "@api.constrains('relation')\n    def _check_relation(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.relation and not rec.env['ir.model']._get_id(rec.relation):\n                raise ValidationError(_(\"Unknown model name '%s' in Related Model\", rec.relation))",
          "message": "'relation'"
        },
        {
          "type": "python",
          "name": "_check_depends",
          "definition": "@api.constrains('depends')\n    def _check_depends(self):\n        \"\"\" Check whether all fields in dependencies are valid. \"\"\"\n        for record in self:\n            if not record.depends:\n                continue\n            for seq in record.depends.split(\",\"):\n                if not seq.strip():\n                    raise UserError(_(\"Empty dependency in %r\", record.depends))\n                model = self.env[record.model]\n                names = seq.strip().split(\".\")\n                last = len(names) - 1\n                for index, name in enumerate(names):\n                    if name == 'id':\n                        raise UserError(_(\"Compute method cannot depend on field 'id'\"))\n                    field = model._fields.get(name)\n                    if field is None:\n                        raise UserError(_(\"Unknown field %r in dependency %r\", name, seq.strip()))\n                    if index < last and not field.relational:\n                        raise UserError(_(\"Non-relational field %r in dependency %r\", name, seq.strip()))\n                    model = model[name]",
          "message": "'depends'"
        },
        {
          "type": "python",
          "name": "_check_relation_table",
          "definition": "@api.constrains('relation_table')\n    def _check_relation_table(self):\n        for rec in self:\n            if rec.relation_table:\n                models.check_pg_name(rec.relation_table)",
          "message": "'relation_table'"
        },
        {
          "type": "python",
          "name": "_check_currency_field",
          "definition": "@api.constrains('currency_field')\n    def _check_currency_field(self):\n        for rec in self:\n            if rec.state == 'manual' and rec.ttype == 'monetary':\n                if not rec.currency_field:\n                    currency_field = self._get(rec.model, 'currency_id') or self._get(rec.model, 'x_currency_id')\n                    if not currency_field:\n                        raise ValidationError(_(\"Currency field is empty and there is no fallback field in the model\"))\n                else:\n                    currency_field = self._get(rec.model, rec.currency_field)\n                    if not currency_field:\n                        raise ValidationError(_(\"Unknown field name %r in currency_field\", rec.currency_field))\n\n                if currency_field.ttype != 'many2one':\n                    raise ValidationError(_(\"Currency field does not have type many2one\"))\n                if currency_field.relation != 'res.currency':\n                    raise ValidationError(_(\"Currency field should have a res.currency relation\"))",
          "message": "'currency_field'"
        },
        {
          "type": "python",
          "name": "_check_on_delete_required_m2o",
          "definition": "@api.constrains('required', 'ttype', 'on_delete')\n    def _check_on_delete_required_m2o(self):\n        for rec in self:\n            if rec.ttype == 'many2one' and rec.required and rec.on_delete == 'set null':\n                raise ValidationError(_(\n                    \"The m2o field %s is required but declares its ondelete policy \"\n                    \"as being 'set null'. Only 'restrict' and 'cascade' make sense.\", rec.name,\n                ))",
          "message": "'required', 'ttype', 'on_delete'"
        }
      ],
      "accessRules": [
        {
          "name": "_custom_many2many_names (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_is_manual_name (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrModelFields"
    },
    {
      "name": "ir.model.inherit",
      "description": "Model Inheritance Tree",
      "fields": [
        {
          "name": "model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true
        },
        {
          "name": "parent_id",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true
        },
        {
          "name": "parent_field_id",
          "type": "Many2one",
          "relation": "ir.model.fields"
        }
      ],
      "methods": [
        {
          "name": "_reflect_inherits",
          "params": [
            "self",
            "model_names"
          ],
          "decorators": [],
          "source": "def _reflect_inherits(self, model_names):\n        \"\"\" Reflect the given models' inherits (_inherit and _inherits). \"\"\"\n        IrModel = self.env[\"ir.model\"]\n        get_model_id = IrModel._get_id\n\n        module_mapping = defaultdict(list)\n        for model_name in model_names:\n            get_field_id = self.env[\"ir.model.fields\"]._get_ids(model_name).get\n            model_id = get_model_id(model_name)\n            model = self.env[model_name]\n\n            for cls in reversed(type(model).mro()):\n                if not models.is_definition_class(cls):\n                    continue\n\n                items = [\n                    (model_id, get_model_id(parent_name), None)\n                    for parent_name in cls._inherit\n                    if parent_name not in (\"base\", model_name)\n                ] + [\n                    (model_id, get_model_id(parent_name), get_field_id(field))\n                    for parent_name, field in cls._inherits.items()\n                ]\n\n                for item in items:\n                    module_mapping[item].append(cls._module)\n\n        if not module_mapping:\n            return\n\n        cr = self.env.cr\n        cr.execute(\n            \"\"\"\n                SELECT i.id, i.model_id, i.parent_id, i.parent_field_id\n                  FROM ir_model_inherit i\n                  JOIN ir_model m\n                    ON m.id = i.model_id\n                 WHERE m.model IN %s\n            \"\"\",\n            [tuple(model_names)]\n        )\n        existing = {}\n        inh_ids = {}\n        for iid, model_id, parent_id, parent_field_id in cr.fetchall():\n            inh_ids[(model_id, parent_id, parent_field_id)] = iid\n            existing[(model_id, parent_id)] = parent_field_id\n\n        sentinel = object()\n        cols = [\"model_id\", \"parent_id\", \"parent_field_id\"]\n        rows = [item for item in module_mapping if existing.get(item[:2], sentinel) != item[2]]\n        if rows:\n            ids = upsert_en(self, cols, rows, [\"model_id\", \"parent_id\"])\n            for row, id_ in zip(rows, ids):\n                inh_ids[row] = id_\n            self.pool.post_init(mark_modified, self.browse(ids), cols[1:])\n\n        # update their XML id\n        IrModel.browse(id_ for item in module_mapping for id_ in item[:2]).fetch(['model'])\n        data_list = []\n        for (model_id, parent_id, parent_field_id), modules in module_mapping.items():\n            model_name = IrModel.browse(model_id).model.replace(\".\", \"_\")\n            parent_name = IrModel.browse(parent_id).model.replace(\".\", \"_\")\n            record_id = inh_ids[(model_id, parent_id, parent_field_id)]\n            data_list += [\n                {\n                    \"xml_id\": f\"{module}.model_inherit__{model_name}__{parent_name}\",\n                    \"record\": self.browse(record_id),\n                }\n                for module in modules\n            ]\n\n        self.env[\"ir.model.data\"]._update_xmlids(data_list)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "uniq",
          "definition": "UNIQUE(model_id, parent_id)",
          "message": "Models inherits from another only once"
        }
      ],
      "accessRules": [],
      "className": "ModelInherit"
    },
    {
      "name": "ir.model.fields.selection",
      "description": "Fields Selection",
      "fields": [
        {
          "name": "field_id",
          "type": "Many2one",
          "relation": "ir.model.fields",
          "required": true
        },
        {
          "name": "value",
          "type": "Char",
          "required": true
        },
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "sequence",
          "type": "Integer"
        }
      ],
      "methods": [
        {
          "name": "_get_selection",
          "params": [
            "self",
            "field_id"
          ],
          "decorators": [],
          "source": "def _get_selection(self, field_id):\n        \"\"\" Return the given field's selection as a list of pairs (value, string). \"\"\"\n        self.flush_model(['value', 'name', 'field_id', 'sequence'])\n        return self._get_selection_data(field_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_selection_data",
          "params": [
            "self",
            "field_id"
          ],
          "decorators": [],
          "source": "def _get_selection_data(self, field_id):\n        # return selection as expected on registry (no translations)\n        self._cr.execute(\"\"\"\n            SELECT value, name->>'en_US'\n            FROM ir_model_fields_selection\n            WHERE field_id=%s\n            ORDER BY sequence, id\n        \"\"\", (field_id,))\n        return self._cr.fetchall()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_selections",
          "params": [
            "self",
            "model_names"
          ],
          "decorators": [],
          "source": "def _reflect_selections(self, model_names):\n        \"\"\" Reflect the selections of the fields of the given models. \"\"\"\n        fields = [\n            field\n            for model_name in model_names\n            for field_name, field in self.env[model_name]._fields.items()\n            if field.type in ('selection', 'reference')\n            if isinstance(field.selection, list)\n        ]\n        if not fields:\n            return\n\n        # determine expected and existing rows\n        IMF = self.env['ir.model.fields']\n        expected = {\n            (field_id, value): (label, index)\n            for field in fields\n            for field_id in [IMF._get_ids(field.model_name)[field.name]]\n            for index, (value, label) in enumerate(field.selection)\n        }\n\n        cr = self.env.cr\n        query = \"\"\"\n            SELECT s.field_id, s.value, s.name->>'en_US', s.sequence\n            FROM ir_model_fields_selection s, ir_model_fields f\n            WHERE s.field_id = f.id AND f.model IN %s\n        \"\"\"\n        cr.execute(query, [tuple(model_names)])\n        existing = {row[:2]: row[2:] for row in cr.fetchall()}\n\n        # create or update rows\n        cols = ['field_id', 'value', 'name', 'sequence']\n        rows = [key + val for key, val in expected.items() if existing.get(key) != val]\n        if rows:\n            ids = upsert_en(self, cols, rows, ['field_id', 'value'])\n            self.pool.post_init(mark_modified, self.browse(ids), cols[2:])\n\n        # update their XML ids\n        module = self._context.get('module')\n        if not module:\n            return\n\n        query = \"\"\"\n            SELECT f.model, f.name, s.value, s.id\n            FROM ir_model_fields_selection s, ir_model_fields f\n            WHERE s.field_id = f.id AND f.model IN %s\n        \"\"\"\n        cr.execute(query, [tuple(model_names)])\n        selection_ids = {row[:3]: row[3] for row in cr.fetchall()}\n\n        data_list = []\n        for field in fields:\n            model = self.env[field.model_name]\n            for value, modules in field._selection_modules(model).items():\n                for m in modules:\n                    xml_id = selection_xmlid(m, field.model_name, field.name, value)\n                    record = self.browse(selection_ids[field.model_name, field.name, value])\n                    data_list.append({'xml_id': xml_id, 'record': record})\n        self.env['ir.model.data']._update_xmlids(data_list)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_selection",
          "params": [
            "self",
            "model_name",
            "field_name",
            "selection"
          ],
          "decorators": [],
          "source": "def _update_selection(self, model_name, field_name, selection):\n        \"\"\" Set the selection of a field to the given list, and return the row\n            values of the given selection records.\n        \"\"\"\n        field_id = self.env['ir.model.fields']._get_ids(model_name)[field_name]\n\n        # selection rows {value: row}\n        cur_rows = self._existing_selection_data(model_name, field_name)\n        new_rows = {\n            value: dict(value=value, name=label, sequence=index)\n            for index, (value, label) in enumerate(selection)\n        }\n\n        rows_to_insert = []\n        rows_to_update = []\n        rows_to_remove = []\n        for value in new_rows.keys() | cur_rows.keys():\n            new_row, cur_row = new_rows.get(value), cur_rows.get(value)\n            if new_row is None:\n                if self.pool.ready:\n                    # removing a selection in the new list, at your own risks\n                    _logger.warning(\"Removing selection value %s on %s.%s\",\n                                    cur_row['value'], model_name, field_name)\n                    rows_to_remove.append(cur_row['id'])\n            elif cur_row is None:\n                new_row['name'] = Json({'en_US': new_row['name']})\n                rows_to_insert.append(dict(new_row, field_id=field_id))\n            elif any(new_row[key] != cur_row[key] for key in new_row):\n                new_row['name'] = Json({'en_US': new_row['name']})\n                rows_to_update.append(dict(new_row, id=cur_row['id']))\n\n        if rows_to_insert:\n            row_ids = query_insert(self.env.cr, self._table, rows_to_insert)\n            # update cur_rows for output\n            for row, row_id in zip(rows_to_insert, row_ids):\n                cur_rows[row['value']] = dict(row, id=row_id)\n\n        for row in rows_to_update:\n            query_update(self.env.cr, self._table, row, ['id'])\n\n        if rows_to_remove:\n            self.browse(rows_to_remove).unlink()\n\n        return cur_rows",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_existing_selection_data",
          "params": [
            "self",
            "model_name",
            "field_name"
          ],
          "decorators": [],
          "source": "def _existing_selection_data(self, model_name, field_name):\n        \"\"\" Return the selection data of the given model, by field and value, as\n            a dict {field_name: {value: row_values}}.\n        \"\"\"\n        query = \"\"\"\n            SELECT s.*, s.name->>'en_US' AS name\n            FROM ir_model_fields_selection s\n            JOIN ir_model_fields f ON s.field_id=f.id\n            WHERE f.model=%s and f.name=%s\n        \"\"\"\n        self._cr.execute(query, [model_name, field_name])\n        return {row['value']: row for row in self._cr.dictfetchall()}",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        field_ids = {vals['field_id'] for vals in vals_list}\n        field_names = set()\n        for field in self.env['ir.model.fields'].browse(field_ids):\n            field_names.add((field.model, field.name))\n            if field.state != 'manual':\n                raise UserError(_('Properties of base fields cannot be altered in this manner! '\n                                  'Please modify them through Python code, '\n                                  'preferably through a custom addon!'))\n        recs = super().create(vals_list)\n\n        if any(\n            model in self.pool and name in self.pool[model]._fields\n            for model, name in field_names\n        ):\n            # setup models; this re-initializes model in registry\n            self.env.flush_all()\n            self.pool.setup_models(self._cr)\n\n        return recs",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if not self:\n            return True\n\n        if (\n            not self.env.user._is_admin() and\n            any(record.field_id.state != 'manual' for record in self)\n        ):\n            raise UserError(_('Properties of base fields cannot be altered in this manner! '\n                              'Please modify them through Python code, '\n                              'preferably through a custom addon!'))\n\n        if 'value' in vals:\n            for selection in self:\n                if selection.value == vals['value']:\n                    continue\n                if selection.field_id.store:\n                    # in order to keep the cache consistent, flush the\n                    # corresponding field, and invalidate it from cache\n                    model = self.env[selection.field_id.model]\n                    fname = selection.field_id.name\n                    model.invalidate_model([fname])\n                    # replace the value by the new one in the field's corresponding column\n                    query = f'UPDATE \"{model._table}\" SET \"{fname}\"=%s WHERE \"{fname}\"=%s'\n                    self.env.cr.execute(query, [vals['value'], selection.value])\n\n        result = super().write(vals)\n\n        # setup models; this re-initializes model in registry\n        self.env.flush_all()\n        self.pool.setup_models(self._cr)\n\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_if_manual",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_if_manual(self):\n        # Prevent manual deletion of module columns\n        if (\n            self.pool.ready\n            and any(selection.field_id.state != 'manual' for selection in self)\n        ):\n            raise UserError(_('Properties of base fields cannot be altered in this manner! '\n                              'Please modify them through Python code, '\n                              'preferably through a custom addon!'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self._process_ondelete()\n        result = super().unlink()\n\n        # Reload registry for normal unlink only. For module uninstall, the\n        # reload is done independently in odoo.modules.loading.\n        if not self._context.get(MODULE_UNINSTALL_FLAG):\n            # setup models; this re-initializes model in registry\n            self.env.flush_all()\n            self.pool.setup_models(self._cr)\n\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_process_ondelete",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _process_ondelete(self):\n        \"\"\" Process the 'ondelete' of the given selection values. \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "safe_write",
          "params": [
            "records",
            "fname",
            "value"
          ],
          "decorators": [],
          "source": "def safe_write(records, fname, value):\n            if not records:\n                return\n            try:\n                with self.env.cr.savepoint():\n                    records.write({fname: value})\n            except Exception:\n                # going through the ORM failed, probably because of an exception\n                # in an override or possibly a constraint.\n                _logger.runbot(\n                    \"Could not fulfill ondelete action for field %s.%s, \"\n                    \"attempting ORM bypass...\", records._name, fname,\n                )\n                query = sql.SQL(\"UPDATE {} SET {}=%s WHERE id IN %s\").format(\n                    sql.Identifier(records._table),\n                    sql.Identifier(fname),\n                )\n                # if this fails then we're shit out of luck and there's nothing\n                # we can do except fix on a case-by-case basis\n                value = field.convert_to_column(value, records)\n                self.env.cr.execute(query, [value, records._ids])\n                records.invalidate_recordset([fname])\n\n        for selection in self:\n            # The field may exist in database but not in registry. In this case\n            # we allow the field to be skipped, but for production this should\n            # be handled through a migration script. The ORM will take care of\n            # the orphaned 'ir.model.fields' down the stack, and will log a\n            # warning prompting the developer to write a migration script.\n            Model = self.env.get(selection.field_id.model)\n            if Model is None:\n                continue\n            field = Model._fields.get(selection.field_id.name)\n            if not field or not field.store or not Model._auto:\n                continue\n\n            ondelete = (field.ondelete or {}).get(selection.value)\n            # special case for custom fields\n            if ondelete is None and field.manual and not field.required:\n                ondelete = 'set null'\n\n            if ondelete is None:\n                # nothing to do, the selection does not come from a field extension\n                continue\n            elif callable(ondelete):\n                ondelete(selection._get_records())\n            elif ondelete == 'set null':\n                safe_write(selection._get_records(), field.name, False)\n            elif ondelete == 'set default':\n                value = field.convert_to_write(field.default(Model), Model)\n                safe_write(selection._get_records(), field.name, value)\n            elif ondelete.startswith('set '):\n                safe_write(selection._get_records(), field.name, ondelete[4:])\n            elif ondelete == 'cascade':\n                selection._get_records().unlink()\n            else:\n                # this shouldn't happen... simply a sanity check\n                raise ValueError(_(\n                    \"The ondelete policy %r is not valid for field %r\",\n                    ondelete, selection\n                ))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_records",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_records(self):\n        \"\"\" Return the records having 'self' as a value. \"\"\"\n        self.ensure_one()\n        Model = self.env[self.field_id.model]\n        Model.flush_model([self.field_id.name])\n        query = 'SELECT id FROM \"{table}\" WHERE \"{field}\"=%s'.format(\n            table=Model._table, field=self.field_id.name,\n        )\n        self.env.cr.execute(query, [self.value])\n        return Model.browse(r[0] for r in self.env.cr.fetchall())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "selection_field_uniq",
          "definition": "unique(field_id, value)",
          "message": "Selections values must be unique per field"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrModelSelection"
    },
    {
      "name": "ir.model.constraint",
      "description": "Model Constraint",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Constraint",
          "help": "PostgreSQL constraint or foreign key name."
        },
        {
          "name": "definition",
          "type": "Char",
          "help": "PostgreSQL constraint definition"
        },
        {
          "name": "message",
          "type": "Char",
          "help": "Error message returned when the constraint is violated."
        },
        {
          "name": "model",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true
        },
        {
          "name": "module",
          "type": "Many2one",
          "relation": "ir.module.module",
          "required": true
        },
        {
          "name": "type",
          "type": "Char",
          "required": true,
          "string": "Constraint Type",
          "help": "Type of the constraint: `f` for a foreign key, "
        },
        {
          "name": "write_date",
          "type": "Datetime"
        },
        {
          "name": "create_date",
          "type": "Datetime"
        }
      ],
      "methods": [
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self.check_access_rights('unlink')\n        self.check_access_rule('unlink')\n        ids_set = set(self.ids)\n        for data in self.sorted(key='id', reverse=True):\n            name = tools.ustr(data.name)\n            if data.model.model in self.env:\n                table = self.env[data.model.model]._table\n            else:\n                table = data.model.model.replace('.', '_')\n            typ = data.type\n\n            # double-check we are really going to delete all the owners of this schema element\n            self._cr.execute(\"\"\"SELECT id from ir_model_constraint where name=%s\"\"\", (data.name,))\n            external_ids = set(x[0] for x in self._cr.fetchall())\n            if external_ids - ids_set:\n                # as installed modules have defined this element we must not delete it!\n                continue\n\n            if typ == 'f':\n                # test if FK exists on this table (it could be on a related m2m table, in which case we ignore it)\n                self._cr.execute(\"\"\"SELECT 1 from pg_constraint cs JOIN pg_class cl ON (cs.conrelid = cl.oid)\n                                    WHERE cs.contype=%s and cs.conname=%s and cl.relname=%s\"\"\",\n                                 ('f', name, table))\n                if self._cr.fetchone():\n                    self._cr.execute(\n                        sql.SQL('ALTER TABLE {} DROP CONSTRAINT {}').format(\n                            sql.Identifier(table),\n                            sql.Identifier(name[:63])\n                        ))\n                    _logger.info('Dropped FK CONSTRAINT %s@%s', name, data.model.model)\n\n            if typ == 'u':\n                hname = tools.make_identifier(name)\n                # test if constraint exists\n                # Since type='u' means any \"other\" constraint, to avoid issues we limit to\n                # 'c' -> check, 'u' -> unique, 'x' -> exclude constraints, effective leaving\n                # out 'p' -> primary key and 'f' -> foreign key, constraints.\n                # See: https://www.postgresql.org/docs/9.5/catalog-pg-constraint.html\n                self._cr.execute(\"\"\"SELECT 1 from pg_constraint cs JOIN pg_class cl ON (cs.conrelid = cl.oid)\n                                    WHERE cs.contype in ('c', 'u', 'x') and cs.conname=%s and cl.relname=%s\"\"\",\n                                 (hname, table))\n                if self._cr.fetchone():\n                    self._cr.execute(sql.SQL('ALTER TABLE {} DROP CONSTRAINT {}').format(\n                        sql.Identifier(table), sql.Identifier(hname)))\n                    _logger.info('Dropped CONSTRAINT %s@%s', name, data.model.model)\n\n        return super().unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        default = dict(default or {})\n        default['name'] = self.name + '_copy'\n        return super(IrModelConstraint, self).copy(default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_constraint",
          "params": [
            "self",
            "model",
            "conname",
            "type",
            "definition",
            "module",
            "message=None"
          ],
          "decorators": [],
          "source": "def _reflect_constraint(self, model, conname, type, definition, module, message=None):\n        \"\"\" Reflect the given constraint, and return its corresponding record\n            if a record is created or modified; returns ``None`` otherwise.\n            The reflection makes it possible to remove a constraint when its\n            corresponding module is uninstalled. ``type`` is either 'f' or 'u'\n            depending on the constraint being a foreign key or not.\n        \"\"\"\n        if not module:\n            # no need to save constraints for custom models as they're not part\n            # of any module\n            return\n        assert type in ('f', 'u')\n        cr = self._cr\n        query = \"\"\" SELECT c.id, type, definition, message->>'en_US' as message\n                    FROM ir_model_constraint c, ir_module_module m\n                    WHERE c.module=m.id AND c.name=%s AND m.name=%s \"\"\"\n        cr.execute(query, (conname, module))\n        cons = cr.dictfetchone()\n        if not cons:\n            query = \"\"\" INSERT INTO ir_model_constraint\n                            (name, create_date, write_date, create_uid, write_uid, module, model, type, definition, message)\n                        VALUES (%s,\n                                now() AT TIME ZONE 'UTC',\n                                now() AT TIME ZONE 'UTC',\n                                %s, %s,\n                                (SELECT id FROM ir_module_module WHERE name=%s),\n                                (SELECT id FROM ir_model WHERE model=%s),\n                                %s, %s, %s)\n                        RETURNING id\"\"\"\n            cr.execute(query, (conname, self.env.uid, self.env.uid, module, model._name, type, definition, Json({'en_US': message})))\n            return self.browse(cr.fetchone()[0])\n\n        cons_id = cons.pop('id')\n        if cons != dict(type=type, definition=definition, message=message):\n            query = \"\"\" UPDATE ir_model_constraint\n                        SET write_date=now() AT TIME ZONE 'UTC',\n                            write_uid=%s, type=%s, definition=%s, message=%s\n                        WHERE id=%s\"\"\"\n            cr.execute(query, (self.env.uid, type, definition, Json({'en_US': message}), cons_id))\n            return self.browse(cons_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_constraints",
          "params": [
            "self",
            "model_names"
          ],
          "decorators": [],
          "source": "def _reflect_constraints(self, model_names):\n        \"\"\" Reflect the SQL constraints of the given models. \"\"\"\n        for model_name in model_names:\n            self._reflect_model(self.env[model_name])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_model",
          "params": [
            "self",
            "model"
          ],
          "decorators": [],
          "source": "def _reflect_model(self, model):\n        \"\"\" Reflect the _sql_constraints of the given model. \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "cons_text",
          "params": [
            "txt"
          ],
          "decorators": [],
          "source": "def cons_text(txt):\n            return txt.lower().replace(', ',',').replace(' (','(')\n\n        # map each constraint on the name of the module where it is defined\n        constraint_module = {\n            constraint[0]: cls._module\n            for cls in reversed(self.env.registry[model._name].mro())\n            if models.is_definition_class(cls)\n            for constraint in getattr(cls, '_local_sql_constraints', ())\n        }\n\n        data_list = []\n        for (key, definition, message) in model._sql_constraints:\n            conname = '%s_%s' % (model._table, key)\n            module = constraint_module.get(key)\n            record = self._reflect_constraint(model, conname, 'u', cons_text(definition), module, message)\n            xml_id = '%s.constraint_%s' % (module, conname)\n            if record:\n                data_list.append(dict(xml_id=xml_id, record=record))\n            else:\n                self.env['ir.model.data']._load_xmlid(xml_id)\n        if data_list:\n            self.env['ir.model.data']._update_xmlids(data_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "module_name_uniq",
          "definition": "unique(name, module)",
          "message": "Constraints with the same name are unique per module."
        }
      ],
      "accessRules": [
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rule",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrModelConstraint"
    },
    {
      "name": "ir.model.relation",
      "description": "Relation Model",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Relation Name",
          "help": "PostgreSQL table name implementing a many2many relation."
        },
        {
          "name": "model",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true
        },
        {
          "name": "module",
          "type": "Many2one",
          "relation": "ir.module.module",
          "required": true
        },
        {
          "name": "write_date",
          "type": "Datetime"
        },
        {
          "name": "create_date",
          "type": "Datetime"
        }
      ],
      "methods": [
        {
          "name": "_module_data_uninstall",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _module_data_uninstall(self):\n        \"\"\"\n        Delete PostgreSQL many2many relations tracked by this model.\n        \"\"\"\n        if not self.env.is_system():\n            raise AccessError(_('Administrator access is required to uninstall a module'))\n\n        ids_set = set(self.ids)\n        to_drop = tools.OrderedSet()\n        for data in self.sorted(key='id', reverse=True):\n            name = tools.ustr(data.name)\n\n            # double-check we are really going to delete all the owners of this schema element\n            self._cr.execute(\"\"\"SELECT id from ir_model_relation where name = %s\"\"\", (data.name,))\n            external_ids = set(x[0] for x in self._cr.fetchall())\n            if external_ids - ids_set:\n                # as installed modules have defined this element we must not delete it!\n                continue\n\n            if tools.table_exists(self._cr, name):\n                to_drop.add(name)\n\n        self.unlink()\n\n        # drop m2m relation tables\n        for table in to_drop:\n            self._cr.execute(sql.SQL('DROP TABLE {} CASCADE').format(sql.Identifier(table)))\n            _logger.info('Dropped table %s', table)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_reflect_relation",
          "params": [
            "self",
            "model",
            "table",
            "module"
          ],
          "decorators": [],
          "source": "def _reflect_relation(self, model, table, module):\n        \"\"\" Reflect the table of a many2many field for the given model, to make\n            it possible to delete it later when the module is uninstalled.\n        \"\"\"\n        self.env.invalidate_all()\n        cr = self._cr\n        query = \"\"\" SELECT 1 FROM ir_model_relation r, ir_module_module m\n                    WHERE r.module=m.id AND r.name=%s AND m.name=%s \"\"\"\n        cr.execute(query, (table, module))\n        if not cr.rowcount:\n            query = \"\"\" INSERT INTO ir_model_relation\n                            (name, create_date, write_date, create_uid, write_uid, module, model)\n                        VALUES (%s,\n                                now() AT TIME ZONE 'UTC',\n                                now() AT TIME ZONE 'UTC',\n                                %s, %s,\n                                (SELECT id FROM ir_module_module WHERE name=%s),\n                                (SELECT id FROM ir_model WHERE model=%s)) \"\"\"\n            cr.execute(query, (table, self.env.uid, self.env.uid, module, model._name))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "IrModelRelation"
    },
    {
      "name": "ir.model.access",
      "description": "Model Access",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true,
          "string": "Model"
        },
        {
          "name": "group_id",
          "type": "Many2one",
          "relation": "res.groups",
          "string": "Group"
        },
        {
          "name": "perm_read",
          "type": "Boolean",
          "string": "Read Access"
        },
        {
          "name": "perm_write",
          "type": "Boolean",
          "string": "Write Access"
        },
        {
          "name": "perm_create",
          "type": "Boolean",
          "string": "Create Access"
        },
        {
          "name": "perm_unlink",
          "type": "Boolean",
          "string": "Delete Access"
        }
      ],
      "methods": [
        {
          "name": "group_names_with_access",
          "params": [
            "self",
            "model_name",
            "access_mode"
          ],
          "decorators": [],
          "source": "def group_names_with_access(self, model_name, access_mode):\n        \"\"\" Return the names of visible groups which have been granted\n            ``access_mode`` on the model ``model_name``.\n           :rtype: list\n        \"\"\"\n        assert access_mode in ('read', 'write', 'create', 'unlink'), 'Invalid access mode'\n        lang = self.env.lang or 'en_US'\n        self._cr.execute(f\"\"\"\n            SELECT COALESCE(c.name->>%s, c.name->>'en_US'), COALESCE(g.name->>%s, g.name->>'en_US')\n              FROM ir_model_access a\n              JOIN ir_model m ON (a.model_id = m.id)\n              JOIN res_groups g ON (a.group_id = g.id)\n         LEFT JOIN ir_module_category c ON (c.id = g.category_id)\n             WHERE m.model = %s\n               AND a.active = TRUE\n               AND a.perm_{access_mode} = TRUE\n          ORDER BY c.name, g.name NULLS LAST\n        \"\"\", [lang, lang, model_name])\n        return [('%s/%s' % x) if x[0] else x[1] for x in self._cr.fetchall()]\n\n    # The context parameter is useful when the method translates error messages.\n    # But as the method raises an exception in that case,  the key 'lang' might\n    # not be really necessary as a cache key, unless the `ormcache_context`\n    # decorator catches the exception (it does not at the moment.)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_allowed_models",
          "params": [
            "self",
            "mode='read'"
          ],
          "decorators": [],
          "source": "def _get_allowed_models(self, mode='read'):\n        assert mode in ('read', 'write', 'create', 'unlink'), 'Invalid access mode'\n\n        self.flush_model()\n        self.env.cr.execute(f\"\"\"\n            SELECT m.model\n              FROM ir_model_access a\n              JOIN ir_model m ON (m.id = a.model_id)\n             WHERE a.perm_{mode}\n               AND a.active\n               AND (\n                    a.group_id IS NULL OR\n                    -- use subselect fo force a better query plan. See #99695 --\n                    a.group_id IN (\n                        SELECT gu.gid\n                            FROM res_groups_users_rel gu\n                            WHERE gu.uid = %s\n                    )\n                )\n            GROUP BY m.model\n        \"\"\", (self.env.uid,))\n\n        return frozenset(v[0] for v in self.env.cr.fetchall())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "check",
          "params": [
            "self",
            "model",
            "mode='read'",
            "raise_exception=True"
          ],
          "decorators": [],
          "source": "def check(self, model, mode='read', raise_exception=True):\n        if self.env.su:\n            # User root have all accesses\n            return True\n\n        assert isinstance(model, str), 'Not a model name: %s' % (model,)\n\n        # TransientModel records have no access rights, only an implicit access rule\n        if model not in self.env:\n            _logger.error('Missing model %s', model)\n\n        has_access = model in self._get_allowed_models(mode)\n\n        if not has_access and raise_exception:\n            groups = '\\n'.join('\\t- %s' % g for g in self.group_names_with_access(model, mode))\n            document_kind = self.env['ir.model']._get(model).name or model\n            msg_heads = {\n                # Messages are declared in extenso so they are properly exported in translation terms\n                'read': _lt(\n                    \"You are not allowed to access '%(document_kind)s' (%(document_model)s) records.\",\n                    document_kind=document_kind,\n                    document_model=model,\n                ),\n                'write':  _lt(\n                    \"You are not allowed to modify '%(document_kind)s' (%(document_model)s) records.\",\n                    document_kind=document_kind,\n                    document_model=model,\n                ),\n                'create': _lt(\n                    \"You are not allowed to create '%(document_kind)s' (%(document_model)s) records.\",\n                    document_kind=document_kind,\n                    document_model=model,\n                ),\n                'unlink': _lt(\n                    \"You are not allowed to delete '%(document_kind)s' (%(document_model)s) records.\",\n                    document_kind=document_kind,\n                    document_model=model,\n                ),\n            }\n            operation_error = msg_heads[mode]\n\n            if groups:\n                group_info = _(\"This operation is allowed for the following groups:\\n%(groups_list)s\", groups_list=groups)\n            else:\n                group_info = _(\"No group currently allows this operation.\")\n\n            resolution_info = _(\"Contact your administrator to request access if necessary.\")\n\n            _logger.info('Access Denied by ACLs for operation: %s, uid: %s, model: %s', mode, self._uid, model)\n            msg = \"\"\"{operation_error}\n\n{group_info}\n\n{resolution_info}\"\"\".format(\n                operation_error=operation_error,\n                group_info=group_info,\n                resolution_info=resolution_info)\n\n            raise AccessError(msg) from None\n\n        return has_access",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "call_cache_clearing_methods",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def call_cache_clearing_methods(self):\n        self.env.invalidate_all()\n        self.env.registry.clear_cache()  # mainly _get_allowed_models\n\n    #\n    # Check rights on actions\n    #",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.call_cache_clearing_methods()\n        for ima in vals_list:\n            if \"group_id\" in ima and not ima[\"group_id\"] and any([\n                    ima.get(\"perm_read\"),\n                    ima.get(\"perm_write\"),\n                    ima.get(\"perm_create\"),\n                    ima.get(\"perm_unlink\")]):\n                _logger.warning(\"Rule %s has no group, this is a deprecated feature. Every access-granting rule should specify a group.\", ima['name'])\n        return super(IrModelAccess, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        self.call_cache_clearing_methods()\n        return super(IrModelAccess, self).write(values)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self.call_cache_clearing_methods()\n        return super(IrModelAccess, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "group_names_with_access (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "call_cache_clearing_methods (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrModelAccess"
    },
    {
      "name": "ir.model.data",
      "description": "Model Data",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "External Identifier",
          "help": "External Key/Identifier that can be used for "
        },
        {
          "name": "complete_name",
          "type": "Char",
          "string": "Complete ID"
        },
        {
          "name": "model",
          "type": "Char",
          "required": true,
          "string": "Model Name"
        },
        {
          "name": "module",
          "type": "Char",
          "required": true
        },
        {
          "name": "res_id",
          "type": "Many2oneReference",
          "string": "Record ID",
          "help": "ID of the target record in the database"
        },
        {
          "name": "noupdate",
          "type": "Boolean",
          "string": "Non Updatable"
        },
        {
          "name": "reference",
          "type": "Char",
          "readonly": true,
          "string": "Reference"
        }
      ],
      "methods": [
        {
          "name": "_compute_complete_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_complete_name(self):\n        for res in self:\n            res.complete_name = \".\".join(n for n in [res.module, res.name] if n)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_reference",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_reference(self):\n        for res in self:\n            res.reference = \"%s,%s\" % (res.model, res.res_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_auto_init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _auto_init(self):\n        res = super(IrModelData, self)._auto_init()\n        tools.create_unique_index(self._cr, 'ir_model_data_module_name_uniq_index',\n                                  self._table, ['module', 'name'])\n        tools.create_index(self._cr, 'ir_model_data_model_res_id_index',\n                           self._table, ['model', 'res_id'])\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        invalid_records = self.filtered(lambda r: not r.res_id or r.model not in self.env)\n        for invalid_record in invalid_records:\n            invalid_record.display_name = invalid_record.complete_name\n        for model, model_data_records in (self - invalid_records).grouped('model').items():\n            records = self.env[model].browse(model_data_records.mapped('res_id'))\n            for xid, target_record in zip(model_data_records, records):\n                try:\n                    xid.display_name = target_record.display_name or xid.complete_name\n                except Exception:  # pylint: disable=broad-except\n                    xid.display_name = xid.complete_name\n\n    # NEW V8 API",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_xmlid_lookup",
          "params": [
            "self",
            "xmlid: str"
          ],
          "returnType": "tuple",
          "decorators": [],
          "source": "def _xmlid_lookup(self, xmlid: str) -> tuple:\n        \"\"\"Low level xmlid lookup\n        Return (id, res_model, res_id) or raise ValueError if not found\n        \"\"\"\n        module, name = xmlid.split('.', 1)\n        query = \"SELECT model, res_id FROM ir_model_data WHERE module=%s AND name=%s\"\n        self.env.cr.execute(query, [module, name])\n        result = self.env.cr.fetchone()\n        if not (result and result[1]):\n            raise ValueError('External ID not found in the system: %s' % xmlid)\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_xmlid_to_res_model_res_id",
          "params": [
            "self",
            "xmlid",
            "raise_if_not_found=False"
          ],
          "decorators": [],
          "source": "def _xmlid_to_res_model_res_id(self, xmlid, raise_if_not_found=False):\n        \"\"\" Return (res_model, res_id)\"\"\"\n        try:\n            return self._xmlid_lookup(xmlid)\n        except ValueError:\n            if raise_if_not_found:\n                raise\n            return (False, False)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_xmlid_to_res_id",
          "params": [
            "self",
            "xmlid",
            "raise_if_not_found=False"
          ],
          "decorators": [],
          "source": "def _xmlid_to_res_id(self, xmlid, raise_if_not_found=False):\n        \"\"\" Returns res_id \"\"\"\n        return self._xmlid_to_res_model_res_id(xmlid, raise_if_not_found)[1]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "check_object_reference",
          "params": [
            "self",
            "module",
            "xml_id",
            "raise_on_access_error=False"
          ],
          "decorators": [],
          "source": "def check_object_reference(self, module, xml_id, raise_on_access_error=False):\n        \"\"\"Returns (model, res_id) corresponding to a given module and xml_id (cached), if and only if the user has the necessary access rights\n        to see that object, otherwise raise a ValueError if raise_on_access_error is True or returns a tuple (model found, False)\"\"\"\n        model, res_id = self._xmlid_lookup(\"%s.%s\" % (module, xml_id))\n        #search on id found in result to check if current user has read access right\n        if self.env[model].search([('id', '=', res_id)]):\n            return model, res_id\n        if raise_on_access_error:\n            raise AccessError(_('Not enough access rights on the external ID %r', '%s.%s', (module, xml_id)))\n        return model, False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        self.ensure_one()\n        rand = \"%04x\" % random.getrandbits(16)\n        default = dict(default or {}, name=\"%s_%s\" % (self.name, rand))\n        return super().copy(default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        self.env.registry.clear_cache()  # _xmlid_lookup\n        return super().write(values)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        \"\"\" Regular unlink method, but make sure to clear the caches. \"\"\"\n        self.env.registry.clear_cache()  # _xmlid_lookup\n        return super(IrModelData, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_lookup_xmlids",
          "params": [
            "self",
            "xml_ids",
            "model"
          ],
          "decorators": [],
          "source": "def _lookup_xmlids(self, xml_ids, model):\n        \"\"\" Look up the given XML ids of the given model. \"\"\"\n        if not xml_ids:\n            return []\n\n        # group xml_ids by prefix\n        bymodule = defaultdict(set)\n        for xml_id in xml_ids:\n            prefix, suffix = xml_id.split('.', 1)\n            bymodule[prefix].add(suffix)\n\n        # query xml_ids by prefix\n        result = []\n        cr = self.env.cr\n        for prefix, suffixes in bymodule.items():\n            query = \"\"\"\n                SELECT d.id, d.module, d.name, d.model, d.res_id, d.noupdate, r.id\n                FROM ir_model_data d LEFT JOIN \"{}\" r on d.res_id=r.id\n                WHERE d.module=%s AND d.name IN %s\n            \"\"\".format(model._table)\n            for subsuffixes in cr.split_for_in_conditions(suffixes):\n                cr.execute(query, (prefix, subsuffixes))\n                result.extend(cr.fetchall())\n\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_xmlids",
          "params": [
            "self",
            "data_list",
            "update=False"
          ],
          "decorators": [],
          "source": "def _update_xmlids(self, data_list, update=False):\n        \"\"\" Create or update the given XML ids.\n\n            :param data_list: list of dicts with keys `xml_id` (XMLID to\n                assign), `noupdate` (flag on XMLID), `record` (target record).\n            :param update: should be ``True`` when upgrading a module\n        \"\"\"\n        if not data_list:\n            return\n\n        rows = tools.OrderedSet()\n        for data in data_list:\n            prefix, suffix = data['xml_id'].split('.', 1)\n            record = data['record']\n            noupdate = bool(data.get('noupdate'))\n            rows.add((prefix, suffix, record._name, record.id, noupdate))\n\n        for sub_rows in self.env.cr.split_for_in_conditions(rows):\n            # insert rows or update them\n            query = self._build_update_xmlids_query(sub_rows, update)\n            try:\n                self.env.cr.execute(query, [arg for row in sub_rows for arg in row])\n                result = self.env.cr.fetchall()\n                if result:\n                    for module, name, model, res_id, create_date, write_date in result:\n                        # small optimisation: during install a lot of xmlid are created/updated.\n                        # Instead of clearing the cache, set the correct value in the cache to avoid a bunch of query\n                        self._xmlid_lookup.__cache__.add_value(self, f\"{module}.{name}\", cache_value=(model, res_id))\n                        if create_date != write_date:\n                            # something was updated, notify other workers\n                            # it is possible that create_date and write_date\n                            # have the same value after an update if it was\n                            # created in the same transaction, no need to invalidate other worker cache\n                            # cache in this case.\n                            self.env.registry.cache_invalidated.add('default')\n\n            except Exception:\n                _logger.error(\"Failed to insert ir_model_data\\n%s\", \"\\n\".join(str(row) for row in sub_rows))\n                raise\n\n        # update loaded_xmlids\n        self.pool.loaded_xmlids.update(\"%s.%s\" % row[:2] for row in rows)\n\n    # NOTE: this method is overriden in web_studio; if you need to make another\n    #  override, make sure it is compatible with the one that is there.",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_build_insert_xmlids_values",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _build_insert_xmlids_values(self):\n        return {\n            'module': '%s',\n            'name': '%s',\n            'model': '%s',\n            'res_id': '%s',\n            'noupdate': '%s',\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_build_update_xmlids_query",
          "params": [
            "self",
            "sub_rows",
            "update"
          ],
          "decorators": [],
          "source": "def _build_update_xmlids_query(self, sub_rows, update):\n        rows = self._build_insert_xmlids_values()\n        row_names = f\"({','.join(rows.keys())})\"\n        row_placeholders = f\"({','.join(rows.values())})\"\n        row_placeholders = \", \".join([row_placeholders] * len(sub_rows))\n        return \"\"\"\n            INSERT INTO ir_model_data {row_names}\n            VALUES {row_placeholder}\n            ON CONFLICT (module, name)\n            DO UPDATE SET (model, res_id, write_date) =\n                (EXCLUDED.model, EXCLUDED.res_id, now() at time zone 'UTC')\n                WHERE (ir_model_data.res_id != EXCLUDED.res_id OR ir_model_data.model != EXCLUDED.model) {and_where}\n            RETURNING module, name, model, res_id, create_date, write_date\n        \"\"\".format(\n            row_names=row_names,\n            row_placeholder=row_placeholders,\n            and_where=\"AND NOT ir_model_data.noupdate\" if update else \"\",\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load_xmlid",
          "params": [
            "self",
            "xml_id"
          ],
          "decorators": [],
          "source": "def _load_xmlid(self, xml_id):\n        \"\"\" Simply mark the given XML id as being loaded, and return the\n            corresponding record.\n        \"\"\"\n        record = self.env.ref(xml_id, raise_if_not_found=False)\n        if record:\n            self.pool.loaded_xmlids.add(xml_id)\n        return record",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_module_data_uninstall",
          "params": [
            "self",
            "modules_to_remove"
          ],
          "decorators": [],
          "source": "def _module_data_uninstall(self, modules_to_remove):\n        \"\"\"Deletes all the records referenced by the ir.model.data entries\n        ``ids`` along with their corresponding database backed (including\n        dropping tables, columns, FKs, etc, as long as there is no other\n        ir.model.data entry holding a reference to them (which indicates that\n        they are still owned by another module).\n        Attempts to perform the deletion in an appropriate order to maximize\n        the chance of gracefully deleting all records.\n        This step is performed as part of the full uninstallation of a module.\n        \"\"\"\n        if not self.env.is_system():\n            raise AccessError(_('Administrator access is required to uninstall a module'))\n\n        # enable model/field deletion\n        # we deactivate prefetching to not try to read a column that has been deleted\n        self = self.with_context(**{MODULE_UNINSTALL_FLAG: True, 'prefetch_fields': False})\n\n        # determine records to unlink\n        records_items = []              # [(model, id)]\n        model_ids = []\n        field_ids = []\n        selection_ids = []\n        constraint_ids = []\n\n        module_data = self.search([('module', 'in', modules_to_remove)], order='id DESC')\n        for data in module_data:\n            if data.model == 'ir.model':\n                model_ids.append(data.res_id)\n            elif data.model == 'ir.model.fields':\n                field_ids.append(data.res_id)\n            elif data.model == 'ir.model.fields.selection':\n                selection_ids.append(data.res_id)\n            elif data.model == 'ir.model.constraint':\n                constraint_ids.append(data.res_id)\n            else:\n                records_items.append((data.model, data.res_id))\n\n        # avoid prefetching fields that are going to be deleted: during uninstall, it is\n        # possible to perform a recompute (via flush) after the database columns have been\n        # deleted but before the new registry has been created, meaning the recompute will\n        # be executed on a stale registry, and if some of the data for executing the compute\n        # methods is not in cache it will be fetched, and fields that exist in the registry but not\n        # in the database will be prefetched, this will of course fail and prevent the uninstall.\n        has_shared_field = False\n        for ir_field in self.env['ir.model.fields'].browse(field_ids):\n            model = self.pool.get(ir_field.model)\n            if model is not None:\n                field = model._fields.get(ir_field.name)\n                if field is not None and field.prefetch:\n                    if field._toplevel:\n                        # the field is specific to this registry\n                        field.prefetch = False\n                    else:\n                        # the field is shared across registries; don't modify it\n                        Field = type(field)\n                        field_ = Field(_base_fields=[field, Field(prefetch=False)])\n                        self.env[ir_field.model]._add_field(ir_field.name, field_)\n                        field_.setup(model)\n                        has_shared_field = True\n        if has_shared_field:\n            lazy_property.reset_all(self.env.registry)\n\n        # to collect external ids of records that cannot be deleted\n        undeletable_ids = []",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "delete",
          "params": [
            "records"
          ],
          "decorators": [],
          "source": "def delete(records):\n            # do not delete records that have other external ids (and thus do\n            # not belong to the modules being installed)\n            ref_data = self.search([\n                ('model', '=', records._name),\n                ('res_id', 'in', records.ids),\n            ])\n            records -= records.browse((ref_data - module_data).mapped('res_id'))\n            if not records:\n                return\n\n            # special case for ir.model.fields\n            if records._name == 'ir.model.fields':\n                missing = records - records.exists()\n                if missing:\n                    # delete orphan external ids right now;\n                    # an orphan ir.model.data can happen if the ir.model.field is deleted via\n                    # an ONDELETE CASCADE, in which case we must verify that the records we're\n                    # processing exist in the database otherwise a MissingError will be raised\n                    orphans = ref_data.filtered(lambda r: r.res_id in missing._ids)\n                    _logger.info('Deleting orphan ir_model_data %s', orphans)\n                    orphans.unlink()\n                    # /!\\ this must go before any field accesses on `records`\n                    records -= missing\n                # do not remove LOG_ACCESS_COLUMNS unless _log_access is False\n                # on the model\n                records -= records.filtered(lambda f: f.name == 'id' or (\n                    f.name in models.LOG_ACCESS_COLUMNS and\n                    f.model in self.env and self.env[f.model]._log_access\n                ))\n\n            # now delete the records\n            _logger.info('Deleting %s', records)\n            try:\n                with self._cr.savepoint():\n                    records.unlink()\n            except Exception:\n                if len(records) <= 1:\n                    undeletable_ids.extend(ref_data._ids)\n                else:\n                    # divide the batch in two, and recursively delete them\n                    half_size = len(records) // 2\n                    delete(records[:half_size])\n                    delete(records[half_size:])\n\n        # remove non-model records first, grouped by batches of the same model\n        for model, items in itertools.groupby(unique(records_items), itemgetter(0)):\n            delete(self.env[model].browse(item[1] for item in items))\n\n        # Remove copied views. This must happen after removing all records from\n        # the modules to remove, otherwise ondelete='restrict' may prevent the\n        # deletion of some view. This must also happen before cleaning up the\n        # database schema, otherwise some dependent fields may no longer exist\n        # in database.\n        modules = self.env['ir.module.module'].search([('name', 'in', modules_to_remove)])\n        modules._remove_copied_views()\n\n        # remove constraints\n        delete(self.env['ir.model.constraint'].browse(unique(constraint_ids)))\n\n        # If we delete a selection field, and some of its values have ondelete='cascade',\n        # we expect the records with that value to be deleted. If we delete the field first,\n        # the column is dropped and the selection is gone, and thus the records above will not\n        # be deleted.\n        delete(self.env['ir.model.fields.selection'].browse(unique(selection_ids)).exists())\n        delete(self.env['ir.model.fields'].browse(unique(field_ids)))\n        relations = self.env['ir.model.relation'].search([('module', 'in', modules.ids)])\n        relations._module_data_uninstall()\n\n        # remove models\n        delete(self.env['ir.model'].browse(unique(model_ids)))\n\n        # log undeletable ids\n        _logger.info(\"ir.model.data could not be deleted (%s)\", undeletable_ids)\n\n        # sort out which undeletable model data may have become deletable again because\n        # of records being cascade-deleted or tables being dropped just above\n        for data in self.browse(undeletable_ids).exists():\n            record = self.env[data.model].browse(data.res_id)\n            try:\n                with self.env.cr.savepoint():\n                    if record.exists():\n                        # record exists therefore the data is still undeletable,\n                        # remove it from module_data\n                        module_data -= data\n                        continue\n            except psycopg2.ProgrammingError:\n                # This most likely means that the record does not exist, since record.exists()\n                # is rougly equivalent to `SELECT id FROM table WHERE id=record.id` and it may raise\n                # a ProgrammingError because the table no longer exists (and so does the\n                # record), also applies to ir.model.fields, constraints, etc.\n                pass\n        # remove remaining module data records\n        module_data.unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_process_end_unlink_record",
          "params": [
            "self",
            "record"
          ],
          "decorators": [],
          "source": "def _process_end_unlink_record(self, record):\n        record.unlink()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_process_end",
          "params": [
            "self",
            "modules"
          ],
          "decorators": [],
          "source": "def _process_end(self, modules):\n        \"\"\" Clear records removed from updated module data.\n        This method is called at the end of the module loading process.\n        It is meant to removed records that are no longer present in the\n        updated data. Such records are recognised as the one with an xml id\n        and a module in ir_model_data and noupdate set to false, but not\n        present in self.pool.loaded_xmlids.\n        \"\"\"\n        if not modules or tools.config.get('import_partial'):\n            return True\n\n        bad_imd_ids = []\n        self = self.with_context({MODULE_UNINSTALL_FLAG: True})\n        loaded_xmlids = self.pool.loaded_xmlids\n\n        query = \"\"\" SELECT id, module || '.' || name, model, res_id FROM ir_model_data\n                    WHERE module IN %s AND res_id IS NOT NULL AND COALESCE(noupdate, false) != %s ORDER BY id DESC\n                \"\"\"\n        self._cr.execute(query, (tuple(modules), True))\n        for (id, xmlid, model, res_id) in self._cr.fetchall():\n            if xmlid in loaded_xmlids:\n                continue\n\n            Model = self.env.get(model)\n            if Model is None:\n                continue\n\n            # when _inherits parents are implicitly created we give them an\n            # external id (if their descendant has one) in order to e.g.\n            # properly remove them when the module is deleted, however this\n            # generated id is *not* provided during update yet we don't want to\n            # try and remove either the xid or the record, so check if the\n            # record has a child we've just updated\n            keep = False\n            for inheriting in (self.env[m] for m in Model._inherits_children):\n                # ignore mixins\n                if inheriting._abstract:\n                    continue\n\n                parent_field = inheriting._inherits[model]\n                children = inheriting.with_context(active_test=False).search([(parent_field, '=', res_id)])\n                children_xids = {\n                    xid\n                    for xids in (children and children._get_external_ids().values())\n                    for xid in xids\n                }\n                if children_xids & loaded_xmlids:\n                    # at least one child was loaded\n                    keep = True\n                    break\n            if keep:\n                continue\n\n            # if the record has other associated xids, only remove the xid\n            if self.search_count([\n                (\"model\", \"=\", model),\n                (\"res_id\", \"=\", res_id),\n                (\"id\", \"!=\", id),\n                (\"id\", \"not in\", bad_imd_ids),\n            ]):\n                bad_imd_ids.append(id)\n                continue\n\n            _logger.info('Deleting %s@%s (%s)', res_id, model, xmlid)\n            record = Model.browse(res_id)\n            if record.exists():\n                module = xmlid.split('.', 1)[0]\n                record = record.with_context(module=module)\n                self._process_end_unlink_record(record)\n            else:\n                bad_imd_ids.append(id)\n        if bad_imd_ids:\n            self.browse(bad_imd_ids).unlink()\n\n        # Once all views are created create specific ones\n        self.env['ir.ui.view']._create_all_specific_views(modules)\n\n        loaded_xmlids.clear()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "toggle_noupdate",
          "params": [
            "self",
            "model",
            "res_id"
          ],
          "decorators": [],
          "source": "def toggle_noupdate(self, model, res_id):\n        \"\"\" Toggle the noupdate flag on the external id of the record \"\"\"\n        record = self.env[model].browse(res_id)\n        if record.check_access_rights('write'):\n            for xid in self.search([('model', '=', model), ('res_id', '=', res_id)]):\n                xid.noupdate = not xid.noupdate",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_xmlid_to_res_model_res_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_xmlid_to_res_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_object_reference (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_update_xmlids (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_load_xmlid (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_module_data_uninstall (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_process_end_unlink_record (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_process_end (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "toggle_noupdate (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrModelData"
    },
    {
      "name": "wizard.ir.model.menu.create",
      "description": "Create Menu Wizard",
      "fields": [
        {
          "name": "menu_id",
          "type": "Many2one",
          "relation": "ir.ui.menu",
          "required": true,
          "string": "Parent Menu"
        },
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Menu Name"
        }
      ],
      "methods": [
        {
          "name": "menu_create",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def menu_create(self):\n        for menu in self:\n            model = self.env['ir.model'].browse(self._context.get('model_id'))\n            vals = {\n                'name': menu.name,\n                'res_model': model.model,\n                'view_mode': 'tree,form',\n            }\n            action_id = self.env['ir.actions.act_window'].create(vals)\n            self.env['ir.ui.menu'].create({\n                'name': menu.name,\n                'parent_id': menu.menu_id.id,\n                'action': 'ir.actions.act_window,%d' % (action_id,)\n            })\n        return {'type': 'ir.actions.act_window_close'}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "WizardModelMenu"
    },
    {
      "name": "ir.module.category",
      "description": "Application",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Name"
        },
        {
          "name": "parent_id",
          "type": "Many2one",
          "relation": "ir.module.category",
          "string": "Parent Application"
        },
        {
          "name": "child_ids",
          "type": "One2many",
          "relation": "ir.module.category",
          "string": "Child Applications"
        },
        {
          "name": "module_ids",
          "type": "One2many",
          "relation": "ir.module.module",
          "string": "Modules"
        },
        {
          "name": "description",
          "type": "Text",
          "string": "Description"
        },
        {
          "name": "sequence",
          "type": "Integer",
          "string": "Sequence"
        },
        {
          "name": "visible",
          "type": "Boolean",
          "string": "Visible"
        },
        {
          "name": "exclusive",
          "type": "Boolean",
          "string": "Exclusive"
        },
        {
          "name": "xml_id",
          "type": "Char",
          "string": "External ID"
        }
      ],
      "methods": [
        {
          "name": "_compute_xml_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_xml_id(self):\n        xml_ids = defaultdict(list)\n        domain = [('model', '=', self._name), ('res_id', 'in', self.ids)]\n        for data in self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name', 'res_id']):\n            xml_ids[data['res_id']].append(\"%s.%s\" % (data['module'], data['name']))\n        for cat in self:\n            cat.xml_id = xml_ids.get(cat.id, [''])[0]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_parent_not_circular",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_parent_not_circular(self):\n        if not self._check_recursion():\n            raise ValidationError(_(\"Error ! You cannot create recursive categories.\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_parent_not_circular",
          "definition": "@api.constrains('parent_id')\n    def _check_parent_not_circular(self):\n        if not self._check_recursion():\n            raise ValidationError(_(\"Error ! You cannot create recursive categories.\"))",
          "message": "'parent_id'"
        }
      ],
      "accessRules": [],
      "className": "ModuleCategory"
    },
    {
      "name": "ir.module.module",
      "description": "Module",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "readonly": true
        },
        {
          "name": "category_id",
          "type": "Many2one",
          "relation": "ir.module.category",
          "readonly": true,
          "string": "Category"
        },
        {
          "name": "shortdesc",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "summary",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "description",
          "type": "Text",
          "readonly": true
        },
        {
          "name": "description_html",
          "type": "Html"
        },
        {
          "name": "author",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "maintainer",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "contributors",
          "type": "Text",
          "readonly": true
        },
        {
          "name": "website",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "installed_version",
          "type": "Char"
        },
        {
          "name": "latest_version",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "published_version",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "url",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "sequence",
          "type": "Integer"
        },
        {
          "name": "dependencies_id",
          "type": "One2many",
          "relation": "ir.module.module.dependency",
          "readonly": true,
          "string": "Dependencies"
        },
        {
          "name": "exclusion_ids",
          "type": "One2many",
          "relation": "ir.module.module.exclusion",
          "readonly": true,
          "string": "Exclusions"
        },
        {
          "name": "auto_install",
          "type": "Boolean",
          "help": "An auto-installable module is automatically installed by the "
        },
        {
          "name": "state",
          "type": "Selection",
          "readonly": true,
          "string": "Status"
        },
        {
          "name": "demo",
          "type": "Boolean",
          "readonly": true
        },
        {
          "name": "license",
          "type": "Selection"
        },
        {
          "name": "menus_by_module",
          "type": "Text",
          "string": "Menus"
        },
        {
          "name": "reports_by_module",
          "type": "Text",
          "string": "Reports"
        },
        {
          "name": "views_by_module",
          "type": "Text",
          "string": "Views"
        },
        {
          "name": "application",
          "type": "Boolean",
          "readonly": true
        },
        {
          "name": "icon",
          "type": "Char"
        },
        {
          "name": "icon_image",
          "type": "Binary",
          "string": "Icon"
        },
        {
          "name": "icon_flag",
          "type": "Char",
          "string": "Flag"
        },
        {
          "name": "to_buy",
          "type": "Boolean"
        },
        {
          "name": "has_iap",
          "type": "Boolean"
        }
      ],
      "methods": [
        {
          "name": "get_module_info",
          "params": [
            "cls",
            "name"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def get_module_info(cls, name):\n        try:\n            return modules.get_manifest(name)\n        except Exception:\n            _logger.debug('Error when trying to fetch information for module %s', name, exc_info=True)\n            return {}",
          "isPrivate": false,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_get_desc",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_desc(self):",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_apply_description_images",
          "params": [
            "doc"
          ],
          "decorators": [],
          "source": "def _apply_description_images(doc):\n            html = lxml.html.document_fromstring(doc)\n            for element, _attribute, _link, _pos in html.iterlinks():\n                if element.get('src') and not '//' in element.get('src') and not 'static/' in element.get('src'):\n                    element.set('src', \"/%s/static/description/%s\" % (module.name, element.get('src')))\n            return tools.html_sanitize(lxml.html.tostring(html))\n\n        for module in self:\n            if not module.name:\n                module.description_html = False\n                continue\n            path = os.path.join(module.name, 'static/description/index.html')\n            try:\n                with tools.file_open(path, 'rb') as desc_file:\n                    doc = desc_file.read()\n                    if doc.startswith(XML_DECLARATION):\n                        warnings.warn(\n                            f\"XML declarations in HTML module descriptions are \"\n                            f\"deprecated since Odoo 17, {module.name} can just \"\n                            f\"have a UTF8 description with not need for a \"\n                            f\"declaration.\",\n                            category=DeprecationWarning,\n                        )\n                    else:\n                        try:\n                            doc = doc.decode()\n                        except UnicodeDecodeError:\n                            warnings.warn(\n                                f\"Non-UTF8 module descriptions are deprecated \"\n                                f\"since Odoo 17 ({module.name}'s description \"\n                                f\"is not utf-8)\",\n                                category=DeprecationWarning,\n                            )\n                    module.description_html = _apply_description_images(doc)\n            except FileNotFoundError:\n                overrides = {\n                    'embed_stylesheet': False,\n                    'doctitle_xform': False,\n                    'output_encoding': 'unicode',\n                    'xml_declaration': False,\n                    'file_insertion_enabled': False,\n                }\n                output = publish_string(source=module.description if not module.application and module.description else '', settings_overrides=overrides, writer=MyWriter())\n                module.description_html = _apply_description_images(output)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_latest_version",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_latest_version(self):\n        default_version = modules.adapt_version('1.0')\n        for module in self:\n            module.installed_version = self.get_module_info(module.name).get('version', default_version)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_views",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_views(self):\n        IrModelData = self.env['ir.model.data'].with_context(active_test=True)\n        dmodels = ['ir.ui.view', 'ir.actions.report', 'ir.ui.menu']\n\n        for module in self:\n            # Skip uninstalled modules below, no data to find anyway.\n            if module.state not in ('installed', 'to upgrade', 'to remove'):\n                module.views_by_module = \"\"\n                module.reports_by_module = \"\"\n                module.menus_by_module = \"\"\n                continue\n\n            # then, search and group ir.model.data records\n            imd_models = defaultdict(list)\n            imd_domain = [('module', '=', module.name), ('model', 'in', tuple(dmodels))]\n            for data in IrModelData.sudo().search(imd_domain):\n                imd_models[data.model].append(data.res_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "browse",
          "params": [
            "model"
          ],
          "decorators": [],
          "source": "def browse(model):\n                # as this method is called before the module update, some xmlid\n                # may be invalid at this stage; explictly filter records before\n                # reading them\n                return self.env[model].browse(imd_models[model]).exists()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "format_view",
          "params": [
            "v"
          ],
          "decorators": [],
          "source": "def format_view(v):\n                return '%s%s (%s)' % (v.inherit_id and '* INHERIT ' or '', v.name, v.type)\n\n            module.views_by_module = \"\\n\".join(sorted(format_view(v) for v in browse('ir.ui.view')))\n            module.reports_by_module = \"\\n\".join(sorted(r.name for r in browse('ir.actions.report')))\n            module.menus_by_module = \"\\n\".join(sorted(m.complete_name for m in browse('ir.ui.menu')))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_icon_image",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_icon_image(self):\n        self.icon_image = ''\n        for module in self:\n            if not module.id:\n                continue\n            if module.icon:\n                path = os.path.join(module.icon.lstrip(\"/\"))\n            else:\n                path = modules.module.get_module_icon_path(module)\n            if path:\n                try:\n                    with tools.file_open(path, 'rb', filter_ext=('.png', '.svg', '.gif', '.jpeg', '.jpg')) as image_file:\n                        module.icon_image = base64.b64encode(image_file.read())\n                except FileNotFoundError:\n                    module.icon_image = ''\n            countries = self.get_module_info(module.name).get('countries', [])\n            country_code = len(countries) == 1 and countries[0]\n            module.icon_flag = get_flag(country_code.upper()) if country_code else ''\n\n    name = fields.Char('Technical Name', readonly=True, required=True)\n    category_id = fields.Many2one('ir.module.category', string='Category', readonly=True, index=True)\n    shortdesc = fields.Char('Module Name', readonly=True, translate=True)\n    summary = fields.Char('Summary', readonly=True, translate=True)\n    description = fields.Text('Description', readonly=True, translate=True)\n    description_html = fields.Html('Description HTML', compute='_get_desc')\n    author = fields.Char(\"Author\", readonly=True)\n    maintainer = fields.Char('Maintainer', readonly=True)\n    contributors = fields.Text('Contributors', readonly=True)\n    website = fields.Char(\"Website\", readonly=True)\n\n    # attention: Incorrect field names !!\n    #   installed_version refers the latest version (the one on disk)\n    #   latest_version refers the installed version (the one in database)\n    #   published_version refers the version available on the repository\n    installed_version = fields.Char('Latest Version', compute='_get_latest_version')\n    latest_version = fields.Char('Installed Version', readonly=True)\n    published_version = fields.Char('Published Version', readonly=True)\n\n    url = fields.Char('URL', readonly=True)\n    sequence = fields.Integer('Sequence', default=100)\n    dependencies_id = fields.One2many('ir.module.module.dependency', 'module_id',\n                                       string='Dependencies', readonly=True)\n    exclusion_ids = fields.One2many('ir.module.module.exclusion', 'module_id',\n                                    string='Exclusions', readonly=True)\n    auto_install = fields.Boolean('Automatic Installation',\n                                   help='An auto-installable module is automatically installed by the '\n                                        'system when all its dependencies are satisfied. '\n                                        'If the module has no dependency, it is always installed.')\n    state = fields.Selection(STATES, string='Status', default='uninstallable', readonly=True, index=True)\n    demo = fields.Boolean('Demo Data', default=False, readonly=True)\n    license = fields.Selection([\n        ('GPL-2', 'GPL Version 2'),\n        ('GPL-2 or any later version', 'GPL-2 or later version'),\n        ('GPL-3', 'GPL Version 3'),\n        ('GPL-3 or any later version', 'GPL-3 or later version'),\n        ('AGPL-3', 'Affero GPL-3'),\n        ('LGPL-3', 'LGPL Version 3'),\n        ('Other OSI approved licence', 'Other OSI Approved License'),\n        ('OEEL-1', 'Odoo Enterprise Edition License v1.0'),\n        ('OPL-1', 'Odoo Proprietary License v1.0'),\n        ('Other proprietary', 'Other Proprietary')\n    ], string='License', default='LGPL-3', readonly=True)\n    menus_by_module = fields.Text(string='Menus', compute='_get_views', store=True)\n    reports_by_module = fields.Text(string='Reports', compute='_get_views', store=True)\n    views_by_module = fields.Text(string='Views', compute='_get_views', store=True)\n    application = fields.Boolean('Application', readonly=True)\n    icon = fields.Char('Icon URL')\n    icon_image = fields.Binary(string='Icon', compute='_get_icon_image')\n    icon_flag = fields.Char(string='Flag', compute='_get_icon_image')\n    to_buy = fields.Boolean('Odoo Enterprise Module', default=False)\n    has_iap = fields.Boolean(compute='_compute_has_iap')\n\n    _sql_constraints = [\n        ('name_uniq', 'UNIQUE (name)', 'The name of the module must be unique!'),\n    ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_has_iap",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_has_iap(self):\n        for module in self:\n            module.has_iap = bool(module.id) and 'iap' in module.upstream_dependencies(exclude_states=('',)).mapped('name')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_except_installed",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_except_installed(self):\n        for module in self:\n            if module.state in ('installed', 'to upgrade', 'to remove', 'to install'):\n                raise UserError(_('You are trying to remove a module that is installed or will be installed.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self.env.registry.clear_cache()\n        return super(Module, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_modules_to_load_domain",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_modules_to_load_domain(self):\n        \"\"\" Domain to retrieve the modules that should be loaded by the registry. \"\"\"\n        return [('state', '=', 'installed')]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "check_external_dependencies",
          "params": [
            "cls",
            "module_name",
            "newstate='to install'"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def check_external_dependencies(cls, module_name, newstate='to install'):\n        terp = cls.get_module_info(module_name)\n        try:\n            modules.check_manifest_dependencies(terp)\n        except Exception as e:\n            if newstate == 'to install':\n                msg = _('Unable to install module \"%s\" because an external dependency is not met: %s', module_name, e.args[0])\n            elif newstate == 'to upgrade':\n                msg = _('Unable to upgrade module \"%s\" because an external dependency is not met: %s', module_name, e.args[0])\n            else:\n                msg = _('Unable to process module \"%s\" because an external dependency is not met: %s', module_name, e.args[0])\n            raise UserError(msg)",
          "isPrivate": false,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "_state_update",
          "params": [
            "self",
            "newstate",
            "states_to_update",
            "level=100"
          ],
          "decorators": [],
          "source": "def _state_update(self, newstate, states_to_update, level=100):\n        if level < 1:\n            raise UserError(_('Recursion error in modules dependencies!'))\n\n        # whether some modules are installed with demo data\n        demo = False\n\n        for module in self:\n            if module.state not in states_to_update:\n                demo = demo or module.demo\n                continue\n\n            # determine dependency modules to update/others\n            update_mods, ready_mods = self.browse(), self.browse()\n            for dep in module.dependencies_id:\n                if dep.state == 'unknown':\n                    raise UserError(_(\"You try to install module %r that depends on module %r.\\nBut the latter module is not available in your system.\", module.name, dep.name))\n                if dep.depend_id.state == newstate:\n                    ready_mods += dep.depend_id\n                else:\n                    update_mods += dep.depend_id\n\n            # update dependency modules that require it, and determine demo for module\n            update_demo = update_mods._state_update(newstate, states_to_update, level=level-1)\n            module_demo = module.demo or update_demo or any(mod.demo for mod in ready_mods)\n            demo = demo or module_demo\n\n            if module.state in states_to_update:\n                # check dependencies and update module itself\n                self.check_external_dependencies(module.name, newstate)\n                module.write({'state': newstate, 'demo': module_demo})\n\n        return demo",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "button_install",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_install(self):\n        # domain to select auto-installable (but not yet installed) modules\n        auto_domain = [('state', '=', 'uninstalled'), ('auto_install', '=', True)]\n\n        # determine whether an auto-install module must be installed:\n        #  - all its dependencies are installed or to be installed,\n        #  - at least one dependency is 'to install'\n        install_states = frozenset(('installed', 'to install', 'to upgrade'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "must_install",
          "params": [
            "module"
          ],
          "decorators": [],
          "source": "def must_install(module):\n            states = {dep.state for dep in module.dependencies_id if dep.auto_install_required}\n            return states <= install_states and 'to install' in states\n\n        modules = self\n        while modules:\n            # Mark the given modules and their dependencies to be installed.\n            modules._state_update('to install', ['uninstalled'])\n\n            # Determine which auto-installable modules must be installed.\n            modules = self.search(auto_domain).filtered(must_install)\n\n        # the modules that are installed/to install/to upgrade\n        install_mods = self.search([('state', 'in', list(install_states))])\n\n        # check individual exclusions\n        install_names = {module.name for module in install_mods}\n        for module in install_mods:\n            for exclusion in module.exclusion_ids:\n                if exclusion.name in install_names:\n                    raise UserError(_('Modules %r and %r are incompatible.', module.shortdesc, exclusion.exclusion_id.shortdesc))\n\n        # check category exclusions",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "closure",
          "params": [
            "module"
          ],
          "decorators": [],
          "source": "def closure(module):\n            todo = result = module\n            while todo:\n                result |= todo\n                todo = todo.dependencies_id.depend_id\n            return result\n\n        exclusives = self.env['ir.module.category'].search([('exclusive', '=', True)])\n        for category in exclusives:\n            # retrieve installed modules in category and sub-categories\n            categories = category.search([('id', 'child_of', category.ids)])\n            modules = install_mods.filtered(lambda mod: mod.category_id in categories)\n            # the installation is valid if all installed modules in categories\n            # belong to the transitive dependencies of one of them\n            if modules and not any(modules <= closure(module) for module in modules):\n                labels = dict(self.fields_get(['state'])['state']['selection'])\n                raise UserError(\n                    _('You are trying to install incompatible modules in category %r:%s', category.name, ''.join(\n                        f\"\\n- {module.shortdesc} ({labels[module.state]})\"\n                        for module in modules\n                    ))\n                )\n\n        return dict(ACTION_DICT, name=_('Install'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "button_immediate_install",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_immediate_install(self):\n        \"\"\" Installs the selected module(s) immediately and fully,\n        returns the next res.config action to execute\n\n        :returns: next res.config item to execute\n        :rtype: dict[str, object]\n        \"\"\"\n        _logger.info('User #%d triggered module installation', self.env.uid)\n        # We use here the request object (which is thread-local) as a kind of\n        # \"global\" env because the env is not usable in the following use case.\n        # When installing a Chart of Account, I would like to send the\n        # allowed companies to configure it on the correct company.\n        # Otherwise, the SUPERUSER won't be aware of that and will try to\n        # configure the CoA on his own company, which makes no sense.\n        if request:\n            request.allowed_company_ids = self.env.companies.ids\n        return self._button_immediate_function(self.env.registry[self._name].button_install)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "button_install_cancel",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_install_cancel(self):\n        self.write({'state': 'uninstalled', 'demo': False})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "module_uninstall",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def module_uninstall(self):\n        \"\"\" Perform the various steps required to uninstall a module completely\n        including the deletion of all database structures created by the module:\n        tables, columns, constraints, etc.\n        \"\"\"\n        modules_to_remove = self.mapped('name')\n        self.env['ir.model.data']._module_data_uninstall(modules_to_remove)\n        # we deactivate prefetching to not try to read a column that has been deleted\n        self.with_context(prefetch_fields=False).write({'state': 'uninstalled', 'latest_version': False})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "_remove_copied_views",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _remove_copied_views(self):\n        \"\"\" Remove the copies of the views installed by the modules in `self`.\n\n        Those copies do not have an external id so they will not be cleaned by\n        `_module_data_uninstall`. This is why we rely on `key` instead.\n\n        It is important to remove these copies because using them will crash if\n        they rely on data that don't exist anymore if the module is removed.\n        \"\"\"\n        domain = expression.OR([[('key', '=like', m.name + '.%')] for m in self])\n        orphans = self.env['ir.ui.view'].with_context(**{'active_test': False, MODULE_UNINSTALL_FLAG: True}).search(domain)\n        orphans.unlink()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "next",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def next(self):\n        \"\"\"\n        Return the action linked to an ir.actions.todo is there exists one that\n        should be executed. Otherwise, redirect to /web\n        \"\"\"\n        Todos = self.env['ir.actions.todo']\n        _logger.info('getting next %s', Todos)\n        active_todo = Todos.search([('state', '=', 'open')], limit=1)\n        if active_todo:\n            _logger.info('next action is \"%s\"', active_todo.name)\n            return active_todo.action_launch()\n        return {\n            'type': 'ir.actions.act_url',\n            'target': 'self',\n            'url': '/web',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_button_immediate_function",
          "params": [
            "self",
            "function"
          ],
          "decorators": [],
          "source": "def _button_immediate_function(self, function):\n        if not self.env.registry.ready or self.env.registry._init:\n            raise UserError(_('The method _button_immediate_install cannot be called on init or non loaded registries. Please use button_install instead.'))\n\n        if getattr(threading.current_thread(), 'testing', False):\n            raise RuntimeError(\n                \"Module operations inside tests are not transactional and thus forbidden.\\n\"\n                \"If you really need to perform module operations to test a specific behavior, it \"\n                \"is best to write it as a standalone script, and ask the runbot/metastorm team \"\n                \"for help.\"\n            )\n        try:\n            # This is done because the installation/uninstallation/upgrade can modify a currently\n            # running cron job and prevent it from finishing, and since the ir_cron table is locked\n            # during execution, the lock won't be released until timeout.\n            self._cr.execute(\"SELECT * FROM ir_cron FOR UPDATE NOWAIT\")\n        except psycopg2.OperationalError:\n            raise UserError(_(\"Odoo is currently processing a scheduled action.\\n\"\n                              \"Module operations are not possible at this time, \"\n                              \"please try again later or contact your system administrator.\"))\n        function(self)\n\n        self._cr.commit()\n        registry = modules.registry.Registry.new(self._cr.dbname, update_module=True)\n        self._cr.commit()\n        if request and request.registry is self.env.registry:\n            request.env.cr.reset()\n            request.registry = request.env.registry\n            assert request.env.registry is registry\n        self._cr.reset()\n        assert self.env.registry is registry\n\n        # pylint: disable=next-method-called\n        config = self.env['ir.module.module'].next() or {}\n        if config.get('type') not in ('ir.actions.act_window_close',):\n            return config\n\n        # reload the client; open the first available root menu\n        menu = self.env['ir.ui.menu'].search([('parent_id', '=', False)])[:1]\n        return {\n            'type': 'ir.actions.client',\n            'tag': 'reload',\n            'params': {'menu_id': menu.id},\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "button_immediate_uninstall",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_immediate_uninstall(self):\n        \"\"\"\n        Uninstall the selected module(s) immediately and fully,\n        returns the next res.config action to execute\n        \"\"\"\n        _logger.info('User #%d triggered module uninstallation', self.env.uid)\n        return self._button_immediate_function(self.env.registry[self._name].button_uninstall)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "button_uninstall",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_uninstall(self):\n        un_installable_modules = set(odoo.conf.server_wide_modules) & set(self.mapped('name'))\n        if un_installable_modules:\n            raise UserError(_(\"Those modules cannot be uninstalled: %s\", ', '.join(un_installable_modules)))\n        if any(state not in ('installed', 'to upgrade') for state in self.mapped('state')):\n            raise UserError(_(\n                \"One or more of the selected modules have already been uninstalled, if you \"\n                \"believe this to be an error, you may try again later or contact support.\"\n            ))\n        deps = self.downstream_dependencies()\n        (self + deps).write({'state': 'to remove'})\n        return dict(ACTION_DICT, name=_('Uninstall'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "button_uninstall_wizard",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_uninstall_wizard(self):\n        \"\"\" Launch the wizard to uninstall the given module. \"\"\"\n        return {\n            'type': 'ir.actions.act_window',\n            'target': 'new',\n            'name': _('Uninstall module'),\n            'view_mode': 'form',\n            'res_model': 'base.module.uninstall',\n            'context': {'default_module_id': self.id},\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "button_uninstall_cancel",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def button_uninstall_cancel(self):\n        self.write({'state': 'installed'})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "button_immediate_upgrade",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_immediate_upgrade(self):\n        \"\"\"\n        Upgrade the selected module(s) immediately and fully,\n        return the next res.config action to execute\n        \"\"\"\n        return self._button_immediate_function(self.env.registry[self._name].button_upgrade)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "button_upgrade",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_upgrade(self):\n        if not self:\n            return\n        Dependency = self.env['ir.module.module.dependency']\n        self.update_list()\n\n        todo = list(self)\n        if 'base' in self.mapped('name'):\n            # If an installed module is only present in the dependency graph through\n            # a new, uninstalled dependency, it will not have been selected yet.\n            # An update of 'base' should also update these modules, and as a consequence,\n            # install the new dependency.\n            todo.extend(self.search([\n                ('state', '=', 'installed'),\n                ('name', '!=', 'studio_customization'),\n                ('id', 'not in', self.ids),\n            ]))\n        i = 0\n        while i < len(todo):\n            module = todo[i]\n            i += 1\n            if module.state not in ('installed', 'to upgrade'):\n                raise UserError(_(\"Can not upgrade module %r. It is not installed.\", module.name))\n            if self.get_module_info(module.name).get(\"installable\", True):\n                self.check_external_dependencies(module.name, 'to upgrade')\n            for dep in Dependency.search([('name', '=', module.name)]):\n                if (\n                    dep.module_id.state == 'installed'\n                    and dep.module_id not in todo\n                    and dep.module_id.name != 'studio_customization'\n                ):\n                    todo.append(dep.module_id)\n\n        self.browse(module.id for module in todo).write({'state': 'to upgrade'})\n\n        to_install = []\n        for module in todo:\n            if not self.get_module_info(module.name).get(\"installable\", True):\n                continue\n            for dep in module.dependencies_id:\n                if dep.state == 'unknown':\n                    raise UserError(_('You try to upgrade the module %s that depends on the module: %s.\\nBut this module is not available in your system.', module.name, dep.name))\n                if dep.state == 'uninstalled':\n                    to_install += self.search([('name', '=', dep.name)]).ids\n\n        self.browse(to_install).button_install()\n        return dict(ACTION_DICT, name=_('Apply Schedule Upgrade'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "button_upgrade_cancel",
          "params": [
            "self"
          ],
          "decorators": [
            "@assert_log_admin_access"
          ],
          "source": "@assert_log_admin_access\n    def button_upgrade_cancel(self):\n        self.write({'state': 'installed'})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "get_values_from_terp",
          "params": [
            "terp"
          ],
          "decorators": [
            "@staticmethod"
          ],
          "source": "@staticmethod\n    def get_values_from_terp(terp):\n        return {\n            'description': dedent(terp.get('description', '')),\n            'shortdesc': terp.get('name', ''),\n            'author': terp.get('author', 'Unknown'),\n            'maintainer': terp.get('maintainer', False),\n            'contributors': ', '.join(terp.get('contributors', [])) or False,\n            'website': terp.get('website', ''),\n            'license': terp.get('license', 'LGPL-3'),\n            'sequence': terp.get('sequence', 100),\n            'application': terp.get('application', False),\n            'auto_install': terp.get('auto_install', False) is not False,\n            'icon': terp.get('icon', False),\n            'summary': terp.get('summary', ''),\n            'url': terp.get('url') or terp.get('live_test_url', ''),\n            'to_buy': False\n        }",
          "isPrivate": false,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        modules = super().create(vals_list)\n        module_metadata_list = [{\n            'name': 'module_%s' % module.name,\n            'model': 'ir.module.module',\n            'module': 'base',\n            'res_id': module.id,\n            'noupdate': True,\n        } for module in modules]\n        self.env['ir.model.data'].create(module_metadata_list)\n        return modules\n\n    # update the list of available packages",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "update_list",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def update_list(self):\n        res = [0, 0]    # [update, add]\n\n        default_version = modules.adapt_version('1.0')\n        known_mods = self.with_context(lang=None).search([])\n        known_mods_names = {mod.name: mod for mod in known_mods}\n\n        # iterate through detected modules and update/create them in db\n        for mod_name in modules.get_modules():\n            mod = known_mods_names.get(mod_name)\n            terp = self.get_module_info(mod_name)\n            values = self.get_values_from_terp(terp)\n\n            if mod:\n                updated_values = {}\n                for key in values:\n                    old = getattr(mod, key)\n                    if (old or values[key]) and values[key] != old:\n                        updated_values[key] = values[key]\n                if terp.get('installable', True) and mod.state == 'uninstallable':\n                    updated_values['state'] = 'uninstalled'\n                if parse_version(terp.get('version', default_version)) > parse_version(mod.latest_version or default_version):\n                    res[0] += 1\n                if updated_values:\n                    mod.write(updated_values)\n            else:\n                mod_path = modules.get_module_path(mod_name)\n                if not mod_path or not terp:\n                    continue\n                state = \"uninstalled\" if terp.get('installable', True) else \"uninstallable\"\n                mod = self.create(dict(name=mod_name, state=state, **values))\n                res[1] += 1\n\n            mod._update_from_terp(terp)\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_from_terp",
          "params": [
            "self",
            "terp"
          ],
          "decorators": [],
          "source": "def _update_from_terp(self, terp):\n        self._update_dependencies(terp.get('depends', []), terp.get('auto_install'))\n        self._update_exclusions(terp.get('excludes', []))\n        self._update_category(terp.get('category', 'Uncategorized'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_dependencies",
          "params": [
            "self",
            "depends=None",
            "auto_install_requirements=()"
          ],
          "decorators": [],
          "source": "def _update_dependencies(self, depends=None, auto_install_requirements=()):\n        self.env['ir.module.module.dependency'].flush_model()\n        existing = set(dep.name for dep in self.dependencies_id)\n        needed = set(depends or [])\n        for dep in (needed - existing):\n            self._cr.execute('INSERT INTO ir_module_module_dependency (module_id, name) values (%s, %s)', (self.id, dep))\n        for dep in (existing - needed):\n            self._cr.execute('DELETE FROM ir_module_module_dependency WHERE module_id = %s and name = %s', (self.id, dep))\n        self._cr.execute('UPDATE ir_module_module_dependency SET auto_install_required = (name = any(%s)) WHERE module_id = %s',\n                         (list(auto_install_requirements or ()), self.id))\n        self.env['ir.module.module.dependency'].invalidate_model(['auto_install_required'])\n        self.invalidate_recordset(['dependencies_id'])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_exclusions",
          "params": [
            "self",
            "excludes=None"
          ],
          "decorators": [],
          "source": "def _update_exclusions(self, excludes=None):\n        self.env['ir.module.module.exclusion'].flush_model()\n        existing = set(excl.name for excl in self.exclusion_ids)\n        needed = set(excludes or [])\n        for name in (needed - existing):\n            self._cr.execute('INSERT INTO ir_module_module_exclusion (module_id, name) VALUES (%s, %s)', (self.id, name))\n        for name in (existing - needed):\n            self._cr.execute('DELETE FROM ir_module_module_exclusion WHERE module_id=%s AND name=%s', (self.id, name))\n        self.invalidate_recordset(['exclusion_ids'])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_category",
          "params": [
            "self",
            "category='Uncategorized'"
          ],
          "decorators": [],
          "source": "def _update_category(self, category='Uncategorized'):\n        current_category = self.category_id\n        seen = set()\n        current_category_path = []\n        while current_category:\n            current_category_path.insert(0, current_category.name)\n            seen.add(current_category.id)\n            if current_category.parent_id.id in seen:\n                current_category.parent_id = False\n                _logger.warning('category %r ancestry loop has been detected and fixed', current_category)\n            current_category = current_category.parent_id\n\n        categs = category.split('/')\n        if categs != current_category_path:\n            cat_id = modules.db.create_categories(self._cr, categs)\n            self.write({'category_id': cat_id})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_translations",
          "params": [
            "self",
            "filter_lang=None",
            "overwrite=False"
          ],
          "decorators": [],
          "source": "def _update_translations(self, filter_lang=None, overwrite=False):\n        if not filter_lang:\n            langs = self.env['res.lang'].get_installed()\n            filter_lang = [code for code, _ in langs]\n        elif not isinstance(filter_lang, (list, tuple)):\n            filter_lang = [filter_lang]\n\n        update_mods = self.filtered(lambda r: r.state in ('installed', 'to install', 'to upgrade'))\n        mod_dict = {\n            mod.name: mod.dependencies_id.mapped('name')\n            for mod in update_mods\n        }\n        mod_names = topological_sort(mod_dict)\n        self.env['ir.module.module']._load_module_terms(mod_names, filter_lang, overwrite)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check(self):\n        for module in self:\n            if not module.description_html:\n                _logger.warning('module %s: description is empty!', module.name)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def _get(self, name):\n        \"\"\" Return the (sudoed) `ir.module.module` record with the given name.\n        The result may be an empty recordset if the module is not found.\n        \"\"\"\n        model_id = self._get_id(name) if name else False\n        return self.browse(model_id).sudo()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_id",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def _get_id(self, name):\n        self.flush_model(['name'])\n        self.env.cr.execute(\"SELECT id FROM ir_module_module WHERE name=%s\", (name,))\n        return self.env.cr.fetchone()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_installed",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _installed(self):\n        \"\"\" Return the set of installed modules as a dictionary {name: id} \"\"\"\n        return {\n            module.name: module.id\n            for module in self.sudo().search([('state', '=', 'installed')])\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "search_panel_select_range",
          "params": [
            "self",
            "field_name",
            "**kwargs"
          ],
          "decorators": [],
          "source": "def search_panel_select_range(self, field_name, **kwargs):\n        if field_name == 'category_id':\n            enable_counters = kwargs.get('enable_counters', False)\n            domain = [('parent_id', '=', False), ('child_ids.module_ids', '!=', False)]\n\n            excluded_xmlids = [\n                'base.module_category_website_theme',\n                'base.module_category_theme',\n            ]\n            if not self.user_has_groups('base.group_no_one'):\n                excluded_xmlids.append('base.module_category_hidden')\n\n            excluded_category_ids = []\n            for excluded_xmlid in excluded_xmlids:\n                categ = self.env.ref(excluded_xmlid, False)\n                if not categ:\n                    continue\n                excluded_category_ids.append(categ.id)\n\n            if excluded_category_ids:\n                domain = expression.AND([\n                    domain,\n                    [('id', 'not in', excluded_category_ids)],\n                ])\n\n            records = self.env['ir.module.category'].search_read(domain, ['display_name'], order=\"sequence\")\n\n            values_range = OrderedDict()\n            for record in records:\n                record_id = record['id']\n                if enable_counters:\n                    model_domain = expression.AND([\n                        kwargs.get('search_domain', []),\n                        kwargs.get('category_domain', []),\n                        kwargs.get('filter_domain', []),\n                        [('category_id', 'child_of', record_id), ('category_id', 'not in', excluded_category_ids)]\n                    ])\n                    record['__count'] = self.env['ir.module.module'].search_count(model_domain)\n                values_range[record_id] = record\n\n            return {\n                'parent_field': 'parent_id',\n                'values': list(values_range.values()),\n            }\n\n        return super(Module, self).search_panel_select_range(field_name, **kwargs)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load_module_terms",
          "params": [
            "self",
            "modules",
            "langs",
            "overwrite=False"
          ],
          "decorators": [],
          "source": "def _load_module_terms(self, modules, langs, overwrite=False):\n        \"\"\" Load PO files of the given modules for the given languages. \"\"\"\n        # load i18n files\n        translation_importer = TranslationImporter(self.env.cr, verbose=False)\n\n        for module_name in modules:\n            modpath = get_module_path(module_name)\n            if not modpath:\n                continue\n            for lang in langs:\n                is_lang_imported = False\n                for po_path in get_po_paths(module_name, lang):\n                    _logger.info('module %s: loading translation file %s for language %s', module_name, po_path, lang)\n                    translation_importer.load_file(po_path, lang)\n                    is_lang_imported = True\n                if lang != 'en_US' and not is_lang_imported:\n                    _logger.info('module %s: no translation for language %s', module_name, lang)\n\n        translation_importer.save(overwrite=overwrite)\n\n\nDEP_STATES = STATES + [('unknown', 'Unknown')]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_uniq",
          "definition": "UNIQUE (name)",
          "message": "The name of the module must be unique!"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "update_list (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "search_panel_select_range (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_load_module_terms (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Module"
    },
    {
      "name": "ir.module.module.dependency",
      "description": "Module dependency",
      "fields": [
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "module_id",
          "type": "Many2one",
          "relation": "ir.module.module"
        },
        {
          "name": "depend_id",
          "type": "Many2one",
          "relation": "ir.module.module"
        },
        {
          "name": "state",
          "type": "Selection",
          "string": "Status"
        },
        {
          "name": "auto_install_required",
          "type": "Boolean",
          "help": "Whether this dependency blocks automatic installation "
        }
      ],
      "methods": [
        {
          "name": "_compute_depend",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_depend(self):\n        # retrieve all modules corresponding to the dependency names\n        names = list(set(dep.name for dep in self))\n        mods = self.env['ir.module.module'].search([('name', 'in', names)])\n\n        # index modules by name, and assign dependencies\n        name_mod = dict((mod.name, mod) for mod in mods)\n        for dep in self:\n            dep.depend_id = name_mod.get(dep.name)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search_depend",
          "params": [
            "self",
            "operator",
            "value"
          ],
          "decorators": [],
          "source": "def _search_depend(self, operator, value):\n        assert operator == 'in'\n        modules = self.env['ir.module.module'].browse(set(value))\n        return [('name', 'in', modules.mapped('name'))]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_state",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_state(self):\n        for dependency in self:\n            dependency.state = dependency.depend_id.state or 'unknown'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ModuleDependency"
    },
    {
      "name": "ir.module.module.exclusion",
      "description": "Module exclusion",
      "fields": [
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "module_id",
          "type": "Many2one",
          "relation": "ir.module.module"
        },
        {
          "name": "exclusion_id",
          "type": "Many2one",
          "relation": "ir.module.module"
        },
        {
          "name": "state",
          "type": "Selection",
          "string": "Status"
        }
      ],
      "methods": [
        {
          "name": "_compute_exclusion",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_exclusion(self):\n        # retrieve all modules corresponding to the exclusion names\n        names = list(set(excl.name for excl in self))\n        mods = self.env['ir.module.module'].search([('name', 'in', names)])\n\n        # index modules by name, and assign dependencies\n        name_mod = {mod.name: mod for mod in mods}\n        for excl in self:\n            excl.exclusion_id = name_mod.get(excl.name)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search_exclusion",
          "params": [
            "self",
            "operator",
            "value"
          ],
          "decorators": [],
          "source": "def _search_exclusion(self, operator, value):\n        assert operator == 'in'\n        modules = self.env['ir.module.module'].browse(set(value))\n        return [('name', 'in', modules.mapped('name'))]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_state",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_state(self):\n        for exclusion in self:\n            exclusion.state = exclusion.exclusion_id.state or 'unknown'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ModuleExclusion"
    },
    {
      "name": "ir.profile",
      "description": "Profiling results",
      "fields": [
        {
          "name": "create_date",
          "type": "Datetime"
        },
        {
          "name": "session",
          "type": "Char"
        },
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "duration",
          "type": "Float"
        },
        {
          "name": "init_stack_trace",
          "type": "Text"
        },
        {
          "name": "sql",
          "type": "Text"
        },
        {
          "name": "sql_count",
          "type": "Integer"
        },
        {
          "name": "traces_async",
          "type": "Text"
        },
        {
          "name": "traces_sync",
          "type": "Text"
        },
        {
          "name": "qweb",
          "type": "Text"
        },
        {
          "name": "entry_count",
          "type": "Integer"
        },
        {
          "name": "speedscope",
          "type": "Binary"
        },
        {
          "name": "speedscope_url",
          "type": "Text"
        }
      ],
      "methods": [
        {
          "name": "_gc_profile",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _gc_profile(self):\n        # remove profiles older than 30 days\n        domain = [('create_date', '<', fields.Datetime.now() - datetime.timedelta(days=30))]\n        return self.sudo().search(domain).unlink()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_speedscope",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_speedscope(self):\n        for execution in self:\n            sp = Speedscope(init_stack_trace=json.loads(execution.init_stack_trace))\n            if execution.sql:\n                sp.add('sql', json.loads(execution.sql))\n            if execution.traces_async:\n                sp.add('frames', json.loads(execution.traces_async))\n            if execution.traces_sync:\n                sp.add('settrace', json.loads(execution.traces_sync))\n\n            result = json.dumps(sp.add_default().make())\n            execution.speedscope = base64.b64encode(result.encode('utf-8'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_speedscope_url",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_speedscope_url(self):\n        for profile in self:\n            profile.speedscope_url = f'/web/speedscope/{profile.id}'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_enabled_until",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _enabled_until(self):\n        \"\"\"\n        If the profiling is enabled, return until when it is enabled.\n        Otherwise return ``None``.\n        \"\"\"\n        limit = self.env['ir.config_parameter'].sudo().get_param('base.profiling_enabled_until', '')\n        return limit if str(fields.Datetime.now()) < limit else None",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "set_profiling",
          "params": [
            "self",
            "profile=None",
            "collectors=None",
            "params=None"
          ],
          "decorators": [],
          "source": "def set_profiling(self, profile=None, collectors=None, params=None):\n        \"\"\"\n        Enable or disable profiling for the current user.\n\n        :param profile: ``True`` to enable profiling, ``False`` to disable it.\n        :param list collectors: optional list of collectors to use (string)\n        :param dict params: optional parameters set on the profiler object\n        \"\"\"\n        # Note: parameters are coming from a rpc calls or route param (public user),\n        # meaning that corresponding session variables are client-defined.\n        # This allows to activate any profiler, but can be\n        # dangerous handling request.session.profile_collectors/profile_params.\n        if profile:\n            limit = self._enabled_until()\n            _logger.info(\"User %s started profiling\", self.env.user.name)\n            if not limit:\n                request.session.profile_session = None\n                if self.env.user._is_system():\n                    return {\n                            'type': 'ir.actions.act_window',\n                            'view_mode': 'form',\n                            'res_model': 'base.enable.profiling.wizard',\n                            'target': 'new',\n                            'views': [[False, 'form']],\n                        }\n                raise UserError(_('Profiling is not enabled on this database. Please contact an administrator.'))\n            if not request.session.profile_session:\n                request.session.profile_session = make_session(self.env.user.name)\n                request.session.profile_expiration = limit\n                if request.session.profile_collectors is None:\n                    request.session.profile_collectors = []\n                if request.session.profile_params is None:\n                    request.session.profile_params = {}\n        elif profile is not None:\n            request.session.profile_session = None\n\n        if collectors is not None:\n            request.session.profile_collectors = collectors\n\n        if params is not None:\n            request.session.profile_params = params\n\n        return {\n            'session': request.session.profile_session,\n            'collectors': request.session.profile_collectors,\n            'params': request.session.profile_params,\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "set_profiling (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrProfile"
    },
    {
      "name": "base.enable.profiling.wizard",
      "description": "Enable profiling for some time",
      "fields": [
        {
          "name": "duration",
          "type": "Selection"
        },
        {
          "name": "expiration",
          "type": "Datetime"
        },
        {
          "name": "expiration",
          "type": "Datetime.now"
        }
      ],
      "methods": [
        {
          "name": "_compute_expiration",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_expiration(self):\n        for record in self:\n            unit, quantity = (record.duration or 'days_0').split('_')\n            record.expiration = fields.Datetime.now() + relativedelta(**{unit: int(quantity)})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "submit",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def submit(self):\n        self.env['ir.config_parameter'].set_param('base.profiling_enabled_until', self.expiration)\n        return False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "EnableProfilingWizard"
    },
    {
      "name": "ir.property",
      "description": "Company Property",
      "fields": [
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "res_id",
          "type": "Char",
          "string": "Resource",
          "help": "If not set, acts as a default value for new resources"
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company",
          "string": "Company"
        },
        {
          "name": "fields_id",
          "type": "Many2one",
          "relation": "ir.model.fields",
          "required": true,
          "string": "Field"
        },
        {
          "name": "value_float",
          "type": "Float"
        },
        {
          "name": "value_integer",
          "type": "Integer"
        },
        {
          "name": "value_text",
          "type": "Text"
        },
        {
          "name": "value_binary",
          "type": "Binary"
        },
        {
          "name": "value_reference",
          "type": "Char"
        },
        {
          "name": "value_datetime",
          "type": "Datetime"
        },
        {
          "name": "type",
          "type": "Selection"
        }
      ],
      "methods": [
        {
          "name": "init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def init(self):\n        # Ensure there is at most one active variant for each combination.\n        query = \"\"\"\n            CREATE UNIQUE INDEX IF NOT EXISTS ir_property_unique_index\n            ON %s (fields_id, COALESCE(company_id, 0), COALESCE(res_id, ''))\n        \"\"\"\n        self.env.cr.execute(query % self._table)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_values",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _update_values(self, values):\n        if 'value' not in values:\n            return values\n        value = values.pop('value')\n\n        prop = None\n        type_ = values.get('type')\n        if not type_:\n            if self:\n                prop = self[0]\n                type_ = prop.type\n            else:\n                type_ = self._fields['type'].default(self)\n\n        field = TYPE2FIELD.get(type_)\n        if not field:\n            raise UserError(_('Invalid type'))\n\n        if field == 'value_reference':\n            if not value:\n                value = False\n            elif isinstance(value, models.BaseModel):\n                value = '%s,%d' % (value._name, value.id)\n            elif isinstance(value, int):\n                field_id = values.get('fields_id')\n                if not field_id:\n                    if not prop:\n                        raise ValueError()\n                    field_id = prop.fields_id\n                else:\n                    field_id = self.env['ir.model.fields'].browse(field_id)\n\n                value = '%s,%d' % (field_id.sudo().relation, value)\n\n        values[field] = value\n        return values",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        # if any of the records we're writing on has a res_id=False *or*\n        # we're writing a res_id=False on any record\n        default_set = False\n\n        values = self._update_values(values)\n        default_set = (\n            # turning a record value into a fallback value\n            values.get('res_id') is False and any(record.res_id for record in self)\n        ) or any(\n            # changing a fallback value\n            not record.res_id and any(record[fname] != self._fields[fname].convert_to_record(value, self) for fname, value in values.items())\n            for record in self\n        )\n        r = super().write(values)\n        if default_set:\n            # DLE P44: test `test_27_company_dependent`\n            # Easy solution, need to flush write when changing a property.\n            # Maybe it would be better to be able to compute all impacted cache value and update those instead\n            # Then clear_cache must be removed as well.\n            self.env.flush_all()\n            self.env.registry.clear_cache()\n        return r",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        vals_list = [self._update_values(vals) for vals in vals_list]\n        created_default = any(not v.get('res_id') for v in vals_list)\n        r = super(Property, self).create(vals_list)\n        if created_default:\n            # DLE P44: test `test_27_company_dependent`\n            self.env.flush_all()\n            self.env.registry.clear_cache()\n        return r",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        default_deleted = any(not p.res_id for p in self)\n        r = super().unlink()\n        if default_deleted:\n            self.env.registry.clear_cache()\n        return r",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_by_record",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_by_record(self):\n        self.ensure_one()\n        if self.type in ('char', 'text', 'selection'):\n            return self.value_text\n        elif self.type == 'float':\n            return self.value_float\n        elif self.type == 'boolean':\n            return bool(self.value_integer)\n        elif self.type == 'integer':\n            return self.value_integer\n        elif self.type == 'binary':\n            return self.value_binary\n        elif self.type == 'many2one':\n            if not self.value_reference:\n                return False\n            model, resource_id = self.value_reference.split(',')\n            return self.env[model].browse(int(resource_id)).exists()\n        elif self.type == 'datetime':\n            return self.value_datetime\n        elif self.type == 'date':\n            if not self.value_datetime:\n                return False\n            return fields.Date.to_string(fields.Datetime.from_string(self.value_datetime))\n        return False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_default",
          "params": [
            "self",
            "name",
            "model",
            "value",
            "company=False"
          ],
          "decorators": [],
          "source": "def _set_default(self, name, model, value, company=False):\n        \"\"\" Set the given field's generic value for the given company.\n\n        :param name: the field's name\n        :param model: the field's model name\n        :param value: the field's value\n        :param company: the company (record or id)\n        \"\"\"\n        field_id = self.env['ir.model.fields']._get(model, name).id\n        company_id = int(company) if company else False\n        prop = self.sudo().search([\n            ('fields_id', '=', field_id),\n            ('company_id', '=', company_id),\n            ('res_id', '=', False),\n        ])\n        if prop:\n            prop.write({'value': value})\n        else:\n            prop.create({\n                'fields_id': field_id,\n                'company_id': company_id,\n                'res_id': False,\n                'name': name,\n                'value': value,\n                'type': self.env[model]._fields[name].type,\n            })",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get",
          "params": [
            "self",
            "name",
            "model",
            "res_id=False"
          ],
          "decorators": [],
          "source": "def _get(self, name, model, res_id=False):\n        \"\"\" Get the given field's generic value for the record.\n\n        :param name: the field's name\n        :param model: the field's model name\n        :param res_id: optional resource, format: \"<id>\" (int) or\n                       \"<model>,<id>\" (str)\n        \"\"\"\n        if not res_id:\n            t, v = self._get_default_property(name, model)\n            if not v or t != 'many2one':\n                return v\n            return self.env[v[0]].browse(v[1])\n\n        p = self._get_property(name, model, res_id=res_id)\n        if p:\n            return p.get_by_record()\n        return False\n\n    # only cache Property._get(res_id=False) as that's\n    # sub-optimally.\n    COMPANY_KEY = \"self.env.company.id\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_property",
          "params": [
            "self",
            "name",
            "model"
          ],
          "decorators": [
            "@ormcache(COMPANY_KEY, 'name', 'model')"
          ],
          "source": "@ormcache(COMPANY_KEY, 'name', 'model')\n    def _get_default_property(self, name, model):\n        prop = self._get_property(name, model, res_id=False)\n        if not prop:\n            return None, False\n        v = prop.get_by_record()\n        if prop.type != 'many2one':\n            return prop.type, v\n        return 'many2one', v and (v._name, v.id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "_get_property",
          "params": [
            "self",
            "name",
            "model",
            "res_id"
          ],
          "decorators": [],
          "source": "def _get_property(self, name, model, res_id):\n        domain = self._get_domain(name, model)\n        if domain is not None:\n            if res_id and isinstance(res_id, int):\n                res_id = \"%s,%s\" % (model, res_id)\n            domain = [('res_id', '=', res_id)] + domain\n            #make the search with company_id asc to make sure that properties specific to a company are given first\n            return self.sudo().search(domain, limit=1, order='company_id')\n        return self.sudo().browse(())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_domain",
          "params": [
            "self",
            "prop_name",
            "model"
          ],
          "decorators": [],
          "source": "def _get_domain(self, prop_name, model):\n        field_id = self.env['ir.model.fields']._get(model, prop_name).id\n        if not field_id:\n            return None\n        company_id = self.env.company.id\n        return [('fields_id', '=', field_id), ('company_id', 'in', [company_id, False])]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_multi",
          "params": [
            "self",
            "name",
            "model",
            "ids"
          ],
          "decorators": [],
          "source": "def _get_multi(self, name, model, ids):\n        \"\"\" Read the property field `name` for the records of model `model` with\n            the given `ids`, and return a dictionary mapping `ids` to their\n            corresponding value.\n        \"\"\"\n        if not ids:\n            return {}\n\n        field = self.env[model]._fields[name]\n        field_id = self.env['ir.model.fields']._get(model, name).id\n        company_id = self.env.company.id or None\n\n        if field.type == 'many2one':\n            comodel = self.env[field.comodel_name]\n            model_pos = len(model) + 2\n            value_pos = len(comodel._name) + 2\n            # retrieve values: both p.res_id and p.value_reference are formatted\n            # as \"<rec._name>,<rec.id>\"; the purpose of the LEFT JOIN is to\n            # return the value id if it exists, NULL otherwise\n            query = \"\"\"\n                SELECT substr(p.res_id, %s)::integer, r.id\n                FROM ir_property p\n                LEFT JOIN {} r ON substr(p.value_reference, %s)::integer=r.id\n                WHERE p.fields_id=%s\n                    AND (p.company_id=%s OR p.company_id IS NULL)\n                    AND (p.res_id IN %s OR p.res_id IS NULL)\n                ORDER BY p.company_id NULLS FIRST\n            \"\"\".format(comodel._table)\n            params = [model_pos, value_pos, field_id, company_id]\n            clean = comodel.browse\n\n        elif field.type in TYPE2FIELD:\n            model_pos = len(model) + 2\n            # retrieve values: p.res_id is formatted as \"<rec._name>,<rec.id>\"\n            query = \"\"\"\n                SELECT substr(p.res_id, %s)::integer, p.{}\n                FROM ir_property p\n                WHERE p.fields_id=%s\n                    AND (p.company_id=%s OR p.company_id IS NULL)\n                    AND (p.res_id IN %s OR p.res_id IS NULL)\n                ORDER BY p.company_id NULLS FIRST\n            \"\"\".format(TYPE2FIELD[field.type])\n            params = [model_pos, field_id, company_id]\n            clean = TYPE2CLEAN[field.type]\n\n        else:\n            return dict.fromkeys(ids, False)\n\n        # retrieve values\n        self.flush_model()\n        cr = self.env.cr\n        result = {}\n        refs = {\"%s,%s\" % (model, id) for id in ids}\n        for sub_refs in cr.split_for_in_conditions(refs):\n            cr.execute(query, params + [sub_refs])\n            result.update(cr.fetchall())\n\n        # determine all values and format them\n        default = result.get(None, None)\n        return {\n            id: clean(result.get(id, default))\n            for id in ids\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_multi",
          "params": [
            "self",
            "name",
            "model",
            "values",
            "default_value=None"
          ],
          "decorators": [],
          "source": "def _set_multi(self, name, model, values, default_value=None):\n        \"\"\" Assign the property field `name` for the records of model `model`\n            with `values` (dictionary mapping record ids to their value).\n            If the value for a given record is the same as the default\n            value, the property entry will not be stored, to avoid bloating\n            the database.\n            If `default_value` is provided, that value will be used instead\n            of the computed default value, to determine whether the value\n            for a record should be stored or not.\n        \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "clean",
          "params": [
            "value"
          ],
          "decorators": [],
          "source": "def clean(value):\n            return value.id if isinstance(value, models.BaseModel) else value\n\n        if not values:\n            return\n\n        if default_value is None:\n            domain = self._get_domain(name, model)\n            if domain is None:\n                raise Exception()\n            # retrieve the default value for the field\n            default_value = clean(self._get(name, model))\n\n        # retrieve the properties corresponding to the given record ids\n        field_id = self.env['ir.model.fields']._get(model, name).id\n        company_id = self.env.company.id\n        refs = {('%s,%s' % (model, id)): id for id in values}\n        props = self.sudo().search([\n            ('fields_id', '=', field_id),\n            ('company_id', '=', company_id),\n            ('res_id', 'in', list(refs)),\n        ])\n\n        # modify existing properties\n        for prop in props:\n            id = refs.pop(prop.res_id)\n            value = clean(values[id])\n            if value == default_value:\n                # avoid prop.unlink(), as it clears the record cache that can\n                # contain the value of other properties to set on record!\n                self._cr.execute(\"DELETE FROM ir_property WHERE id=%s\", [prop.id])\n            elif value != clean(prop.get_by_record()):\n                prop.write({'value': value})\n\n        # create new properties for records that do not have one yet\n        vals_list = []\n        for ref, id in refs.items():\n            value = clean(values[id])\n            if value != default_value:\n                vals_list.append({\n                    'fields_id': field_id,\n                    'company_id': company_id,\n                    'res_id': ref,\n                    'name': name,\n                    'value': value,\n                    'type': self.env[model]._fields[name].type,\n                })\n        self.sudo().create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "search_multi",
          "params": [
            "self",
            "name",
            "model",
            "operator",
            "value"
          ],
          "decorators": [],
          "source": "def search_multi(self, name, model, operator, value):\n        \"\"\" Return a domain for the records that match the given condition. \"\"\"\n        default_matches = False\n        negate = False\n\n        # For \"is set\" and \"is not set\", same logic for all types\n        if operator == 'in' and False in value:\n            operator = 'not in'\n            negate = True\n        elif operator == 'not in' and False not in value:\n            operator = 'in'\n            negate = True\n        elif operator in ('!=', 'not like', 'not ilike') and value:\n            operator = TERM_OPERATORS_NEGATION[operator]\n            negate = True\n        elif operator == '=' and not value:\n            operator = '!='\n            negate = True\n\n        field = self.env[model]._fields[name]\n\n        if field.type == 'many2one':",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "makeref",
          "params": [
            "value"
          ],
          "decorators": [],
          "source": "def makeref(value):\n                return value and f'{field.comodel_name},{value}'\n\n            if operator in ('=', '!=', '<=', '<', '>', '>='):\n                value = makeref(value)\n            elif operator in ('in', 'not in'):\n                value = [makeref(v) for v in value]\n            elif operator in ('=like', '=ilike', 'like', 'not like', 'ilike', 'not ilike'):\n                # most probably inefficient... but correct\n                target = self.env[field.comodel_name]\n                target_names = target.name_search(value, operator=operator, limit=None)\n                target_ids = [n[0] for n in target_names]\n                operator, value = 'in', [makeref(v) for v in target_ids]\n            elif operator in ('any', 'not any'):\n                if operator == 'not any':\n                    negate = True\n                operator = 'in'\n                value = list(map(makeref, self.env[field.comodel_name]._search(value)))\n\n        elif field.type in ('integer', 'float'):\n            # No record is created in ir.property if the field's type is float or integer with a value\n            # equal to 0. Then to match with the records that are linked to a property field equal to 0,\n            # the negation of the operator must be taken  to compute the goods and the domain returned\n            # to match the searched records is just the opposite.\n            value = float(value) if field.type == 'float' else int(value)\n            if operator == '>=' and value <= 0:\n                operator = '<'\n                negate = True\n            elif operator == '>' and value < 0:\n                operator = '<='\n                negate = True\n            elif operator == '<=' and value >= 0:\n                operator = '>'\n                negate = True\n            elif operator == '<' and value > 0:\n                operator = '>='\n                negate = True\n\n        elif field.type == 'boolean':\n            # the value must be mapped to an integer value\n            value = int(value)\n\n        # retrieve the properties that match the condition\n        domain = self._get_domain(name, model)\n        if domain is None:\n            raise Exception()\n        props = self.search(domain + [(TYPE2FIELD[field.type], operator, value)])\n\n        # retrieve the records corresponding to the properties that match\n        good_ids = []\n        for prop in props:\n            if prop.res_id:\n                __, res_id = prop.res_id.split(',')\n                good_ids.append(int(res_id))\n            else:\n                default_matches = True\n\n        if default_matches:\n            # exclude all records with a property that does not match\n            props = self.search(domain + [('res_id', '!=', False)])\n            all_ids = {int(res_id.split(',')[1]) for res_id in props.mapped('res_id')}\n            bad_ids = list(all_ids - set(good_ids))\n            if negate:\n                return [('id', 'in', bad_ids)]\n            else:\n                return [('id', 'not in', bad_ids)]\n        elif negate:\n            return [('id', 'not in', good_ids)]\n        else:\n            return [('id', 'in', good_ids)]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_set_default (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_multi (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_set_multi (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "search_multi (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Property"
    },
    {
      "name": "ir.qweb",
      "description": "Qweb",
      "fields": [],
      "methods": [
        {
          "name": "_render",
          "params": [
            "self",
            "template",
            "values=None",
            "**options"
          ],
          "decorators": [],
          "source": "def _render(self, template, values=None, **options):\n        \"\"\" render(template, values, **options)\n\n        Render the template specified by the given name.\n\n        :param template: etree, xml_id, template name (see _get_template)\n            * Call the method ``load`` is not an etree.\n        :param dict values: template values to be used for rendering\n        :param options: used to compile the template\n            Options will be add into the IrQweb.env.context for the rendering.\n            * ``lang`` (str) used language to render the template\n            * ``inherit_branding`` (bool) add the tag node branding\n            * ``inherit_branding_auto`` (bool) add the branding on fields\n            * ``minimal_qcontext``(bool) To use the minimum context and options\n                from ``_prepare_environment``\n\n        :returns: bytes marked as markup-safe (decode to :class:`markupsafe.Markup`\n                  instead of `str`)\n        :rtype: MarkupSafe\n        \"\"\"\n        values = values.copy() if values else {}\n        if T_CALL_SLOT in values:\n            raise ValueError(f'values[{T_CALL_SLOT}] should be unset when call the _render method and only set into the template.')\n\n        irQweb = self.with_context(**options)._prepare_environment(values)\n\n        safe_eval.check_values(values)\n\n        template_functions, def_name = irQweb._compile(template)\n        render_template = template_functions[def_name]\n        rendering = render_template(irQweb, values)\n        result = ''.join(rendering)\n\n        return Markup(result)\n\n    # assume cache will be invalidated by third party on write to ir.ui.view",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_template_cache_keys",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_template_cache_keys(self):\n        \"\"\" Return the list of context keys to use for caching ``_compile``. \"\"\"\n        return ['lang', 'inherit_branding', 'inherit_branding_auto', 'edit_translations', 'profile']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_id",
          "params": [
            "self",
            "template"
          ],
          "decorators": [],
          "source": "def _get_view_id(self, template):\n        try:\n            return self.env['ir.ui.view'].sudo().with_context(load_all_views=True)._get_view_id(template)\n        except Exception:\n            return None",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile",
          "params": [
            "self",
            "template"
          ],
          "decorators": [],
          "source": "def _compile(self, template):\n        if isinstance(template, etree._Element):\n            self = self.with_context(is_t_cache_disabled=True)\n            ref = None\n        else:\n            ref = self._get_view_id(template)\n\n        # define the base key cache for code in cache and t-cache feature\n        base_key_cache = None\n        if ref:\n            base_key_cache = self._get_cache_key(tuple([ref] + [self.env.context.get(k) for k in self._get_template_cache_keys()]))\n        self = self.with_context(__qweb_base_key_cache=base_key_cache)\n\n        # generate the template functions and the root function name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "generate_functions",
          "params": [],
          "decorators": [],
          "source": "def generate_functions():\n            code, options, def_name = self._generate_code(template)\n            if self.env.context.get('profile'):\n                ref_value = None\n                with contextlib.suppress(ValueError, TypeError):\n                    ref_value = int(options.get('ref'))\n                profile_options = {\n                    'ref': ref_value,\n                    'ref_xml': options.get('ref_xml') and str(options['ref_xml']) or None,\n                }\n            else:\n                profile_options = None\n            code = '\\n'.join([\n                \"def generate_functions():\",\n                \"    template_functions = {}\",\n                indent_code(code, 1),\n                f\"    template_functions['options'] = {profile_options!r}\",\n                \"    return template_functions\",\n            ])\n\n            try:\n                compiled = compile(code, f\"<{ref}>\", 'exec')\n                globals_dict = self.__prepare_globals()\n                globals_dict['__builtins__'] = globals_dict # So that unknown/unsafe builtins are never added.\n                unsafe_eval(compiled, globals_dict)\n                return globals_dict['generate_functions'](), def_name\n            except QWebException:\n                raise\n            except Exception as e:\n                raise QWebException(\"Error when compiling xml template\",\n                    self, template, code=code, ref=ref) from e\n\n        return self._load_values(base_key_cache, generate_functions)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "generate_functions",
          "params": [],
          "decorators": [],
          "source": "def generate_functions():\",\n                \"    template_functions = {}\",\n                indent_code(code, 1),\n                f\"    template_functions['options'] = {profile_options!r}\",\n                \"    return template_functions\",\n            ])\n\n            try:\n                compiled = compile(code, f\"<{ref}>\", 'exec')\n                globals_dict = self.__prepare_globals()\n                globals_dict['__builtins__'] = globals_dict # So that unknown/unsafe builtins are never added.\n                unsafe_eval(compiled, globals_dict)\n                return globals_dict['generate_functions'](), def_name\n            except QWebException:\n                raise\n            except Exception as e:\n                raise QWebException(\"Error when compiling xml template\",\n                    self, template, code=code, ref=ref) from e\n\n        return self._load_values(base_key_cache, generate_functions)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_generate_code",
          "params": [
            "self",
            "template"
          ],
          "decorators": [],
          "source": "def _generate_code(self, template):\n        \"\"\" Compile the given template into a rendering function (generator)::\n\n            render_template(qweb, values)\n            This method can be called only by the IrQweb `_render` method or by\n            the compiled code of t-call from an other template.\n\n            An `options` dictionary is created and attached to the function. It\n            contains rendering options that are part of the cache key in\n            addition to template references.\n\n            where ``qweb`` is a QWeb instance and ``values`` are the values to\n            render.\n\n            :returns: tuple containing code, options and main method name\n        \"\"\"\n        if not isinstance(template, (int, str, etree._Element)):\n            template = str(template)\n        # The `compile_context`` dictionary includes the elements used for the\n        # cache key to which are added the template references as well as\n        # technical information useful for generating the function. This\n        # dictionary is only used when compiling the template.\n        compile_context = self.env.context.copy()\n\n        try:\n            element, document, ref = self._get_template(template)\n        except (ValueError, UserError) as e:\n            # return the error function if the template is not found or fail\n            message = str(e)\n            code = indent_code(f\"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "not_found_template",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def not_found_template(self, values):\n                    if self.env.context.get('raise_if_not_found', True):\n                        raise {e.__class__.__name__}({message!r})\n                    warning('Cannot load template %s: %s', {template!r}, {message!r})\n                    return ''\n                template_functions = {{'not_found_template': not_found_template}}\n            \"\"\", 0)\n            return (code, {}, 'not_found_template')\n\n        compile_context.pop('raise_if_not_found', None)\n\n        # reference to get xml and etree (usually the template ID)\n        compile_context['ref'] = ref\n        # reference name or key to get xml and etree (usually the template XML ID)\n        compile_context['ref_name'] = element.attrib.pop('t-name', template if isinstance(template, str) and '<' not in template else None)\n        # str xml of the reference template used for compilation. Useful for debugging, dev mode and profiling.\n        compile_context['ref_xml'] = document\n        # Identifier used to call `_compile`\n        compile_context['template'] = template\n        # Root of the etree which will be processed during compilation.\n        compile_context['root'] = element.getroottree()\n        # Reference to the last node being compiled. It is mainly used for debugging and displaying error messages.\n        compile_context['_qweb_error_path_xml'] = None\n\n        compile_context['nsmap'] = {\n            ns_prefix: str(ns_definition)\n            for ns_prefix, ns_definition in compile_context.get('nsmap', {}).items()\n        }\n\n        # The options dictionary includes cache key elements and template\n        # references. It will be attached to the generated function. This\n        # dictionary is only there for logs, performance or test information.\n        # The values of these `options` cannot be changed and must always be\n        # identical in `context` and `self.env.context`.\n        options = {k: compile_context.get(k) for k in self._get_template_cache_keys() + ['ref', 'ref_name', 'ref_xml']}\n\n        # generate code\n\n        def_name = TO_VARNAME_REGEXP.sub(r'_', f'template_{ref}')\n\n        name_gen = count()\n        compile_context['make_name'] = lambda prefix: f\"{def_name}_{prefix}_{next(name_gen)}\"\n\n        try:\n            if element.text:\n                element.text = FIRST_RSTRIP_REGEXP.sub(r'\\2', element.text)\n\n            compile_context['template_functions'] = {}\n\n            compile_context['_text_concat'] = []\n            self._append_text(\"\", compile_context) # To ensure the template function is a generator and doesn't become a regular function\n            compile_context['template_functions'][f'{def_name}_content'] = (\n                [f\"def {def_name}_content(self, values):\"]\n                + self._compile_node(element, compile_context, 2)\n                + self._flush_text(compile_context, 2, rstrip=True))\n\n            compile_context['template_functions'][def_name] = [indent_code(f\"\"\"\n                def {def_name}(self, values):\n                    try:\n                        if '__qweb_loaded_values' not in values:\n                            values['__qweb_loaded_values'] = {{}}\n                            values['__qweb_root_values'] = values.copy()\n                            values['xmlid'] = {options['ref_name']!r}\n                            values['viewid'] = {options['ref']!r}\n                        values['__qweb_loaded_values'].update(template_functions)\n\n                        yield from {def_name}_content(self, values)\n                    except QWebException:\n                        raise\n                    except Exception as e:\n                        if isinstance(e, TransactionRollbackError):\n                            raise\n                        raise QWebException(\"Error while render the template\",\n                            self, template, ref={compile_context['ref']!r}, code=code) from e\n                    \"\"\", 0)]\n        except QWebException:\n            raise\n        except Exception as e:\n            raise QWebException(\"Error when compiling xml template\",\n                self, template, ref=compile_context['ref'], path_xml=compile_context['_qweb_error_path_xml']) from e\n\n        code_lines = ['code = None']\n        code_lines.append(f'template = {(document if isinstance(template, etree._Element) else template)!r}')\n        code_lines.append('template_functions = {}')\n\n        for lines in compile_context['template_functions'].values():\n            code_lines.extend(lines)\n\n        for name in compile_context['template_functions']:\n            code_lines.append(f'template_functions[{name!r}] = {name}')\n\n        code = '\\n'.join(code_lines)\n        code += f'\\n\\ncode = {code!r}'\n\n        return (code, options, def_name)\n\n    # read and load input template",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_template",
          "params": [
            "self",
            "template"
          ],
          "decorators": [],
          "source": "def _get_template(self, template):\n        \"\"\" Retrieve the given template, and return it as a tuple ``(etree,\n        xml, ref)``, where ``element`` is an etree, ``document`` is the\n        string document that contains ``element``, and ``ref`` if the uniq\n        reference of the template (id, t-name or template).\n\n        :param template: template identifier or etree\n        \"\"\"\n        assert template not in (False, None, \"\"), \"template is required\"\n\n        # template is an xml etree already\n        if isinstance(template, etree._Element):\n            element = template\n            document = etree.tostring(template, encoding='unicode')\n            ref = None\n        # template is xml as string\n        elif isinstance(template, str) and '<' in template:\n            raise ValueError('Inline templates must be passed as `etree` documents')\n\n        # template is (id or ref) to a database stored template\n        else:\n            try:\n                ref_alias = int(template)  # e.g. <t t-call=\"33\"/>\n            except ValueError:\n                ref_alias = template  # e.g. web.layout\n\n            doc_or_elem, ref = self._load(ref_alias) or (None, None)\n            if doc_or_elem is None:\n                raise ValueError(f\"Can not load template: {ref_alias!r}\")\n            if isinstance(doc_or_elem, etree._Element):\n                element = doc_or_elem\n                document = etree.tostring(doc_or_elem, encoding='unicode')\n            elif isinstance(doc_or_elem, str):\n                element = etree.fromstring(doc_or_elem)\n                document = doc_or_elem\n            else:\n                raise TypeError(f\"Loaded template {ref!r} should be a string.\")\n\n        # return etree, document and ref, or try to find the ref\n        if ref:\n            return (element, document, ref)\n\n        # <templates>\n        #   <template t-name=... /> <!-- return ONLY this element -->\n        #   <template t-name=... />\n        # </templates>\n        for node in element.iter():\n            ref = node.get('t-name')\n            if ref:\n                return (node, document, ref)\n\n        # use the document itself as ref when no t-name was found\n        return (element, document, document)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load",
          "params": [
            "self",
            "ref"
          ],
          "decorators": [],
          "source": "def _load(self, ref):\n        \"\"\"\n        Load the template referenced by ``ref``.\n\n        :returns: The loaded template (as string or etree) and its\n            identifier\n        :rtype: Tuple[Union[etree, str], Optional[str, int]]\n        \"\"\"\n        IrUIView = self.env['ir.ui.view'].sudo()\n        view = IrUIView._get(ref)\n        template = IrUIView._read_template(view.id)\n        etree_view = etree.fromstring(template)\n\n        xmlid = view.key or ref\n        if isinstance(ref, int):\n            domain = [('model', '=', 'ir.ui.view'), ('res_id', '=', view.id)]\n            model_data = self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name'], limit=1)\n            if model_data:\n                xmlid = f\"{model_data[0]['module']}.{model_data[0]['name']}\"\n\n        # QWeb's ``_read_template`` will check if one of the first children of\n        # what we send to it has a \"t-name\" attribute having ``ref`` as value\n        # to consider it has found it. As it'll never be the case when working\n        # with view ids or children view or children primary views, force it here.\n        if view.inherit_id is not None:\n            for node in etree_view:\n                if node.get('t-name') == str(ref) or node.get('t-name') == str(view.key):\n                    node.attrib.pop('name', None)\n                    node.attrib.pop('id', None)\n                    etree_view = node\n                    break\n        etree_view.set('t-name', str(xmlid))\n        return (etree_view, view.id)\n\n    # values for running time",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_converted_image_data_uri",
          "params": [
            "self",
            "base64_source"
          ],
          "decorators": [],
          "source": "def _get_converted_image_data_uri(self, base64_source):\n        if self.env.context.get('webp_as_jpg'):\n            mimetype = FILETYPE_BASE64_MAGICWORD.get(base64_source[:1], 'png')\n            if 'webp' in mimetype:\n                # Use converted image so that is recognized by wkhtmltopdf.\n                bin_source = base64.b64decode(base64_source)\n                Attachment = self.env['ir.attachment']\n                checksum = Attachment._compute_checksum(bin_source)\n                origins = Attachment.sudo().search([\n                    ['id', '!=', False],  # No implicit condition on res_field.\n                    ['checksum', '=', checksum],\n                ])\n                if origins:\n                    converted_domain = [\n                        ['id', '!=', False],  # No implicit condition on res_field.\n                        ['res_model', '=', 'ir.attachment'],\n                        ['res_id', 'in', origins.ids],\n                        ['mimetype', '=', 'image/jpeg'],\n                    ]\n                    converted = Attachment.sudo().search(converted_domain, limit=1)\n                    if converted:\n                        base64_source = converted.datas\n        return image_data_uri(base64_source)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_prepare_environment",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _prepare_environment(self, values):\n        \"\"\" Prepare the values and context that will sent to the\n        compiled and evaluated function.\n\n        :param values: template values to be used for rendering\n\n        :returns self (with new context)\n        \"\"\"\n        debug = request and request.session.debug or ''\n        values.update(\n            true=True,\n            false=False,\n        )\n        if not self.env.context.get('minimal_qcontext'):\n            values.setdefault('debug', debug)\n            values.setdefault('user_id', self.env.user.with_env(self.env))\n            values.setdefault('res_company', self.env.company.sudo())\n            values.update(\n                request=request,  # might be unbound if we're not in an httprequest context\n                test_mode_enabled=bool(config['test_enable'] or config['test_file']),\n                json=scriptsafe,\n                quote_plus=werkzeug.urls.url_quote_plus,\n                time=safe_eval.time,\n                datetime=safe_eval.datetime,\n                relativedelta=relativedelta,\n                image_data_uri=self._get_converted_image_data_uri,\n                # specific 'math' functions to ease rounding in templates and lessen controller marshmalling\n                floor=math.floor,\n                ceil=math.ceil,\n                env=self.env,\n                lang=self.env.context.get('lang'),\n                keep_query=keep_query,\n            )\n\n        context = {'dev_mode': 'qweb' in tools.config['dev_mode']}\n        if 'xml' in tools.config['dev_mode']:\n            context['is_t_cache_disabled'] = True\n        elif 'disable-t-cache' in debug:\n            context['is_t_cache_disabled'] = True\n        return self.with_context(**context)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "__prepare_globals",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def __prepare_globals(self):\n        \"\"\" Prepare the global context that will sent to eval the qweb\n        generated code.\n        \"\"\"\n        return {\n            'Sized': Sized,\n            'Mapping': Mapping,\n            'Markup': Markup,\n            'escape': escape,\n            'VOID_ELEMENTS': VOID_ELEMENTS,\n            'QWebException': QWebException,\n            'Exception': Exception,\n            'TransactionRollbackError': TransactionRollbackError, # for SerializationFailure in assets\n            'ValueError': ValueError,\n            'UserError': UserError,\n            'AccessDenied': AccessDenied,\n            'AccessError': AccessError,\n            'MissingError': MissingError,\n            'ValidationError': ValidationError,\n            'warning': lambda *args: _logger.warning(*args),\n            **_BUILTINS,\n        }\n\n    # helpers for compilation",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_append_text",
          "params": [
            "self",
            "text",
            "compile_context"
          ],
          "decorators": [],
          "source": "def _append_text(self, text, compile_context):\n        \"\"\" Add an item (converts to a string) to the list.\n            This will be concatenated and added during a call to the\n            `_flush_text` method. This makes it possible to return only one\n            yield containing all the parts.\"\"\"\n        compile_context['_text_concat'].append(self._compile_to_str(text))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_rstrip_text",
          "params": [
            "self",
            "compile_context"
          ],
          "decorators": [],
          "source": "def _rstrip_text(self, compile_context):\n        \"\"\" The text to flush is right stripped, and the stripped content are\n        returned.\n        \"\"\"\n        text_concat = compile_context['_text_concat']\n        if not text_concat:\n            return ''\n\n        result = RSTRIP_REGEXP.search(text_concat[-1])\n        strip = result.group(0) if result else ''\n        text_concat[-1] = RSTRIP_REGEXP.sub('', text_concat[-1])\n\n        return strip",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_flush_text",
          "params": [
            "self",
            "compile_context",
            "level",
            "rstrip=False"
          ],
          "decorators": [],
          "source": "def _flush_text(self, compile_context, level, rstrip=False):\n        \"\"\"Concatenate all the textual chunks added by the `_append_text`\n            method into a single yield.\n            If no text to flush, return an empty list\n\n            If rstrip the text is right stripped.",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_static_node",
          "params": [
            "self",
            "el",
            "compile_context"
          ],
          "decorators": [],
          "source": "def _is_static_node(self, el, compile_context):\n        \"\"\" Test whether the given element is purely static, i.e. (there\n        are no t-* attributes), does not require dynamic rendering for its\n        attributes.\n        \"\"\"\n        return el.tag != 't' and 'groups' not in el.attrib and not any(\n            att.startswith('t-') and att not in ('t-tag-open', 't-inner-content')\n            for att in el.attrib\n        )\n\n    # compile python expression and format string",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_format",
          "params": [
            "self",
            "expr"
          ],
          "decorators": [],
          "source": "def _compile_format(self, expr):\n        \"\"\" Parses the provided format string and compiles it to a single\n        expression python, uses string with format method.\n        Use format is faster to concat string and values.\n        \"\"\"\n        # <t t-setf-name=\"Hello #{world} %s !\"/>\n        # =>\n        # values['name'] = 'Hello %s %%s !' % (values['world'],)\n        values = [\n            f'self._compile_to_str({self._compile_expr(m.group(1) or m.group(2))})'\n            for m in FORMAT_REGEX.finditer(expr)\n        ]\n        code = repr(FORMAT_REGEX.sub('%s', expr.replace('%', '%%')))\n        if values:\n            code += f' % ({\", \".join(values)},)'\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_expr_tokens",
          "params": [
            "self",
            "tokens",
            "allowed_keys",
            "argument_names=None",
            "raise_on_missing=False"
          ],
          "decorators": [],
          "source": "def _compile_expr_tokens(self, tokens, allowed_keys, argument_names=None, raise_on_missing=False):\n        \"\"\" Transform the list of token coming into a python instruction in\n            textual form by adding the namepaces for the dynamic values.\n\n            Example: `5 + a + b.c` to be `5 + values.get('a') + values['b'].c`\n            Unknown values are considered to be None, but using `values['b']`\n            gives a clear error message in cases where there is an attribute for\n            example (have a `KeyError: 'b'`, instead of `AttributeError: 'NoneType'\n            object has no attribute 'c'`).",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_expr",
          "params": [
            "self",
            "expr",
            "raise_on_missing=False"
          ],
          "decorators": [],
          "source": "def _compile_expr(self, expr, raise_on_missing=False):\n        \"\"\"Transform string coming into a python instruction in textual form by\n        adding the namepaces for the dynamic values.\n        This method tokenize the string and call ``_compile_expr_tokens``\n        method.\n\n        :param expr: string: python expression\n        :param [raise_on_missing]: boolean:\n            Compile has `values['product'].price` instead of\n            `values.get('product').price` to raise an error when get the\n            'product' value and not an 'NoneType' object has no attribute\n            'price' error.\n        \"\"\"\n        # Parentheses are useful for compiling multi-line expressions such as\n        # conditions existing in some templates. (see test_compile_expr tests)\n        readable = io.BytesIO(f\"({expr or ''})\".encode('utf-8'))\n        try:\n            tokens = list(tokenize.tokenize(readable.readline))\n        except tokenize.TokenError:\n            raise ValueError(f\"Can not compile expression: {expr}\")\n\n        expression = self._compile_expr_tokens(tokens, ALLOWED_KEYWORD, raise_on_missing=raise_on_missing)\n\n        assert_valid_codeobj(_SAFE_QWEB_OPCODES, compile(expression, '<>', 'eval'), expr)\n\n        return f\"({expression})\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_bool",
          "params": [
            "self",
            "attr",
            "default=False"
          ],
          "decorators": [],
          "source": "def _compile_bool(self, attr, default=False):\n        \"\"\"Convert the statements as a boolean.\"\"\"\n        if attr:\n            if attr is True:\n                return True\n            attr = attr.lower()\n            if attr in ('false', '0'):\n                return False\n            elif attr in ('true', '1'):\n                return True\n        return bool(default)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_to_str",
          "params": [
            "self",
            "expr"
          ],
          "decorators": [],
          "source": "def _compile_to_str(self, expr):\n        \"\"\" Generates a text value (an instance of text_type) from an arbitrary\n            source.\n        \"\"\"\n        return pycompat.to_text(expr)\n\n    # order",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_directives_eval_order",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _directives_eval_order(self):\n        \"\"\" List all supported directives in the order in which they should be\n        evaluated on a given element. For instance, a node bearing both\n        ``foreach`` and ``if`` should see ``foreach`` executed before ``if`` aka\n        .. code-block:: xml\n            <el t-foreach=\"foo\" t-as=\"bar\" t-if=\"bar\">\n        should be equivalent to\n        .. code-block:: xml\n            <t t-foreach=\"foo\" t-as=\"bar\">\n                <t t-if=\"bar\">\n                    <el>\n        then this method should return ``['foreach', 'if']``.\n        \"\"\"\n        return [\n            'elif', # Must be the first because compiled by the previous if.\n            'else', # Must be the first because compiled by the previous if.\n            'debug',\n            'nocache',\n            'cache',\n            'groups',\n            'as', 'foreach',\n            'if',\n            'call-assets',\n            'lang',\n            'options',\n            'att',\n            'field', 'esc', 'raw', 'out',\n            'tag-open',\n            'call',\n            'set',\n            'inner-content',\n            'tag-close',\n        ]\n\n    # compile",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_node",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_node(self, el, compile_context, level):\n        \"\"\" Compile the given element into python code.\n\n            The t-* attributes (directives) will be converted to a python instruction. If there\n            are no t-* attributes, the element will be considered static.\n\n            Directives are compiled using the order provided by the\n            ``_directives_eval_order`` method (an create the\n            ``compile_context['iter_directives']`` iterator).\n            For compilation, the directives supported are those with a\n            compilation method ``_compile_directive_*``\n\n        :return: list of string\n        \"\"\"\n        # Internal directive used to skip a rendering.\n        if 't-qweb-skip' in el.attrib:\n            return []\n\n        # if tag don't have qweb attributes don't use directives\n        if self._is_static_node(el, compile_context):\n            return self._compile_static_node(el, compile_context, level)\n\n        path = compile_context['root'].getpath(el)\n        xml = etree.tostring(etree.Element(el.tag, el.attrib), encoding='unicode')\n        compile_context['_qweb_error_path_xml'] = (path, xml)\n        body = [indent_code(f'# element: {path!r} , {xml!r}', level)]\n\n        # create an iterator on directives to compile in order\n        compile_context['iter_directives'] = iter(self._directives_eval_order())\n\n        # add technical directive tag-open, tag-close, inner-content and take\n        # care of the namspace\n        if not el.nsmap:\n            unqualified_el_tag = el_tag = el.tag\n        else:\n            # Etree will remove the ns prefixes indirection by inlining the corresponding\n            # nsmap definition into the tag attribute. Restore the tag and prefix here.\n            # Note: we do not support namespace dynamic attributes, we need a default URI\n            # on the root and use attribute directive t-att=\"{'xmlns:example': value}\".\n            unqualified_el_tag = etree.QName(el.tag).localname\n            el_tag = unqualified_el_tag\n            if el.prefix:\n                el_tag = f'{el.prefix}:{el_tag}'\n\n        if unqualified_el_tag != 't':\n            el.set('t-tag-open', el_tag)\n            if el_tag not in VOID_ELEMENTS:\n                el.set('t-tag-close', el_tag)\n\n        if not ({'t-out', 't-esc', 't-raw', 't-field'} & set(el.attrib)):\n            el.set('t-inner-content', 'True')\n\n        return body + self._compile_directives(el, compile_context, level)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_static_node",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_static_node(self, el, compile_context, level):\n        \"\"\" Compile a purely static element into a list of string. \"\"\"\n        if not el.nsmap:\n            unqualified_el_tag = el_tag = el.tag\n            attrib = self._post_processing_att(el.tag, el.attrib)\n        else:\n            # Etree will remove the ns prefixes indirection by inlining the corresponding\n            # nsmap definition into the tag attribute. Restore the tag and prefix here.\n            unqualified_el_tag = etree.QName(el.tag).localname\n            el_tag = unqualified_el_tag\n            if el.prefix:\n                el_tag = f'{el.prefix}:{el_tag}'\n\n            attrib = {}\n            # If `el` introduced new namespaces, write them as attribute by using the\n            # `attrib` dict.\n            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(compile_context['nsmap'].items()):\n                if ns_prefix is None:\n                    attrib['xmlns'] = ns_definition\n                else:\n                    attrib[f'xmlns:{ns_prefix}'] = ns_definition\n\n            # Etree will also remove the ns prefixes indirection in the attributes. As we only have\n            # the namespace definition, we'll use an nsmap where the keys are the definitions and\n            # the values the prefixes in order to get back the right prefix and restore it.\n            ns = chain(compile_context['nsmap'].items(), el.nsmap.items())\n            nsprefixmap = {v: k for k, v in ns}\n            for key, value in el.attrib.items():\n                attrib_qname = etree.QName(key)\n                if attrib_qname.namespace:\n                    attrib[f'{nsprefixmap[attrib_qname.namespace]}:{attrib_qname.localname}'] = value\n                else:\n                    attrib[key] = value\n\n            attrib = self._post_processing_att(el.tag, attrib)\n\n            # Update the dict of inherited namespaces before continuing the recursion. Note:\n            # since `compile_context['nsmap']` is a dict (and therefore mutable) and we do **not**\n            # want changes done in deeper recursion to bevisible in earlier ones, we'll pass\n            # a copy before continuing the recursion and restore the original afterwards.\n            original_nsmap = dict(compile_context['nsmap'])\n\n        if unqualified_el_tag != 't':\n            attributes = ''.join(f' {name}=\"{escape(str(value))}\"'\n                                for name, value in attrib.items() if value or isinstance(value, str))\n            self._append_text(f'<{el_tag}{\"\".join(attributes)}', compile_context)\n            if el_tag in VOID_ELEMENTS:\n                self._append_text('/>', compile_context)\n            else:\n                self._append_text('>', compile_context)\n\n        el.attrib.clear()\n\n        if el.nsmap:\n            compile_context['nsmap'].update(el.nsmap)\n            body = self._compile_directive(el, compile_context, 'inner-content', level)\n            compile_context['nsmap'] = original_nsmap\n        else:\n            body = self._compile_directive(el, compile_context, 'inner-content', level)\n\n        if unqualified_el_tag != 't':\n            if el_tag not in VOID_ELEMENTS:\n                self._append_text(f'</{el_tag}>', compile_context)\n\n        return body",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directives",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directives(self, el, compile_context, level):\n        \"\"\" Compile the given element, following the directives given in the\n        iterator ``compile_context['iter_directives']`` create by\n        `_compile_node`` method.\n\n        :return: list of code lines\n        \"\"\"\n        if self._is_static_node(el, compile_context):\n            el.attrib.pop('t-tag-open', None)\n            el.attrib.pop('t-inner-content', None)\n            el.attrib.pop('t-tag-close', None)\n            return self._compile_static_node(el, compile_context, level)\n\n        code = []\n\n        # compile the directives still present on the element\n        for directive in compile_context['iter_directives']:\n            if ('t-' + directive) in el.attrib:\n                code.extend(self._compile_directive(el, compile_context, directive, level))\n            elif directive == 'groups':\n                if directive in el.attrib:\n                    code.extend(self._compile_directive(el, compile_context, directive, level))\n            elif directive == 'att':\n                code.extend(self._compile_directive(el, compile_context, directive, level))\n            elif directive == 'options':\n                if any(name.startswith('t-options-') for name in el.attrib):\n                    code.extend(self._compile_directive(el, compile_context, directive, level))\n            elif directive == 'nocache':\n                if any(name.startswith('t-nocache-') for name in el.attrib):\n                    code.extend(self._compile_directive(el, compile_context, directive, level))\n\n        # compile unordered directives still present on the element\n        for att in el.attrib:\n            if att not in SPECIAL_DIRECTIVES and att.startswith('t-') and getattr(self, f\"_compile_directive_{att[2:].replace('-', '_')}\", None):\n                code.extend(self._compile_directive(el, compile_context, directive, level))\n\n        remaining = set(el.attrib) - SPECIAL_DIRECTIVES\n        if remaining:\n            _logger.warning('Unknown directives or unused attributes: %s in %s', remaining, compile_context['template'])\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive",
          "params": [
            "self",
            "el",
            "compile_context",
            "directive",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive(self, el, compile_context, directive, level):\n        compile_handler = getattr(self, f\"_compile_directive_{directive.replace('-', '_')}\", None)\n        return compile_handler(el, compile_context, level)\n\n    # compile directives",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_debug",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_debug(self, el, compile_context, level):\n        \"\"\"Compile `t-debug` expressions into a python code as a list of\n        strings.\n\n        The code will contains the call to the debugger chosen from the valid\n        list.\n        \"\"\"\n        debugger = el.attrib.pop('t-debug')\n        code = []\n        if compile_context.get('dev_mode'):\n            code.append(indent_code(f\"self._debug_trace({debugger!r}, values)\", level))\n        else:\n            _logger.warning(\"@t-debug in template is only available in qweb dev mode\")\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_options",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_options(self, el, compile_context, level):\n        \"\"\"\n        compile t-options and add to the dict the t-options-xxx. Will create\n        the dictionary ``values['__qweb_options__']`` in compiled code.\n        \"\"\"\n        code = []\n        dict_options = []\n        for key in list(el.attrib):\n            if key.startswith('t-options-'):\n                value = el.attrib.pop(key)\n                option_name = key[10:]\n                dict_options.append(f'{option_name!r}:{self._compile_expr(value)}')\n\n        t_options = el.attrib.pop('t-options', None)\n        if t_options and dict_options:\n            code.append(indent_code(f\"values['__qweb_options__'] = {{**{self._compile_expr(t_options)}, {', '.join(dict_options)}}}\", level))\n        elif dict_options:\n            code.append(indent_code(f\"values['__qweb_options__'] = {{{', '.join(dict_options)}}}\", level))\n        elif t_options:\n            code.append(indent_code(f\"values['__qweb_options__'] = {self._compile_expr(t_options)}\", level))\n        else:\n            code.append(indent_code(\"values['__qweb_options__'] = {}\", level))\n\n        el.set('t-consumed-options', str(bool(code)))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_consumed_options",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_consumed_options(self, el, compile_context, level):\n        raise SyntaxError('the t-options must be on the same tag as a directive that consumes it (for example: t-out, t-field, t-call)')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_att",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_att(self, el, compile_context, level):\n        \"\"\" Compile the attributes of the given elements.\n\n        The compiled function will create the ``values['__qweb_attrs__']``\n        dictionary. Then the dictionary will be output.\n\n\n        The new namespaces of the current element.\n\n        The static attributes (not prefixed by ``t-``) are add to the\n        dictionary in first.\n\n        The dynamic attributes values will be add after. The dynamic\n        attributes has different origins.\n        - value from key equal to ``t-att``: python dictionary expression;\n        - value from keys that start with ``t-att-``: python expression;\n        - value from keys that start with ``t-attf-``: format string\n            expression.\n        \"\"\"\n        code = [indent_code(\"attrs = values['__qweb_attrs__'] = {}\", level)]\n\n        # Compile the introduced new namespaces of the given element.\n        #\n        # Add the found new attributes into the `attrs` dictionary like\n        # the static attributes.\n        if el.nsmap:\n            for ns_prefix, ns_definition in set(el.nsmap.items()) - set(compile_context['nsmap'].items()):\n                key = 'xmlns'\n                if ns_prefix is not None:\n                    key = f'xmlns:{ns_prefix}'\n                code.append(indent_code(f'attrs[{key!r}] = {ns_definition!r}', level))\n\n        # Compile the static attributes of the given element.\n        #\n        # Etree will also remove the ns prefixes indirection in the\n        # attributes. As we only have the namespace definition, we'll use\n        # an nsmap where the keys are the definitions and the values the\n        # prefixes in order to get back the right prefix and restore it.\n        if any(not name.startswith('t-') for name in el.attrib):\n            nsprefixmap = {v: k for k, v in chain(compile_context['nsmap'].items(), el.nsmap.items())}\n            for key in list(el.attrib):\n                if not key.startswith('t-'):\n                    value = el.attrib.pop(key)\n                    attrib_qname = etree.QName(key)\n                    if attrib_qname.namespace:\n                        key = f'{nsprefixmap[attrib_qname.namespace]}:{attrib_qname.localname}'\n                    code.append(indent_code(f'attrs[{key!r}] = {value!r}', level))\n\n        # Compile the dynamic attributes of the given element. All\n        # attributes will be add to the ``attrs`` dictionary in the\n        # compiled function.\n        for key in list(el.attrib):\n            if key.startswith('t-attf-'):\n                value = el.attrib.pop(key)\n                code.append(indent_code(f\"attrs[{key[7:]!r}] = {self._compile_format(value)}\", level))\n            elif key.startswith('t-att-'):\n                value = el.attrib.pop(key)\n                code.append(indent_code(f\"attrs[{key[6:]!r}] = {self._compile_expr(value)}\", level))\n            elif key == 't-att':\n                value = el.attrib.pop(key)\n                code.append(indent_code(f\"\"\"\n                    atts_value = {self._compile_expr(value)}\n                    if isinstance(atts_value, dict):\n                        attrs.update(atts_value)\n                    elif isinstance(atts_value, (list, tuple)) and not isinstance(atts_value[0], (list, tuple)):\n                        attrs.update([atts_value])\n                    elif isinstance(atts_value, (list, tuple)):\n                        attrs.update(dict(atts_value))\n                    \"\"\", level))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_tag_open",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_tag_open(self, el, compile_context, level):\n        \"\"\" Compile the opening tag with attributes of the given element into\n        a list of python code line.\n\n        The compiled function will fill the ``attrs`` dictionary. Then the\n        ``attrs`` dictionary will be output and reset the value of ``attrs``.\n\n        The static attributes (not prefixed by ``t-``) are add to the\n        ``attrs`` dictionary in first.\n\n        The dynamic attributes values will be add after. The dynamic\n        attributes has different origins.\n        - value from key equal to ``t-att``: python dictionary expression;\n        - value from keys that start with ``t-att-``: python expression;\n        - value from keys that start with ``t-attf-``: format string\n            expression.\n        \"\"\"\n\n        el_tag = el.attrib.pop('t-tag-open', None)\n        if not el_tag:\n            return []\n\n        # open the open tag\n        self._append_text(f\"<{el_tag}\", compile_context)\n\n        code = self._flush_text(compile_context, level)\n\n        # Generates the part of the code that prost process and output the\n        # attributes from ``attrs`` dictionary. Consumes `attrs` dictionary\n        # and reset it.\n        #\n        # Use str(value) to change Markup into str and escape it, then use str\n        # to avoid the escaping of the other html content.\n        code.append(indent_code(f\"\"\"\n            attrs = values.pop('__qweb_attrs__', None)\n            if attrs:\n                tagName = {el.tag!r}\n                attrs = self._post_processing_att(tagName, attrs)\n                for name, value in attrs.items():\n                    if value or isinstance(value, str):\n                        yield f' {{escape(str(name))}}=\"{{escape(str(value))}}\"'\n        \"\"\", level))\n\n        # close the open tag\n        if 't-tag-close' in el.attrib:\n            self._append_text('>', compile_context)\n        else:\n            self._append_text('/>', compile_context)\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_tag_close",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_tag_close(self, el, compile_context, level):\n        \"\"\" Compile the closing tag of the given element into string.\n        Returns an empty list because it's use only `_append_text`.\n        \"\"\"\n        el_tag = el.attrib.pop(\"t-tag-close\", None)\n        if el_tag:\n            self._append_text(f'</{el_tag}>', compile_context)\n        return []",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_set",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_set(self, el, compile_context, level):\n        \"\"\"Compile `t-set` expressions into a python code as a list of\n        strings.\n\n        There are 3 kinds of `t-set`:\n        * `t-value` containing python code;\n        * `t-valuef` containing strings to format;\n        * whose value is the content of the tag (being Markup safe).\n\n        The code will contain the assignment of the dynamically generated value.\n        \"\"\"\n\n        code = self._flush_text(compile_context, level, rstrip=el.tag.lower() == 't')\n\n        if 't-set' in el.attrib:\n            varname = el.attrib.pop('t-set')\n            if varname == \"\":\n                raise KeyError('t-set')\n            if varname != T_CALL_SLOT and varname[0] != '{' and not VARNAME_REGEXP.match(varname):\n                raise ValueError('The varname can only contain alphanumeric characters and underscores.')\n\n            if 't-value' in el.attrib or 't-valuef' in el.attrib or varname[0] == '{':\n                el.attrib.pop('t-inner-content') # The content is considered empty.\n                if varname == T_CALL_SLOT:\n                    raise SyntaxError('t-set=\"0\" should not be set from t-value or t-valuef')\n\n            if 't-value' in el.attrib:\n                expr = el.attrib.pop('t-value') or 'None'\n                code.append(indent_code(f\"values[{varname!r}] = {self._compile_expr(expr)}\", level))\n            elif 't-valuef' in el.attrib:\n                exprf = el.attrib.pop('t-valuef')\n                code.append(indent_code(f\"values[{varname!r}] = {self._compile_format(exprf)}\", level))\n            elif varname[0] == '{':\n                code.append(indent_code(f\"values.update({self._compile_expr(varname)})\", level))\n            else:\n                # set the content as value\n                content = (\n                    self._compile_directive(el, compile_context, 'inner-content', 1) +\n                    self._flush_text(compile_context, 1))\n                if content:\n                    def_name = compile_context['make_name']('t_set')\n                    compile_context['template_functions'][def_name] = [f\"def {def_name}(self, values):\"] + content\n                    code.append(indent_code(f\"\"\"\n                            t_set = []\n                            for item in {def_name}(self, values):\n                                if isinstance(item, str):\n                                    t_set.append(item)\n                                else:\n                                    ref, function_name, cached_values = item\n                                    t_nocache_function = values['__qweb_loaded_values'].get(function_name)\n                                    if not t_nocache_function:\n                                        t_call_template_functions, def_name = self._compile(ref)\n                                        t_nocache_function = t_call_template_functions[function_name]\n\n                                    nocache_values = values['__qweb_root_values'].copy()\n                                    nocache_values.update(cached_values)\n                                    t_set.extend(t_nocache_function(self, nocache_values))\n                        \"\"\", level))\n                    expr = \"Markup(''.join(t_set))\"\n                else:\n                    expr = \"''\"\n                code.append(indent_code(f\"values[{varname!r}] = {expr}\", level))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_value",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_value(self, el, compile_context, level):\n        \"\"\"Compile `t-value` expressions into a python code as a list of strings.\n\n        This method only check if this attributes is on the same node of a\n         `t-set` attribute.\n        \"\"\"\n        raise SyntaxError(\"t-value must be on the same node of t-set\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_valuef",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_valuef(self, el, compile_context, level):\n        \"\"\"Compile `t-valuef` expressions into a python code as a list of strings.\n\n        This method only check if this attributes is on the same node of a\n         `t-set` attribute.\n        \"\"\"\n        raise SyntaxError(\"t-valuef must be on the same node of t-set\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_inner_content",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_inner_content(self, el, compile_context, level):\n        \"\"\"Compiles the content of the element (is the technical `t-inner-content`\n        directive created by QWeb) into a python code as a list of\n        strings.\n\n        The code will contains the text content of the node or the compliled\n        code from the recursive call of ``_compile_node``.\n        \"\"\"\n        el.attrib.pop('t-inner-content', None)\n\n        if el.nsmap:\n            # Update the dict of inherited namespaces before continuing the recursion. Note:\n            # since `compile_context['nsmap']` is a dict (and therefore mutable) and we do **not**\n            # want changes done in deeper recursion to bevisible in earlier ones, we'll pass\n            # a copy before continuing the recursion and restore the original afterwards.\n            compile_context = dict(compile_context, nsmap=el.nsmap)\n\n        if el.text is not None:\n            self._append_text(el.text, compile_context)\n        body = []\n        for item in el:\n            if isinstance(item, etree._Comment):\n                if compile_context.get('preserve_comments'):\n                    self._append_text(f\"<!--{item.text}-->\", compile_context)\n            elif isinstance(item, etree._ProcessingInstruction):\n                if compile_context.get('preserve_comments'):\n                    self._append_text(f\"<?{item.target} {item.text}?>\", compile_context)\n            else:\n                body.extend(self._compile_node(item, compile_context, level))\n            # comments can also contains tail text\n            if item.tail is not None:\n                self._append_text(item.tail, compile_context)\n        return body",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_if",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_if(self, el, compile_context, level):\n        \"\"\"Compile `t-if` expressions into a python code as a list of strings.\n\n        The code will contain the condition `if`, `else` and `elif` part that\n        wrap the rest of the compiled code of this element.\n        \"\"\"\n        expr = el.attrib.pop('t-if', el.attrib.pop('t-elif', None))\n\n        assert not expr.isspace(), 't-if or t-elif expression should not be empty.'\n\n        strip = self._rstrip_text(compile_context)  # the withspaces is visible only when display a content\n        if el.tag.lower() == 't' and el.text and LSTRIP_REGEXP.search(el.text):\n            strip = ''  # remove technical spaces\n        code = self._flush_text(compile_context, level)\n\n        code.append(indent_code(f\"if {self._compile_expr(expr)}:\", level))\n        body = []\n        if strip:\n            self._append_text(strip, compile_context)\n        body.extend(\n            self._compile_directives(el, compile_context, level + 1) +\n            self._flush_text(compile_context, level + 1, rstrip=True))\n        code.extend(body or [indent_code('pass', level + 1)])\n\n        # Look for the else or elif conditions\n        next_el = el.getnext()\n        comments_to_remove = []\n        while isinstance(next_el, etree._Comment):\n            comments_to_remove.append(next_el)\n            next_el = next_el.getnext()\n\n        # If there is a t-else directive, the comment nodes are deleted\n        # and the t-else or t-elif is validated.\n        if next_el is not None and {'t-else', 't-elif'} & set(next_el.attrib):\n            # Insert a flag to allow t-else or t-elif rendering.\n            next_el.attrib['t-else-valid'] = 'True'\n\n            # remove comment node\n            parent = el.getparent()\n            for comment in comments_to_remove:\n                parent.remove(comment)\n            if el.tail and not el.tail.isspace():\n                raise SyntaxError(\"Unexpected non-whitespace characters between t-if and t-else directives\")\n            el.tail = None\n\n            # You have to render the `t-else` and `t-elif` here in order\n            # to be able to put the log. Otherwise, the parent's\n            # `t-inner-content`` directive will render the different\n            # nodes without taking indentation into account such as:\n            #    if (if_expression):\n            #         content_if\n            #    log ['last_path_node'] = path\n            #    else:\n            #       content_else\n\n            code.append(indent_code(\"else:\", level))\n            body = []\n            if strip:\n                self._append_text(strip, compile_context)\n            body.extend(\n                self._compile_node(next_el, compile_context, level + 1)+\n                self._flush_text(compile_context, level + 1, rstrip=True))\n            code.extend(body or [indent_code('pass', level + 1)])\n\n            # Insert a flag to avoid the t-else or t-elif rendering when\n            # the parent t-inner-content dirrective compile his\n            # children.\n            next_el.attrib['t-qweb-skip'] = 'True'\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_elif",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_elif(self, el, compile_context, level):\n        \"\"\"Compile `t-elif` expressions into a python code as a list of\n        strings. This method is linked with the `t-if` directive.\n\n        Check if this directive is valide, the t-qweb-skip flag and call\n        `t-if` directive\n        \"\"\"\n        if not el.attrib.pop('t-else-valid', None):\n            raise SyntaxError(\"t-elif directive must be preceded by t-if or t-elif directive\")\n\n        return self._compile_directive_if(el, compile_context, level)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_else",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_else(self, el, compile_context, level):\n        \"\"\"Compile `t-else` expressions into a python code as a list of strings.\n        This method is linked with the `t-if` directive.\n\n        Check if this directive is valide and add the t-qweb-skip flag.\n        \"\"\"\n        if not el.attrib.pop('t-else-valid', None):\n            raise SyntaxError(\"t-elif directive must be preceded by t-if or t-elif directive\")\n        el.attrib.pop('t-else')\n        return []",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_groups",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_groups(self, el, compile_context, level):\n        \"\"\"Compile `t-groups` expressions into a python code as a list of\n        strings.\n\n        The code will contain the condition `if self.user_has_groups(groups)`\n        part that wrap the rest of the compiled code of this element.\n        \"\"\"\n        groups = el.attrib.pop('t-groups', el.attrib.pop('groups', None))\n\n        strip = self._rstrip_text(compile_context)\n        code = self._flush_text(compile_context, level)\n        code.append(indent_code(f\"if self.user_has_groups({groups!r}):\", level))\n        if strip and el.tag.lower() != 't':\n            self._append_text(strip, compile_context)\n        code.extend([\n            *self._compile_directives(el, compile_context, level + 1),\n            *self._flush_text(compile_context, level + 1, rstrip=True),\n        ] or [indent_code('pass', level + 1)])\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_foreach",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_foreach(self, el, compile_context, level):\n        \"\"\"Compile `t-foreach` expressions into a python code as a list of\n        strings.\n\n        `t-as` is used to define the key name.\n        `t-foreach` compiled value can be an iterable, an dictionary or a\n        number.\n\n        The code will contain loop `for` that wrap the rest of the compiled\n        code of this element.\n        Some key into values dictionary are create automatically:\n            *_size, *_index, *_value, *_first, *_last, *_odd, *_even, *_parity\n        \"\"\"\n        expr_foreach = el.attrib.pop('t-foreach')\n        expr_as = el.attrib.pop('t-as')\n\n        if not expr_as:\n            raise KeyError('t-as')\n\n        if not VARNAME_REGEXP.match(expr_as):\n            raise ValueError(f'The varname {expr_as!r} can only contain alphanumeric characters and underscores.')\n\n        if el.tag.lower() == 't':\n            self._rstrip_text(compile_context)\n\n        code = self._flush_text(compile_context, level)\n\n        content_foreach = (\n            self._compile_directives(el, compile_context, level + 1) +\n            self._flush_text(compile_context, level + 1, rstrip=True))\n\n        t_foreach = compile_context['make_name']('t_foreach')\n        size = compile_context['make_name']('size')\n        has_value = compile_context['make_name']('has_value')\n\n        if expr_foreach.isdigit():\n            code.append(indent_code(f\"\"\"\n                values[{expr_as + '_size'!r}] = {size} = {int(expr_foreach)}\n                {t_foreach} = range({size})\n                {has_value} = False\n            \"\"\", level))\n        else:\n            code.append(indent_code(f\"\"\"\n                {t_foreach} = {self._compile_expr(expr_foreach)} or []\n                if isinstance({t_foreach}, Sized):\n                    values[{expr_as + '_size'!r}] = {size} = len({t_foreach})\n                elif ({t_foreach}).__class__ == int:\n                    values[{expr_as + '_size'!r}] = {size} = {t_foreach}\n                    {t_foreach} = range({size})\n                else:\n                    {size} = None\n                {has_value} = False\n                if isinstance({t_foreach}, Mapping):\n                    {t_foreach} = {t_foreach}.items()\n                    {has_value} = True\n            \"\"\", level))\n\n        code.append(indent_code(f\"\"\"\n                for index, item in enumerate({t_foreach}):\n                    values[{expr_as + '_index'!r}] = index\n                    if {has_value}:\n                        values[{expr_as!r}], values[{expr_as + '_value'!r}] = item\n                    else:\n                        values[{expr_as!r}] = values[{expr_as + '_value'!r}] = item\n                    values[{expr_as + '_first'!r}] = values[{expr_as + '_index'!r}] == 0\n                    if {size} is not None:\n                        values[{expr_as + '_last'!r}] = index + 1 == {size}\n                    values[{expr_as + '_odd'!r}] = index % 2\n                    values[{expr_as + '_even'!r}] = not values[{expr_as + '_odd'!r}]\n                    values[{expr_as + '_parity'!r}] = 'odd' if values[{expr_as + '_odd'!r}] else 'even'\n            \"\"\", level))\n\n        code.extend(content_foreach or indent_code('continue', level + 1))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_as",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_as(self, el, compile_context, level):\n        \"\"\"Compile `t-as` expressions into a python code as a list of strings.\n\n        This method only check if this attributes is on the same node of a\n         `t-foreach` attribute.\n        \"\"\"\n        if 't-foreach' not in el.attrib:\n            raise SyntaxError(\"t-as must be on the same node of t-foreach\")\n        return []",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_out",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_out(self, el, compile_context, level):\n        \"\"\"Compile `t-out` expressions into a python code as a list of\n        strings.\n\n        The code will contain evalution and rendering of the compiled value. If\n        the compiled value is None or False, the tag is not added to the render\n        (Except if the widget forces rendering or there is default content).\n        (eg: `<t t-out=\"my_value\">Default content if falsy</t>`)\n\n        The output can have some rendering option with `t-options-widget` or\n        `t-options={'widget': ...}. At rendering time, The compiled code will\n        call ``_get_widget`` method or ``_get_field`` method for `t-field`.\n\n        A `t-field` will necessarily be linked to the value of a record field\n        (eg: `<span t-field=\"record.field_name\"/>`), a t-out` can be applied\n        to any value (eg: `<span t-out=\"10\" t-options-widget=\"'float'\"/>`).\n        \"\"\"\n        ttype = 't-out'\n        expr = el.attrib.pop('t-out', None)\n        if expr is None:\n            ttype = 't-field'\n            expr = el.attrib.pop('t-field', None)\n            if expr is None:\n                # deprecated use.\n                ttype = 't-esc'\n                expr = el.attrib.pop('t-esc', None)\n                if expr is None:\n                    ttype = 't-raw'\n                    expr = el.attrib.pop('t-raw')\n\n        code = self._flush_text(compile_context, level)\n\n        code_options = el.attrib.pop('t-consumed-options', 'None')\n        tag_open = (\n            self._compile_directive(el, compile_context, 'tag-open', level + 1) +\n            self._flush_text(compile_context, level + 1))\n        tag_close = (\n            self._compile_directive(el, compile_context, 'tag-close', level + 1) +\n            self._flush_text(compile_context, level + 1))\n        default_body = (\n            self._compile_directive(el, compile_context, 'inner-content', level + 1) +\n            self._flush_text(compile_context, level + 1))\n\n        # The generated code will set the values of the content, attrs (used to\n        # output attributes) and the force_display (if the widget or field\n        # mark force_display as True, the tag will be inserted in the output\n        # even the value of content is None and without default value)\n\n        if expr == T_CALL_SLOT and code_options != 'True':\n            code.append(indent_code(\"if True:\", level))\n            code.extend(tag_open)\n            code.append(indent_code(f\"yield from values.get({T_CALL_SLOT}, [])\", level + 1))\n            code.extend(tag_close)\n            return code\n        elif ttype == 't-field':\n            record, field_name = expr.rsplit('.', 1)\n            code.append(indent_code(f\"\"\"\n                field_attrs, content, force_display = self._get_field({self._compile_expr(record, raise_on_missing=True)}, {field_name!r}, {expr!r}, {el.tag!r}, values.pop('__qweb_options__', {{}}), values)\n                if values.get('__qweb_attrs__') is None:\n                    values['__qweb_attrs__'] = field_attrs\n                else:\n                    values['__qweb_attrs__'].update(field_attrs)\n                if content is not None and content is not False:\n                    content = self._compile_to_str(content)\n                \"\"\", level))\n            force_display_dependent = True\n        else:\n            if expr == T_CALL_SLOT:\n                code.append(indent_code(f\"content = Markup(''.join(values.get({T_CALL_SLOT}, [])))\", level))\n            else:\n                code.append(indent_code(f\"content = {self._compile_expr(expr)}\", level))\n\n            if code_options == 'True':\n                code.append(indent_code(f\"\"\"\n                    widget_attrs, content, force_display = self._get_widget(content, {expr!r}, {el.tag!r}, values.pop('__qweb_options__', {{}}), values)\n                    if values.get('__qweb_attrs__') is None:\n                        values['__qweb_attrs__'] = widget_attrs\n                    else:\n                        values['__qweb_attrs__'].update(widget_attrs)\n                    content = self._compile_to_str(content)\n                    \"\"\", level))\n                force_display_dependent = True\n            else:\n                force_display_dependent = False\n\n            if ttype == 't-raw':\n                # deprecated use.\n                code.append(indent_code(\"\"\"\n                    if content is not None and content is not False:\n                        content = Markup(content)\n                \"\"\", level))\n\n        # The generated code will create the output tag with all attribute.\n        # If the value is not falsy or if there is default content or if it's\n        # in force_display mode, the tag is add into the output.\n\n        el.attrib.pop('t-tag', None) # code generating the output is done here\n\n        # generate code to display the tag if the value is not Falsy\n\n        code.append(indent_code(\"if content is not None and content is not False:\", level))\n        code.extend(tag_open)\n        # Use str to avoid the escaping of the other html content because the\n        # yield generator MarkupSafe values will be join into an string in\n        # `_render`.\n        code.append(indent_code(\"yield str(escape(content))\", level + 1))\n        code.extend(tag_close)\n\n        # generate code to display the tag with default content if the value is\n        # Falsy\n\n        if default_body or compile_context['_text_concat']:\n            _text_concat = list(compile_context['_text_concat'])\n            compile_context['_text_concat'].clear()\n            code.append(indent_code(\"else:\", level))\n            code.extend(tag_open)\n            code.extend(default_body)\n            compile_context['_text_concat'].extend(_text_concat)\n            code.extend(tag_close)\n        elif force_display_dependent:\n\n            # generate code to display the tag if it's the force_diplay mode.\n\n            if tag_open + tag_close:\n                code.append(indent_code(\"elif force_display:\", level))\n                code.extend(tag_open + tag_close)\n\n            code.append(indent_code(\"\"\"else: values.pop('__qweb_attrs__', None)\"\"\", level))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_esc",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_esc(self, el, compile_context, level):\n        # deprecated use.\n        if compile_context.get('dev_mode'):\n            _logger.warning(\n                \"Found deprecated directive @t-esc=%r in template %r. Replace by @t-out\",\n                el.get('t-esc'),\n                compile_context.get('ref', '<unknown>'),\n            )\n        return self._compile_directive_out(el, compile_context, level)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_raw",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_raw(self, el, compile_context, level):\n        # deprecated use.\n        _logger.warning(\n            \"Found deprecated directive @t-raw=%r in template %r. Replace by \"\n            \"@t-out, and explicitely wrap content in `Markup` if \"\n            \"necessary (which likely is not the case)\",\n            el.get('t-raw'),\n            compile_context.get('ref', '<unknown>'),\n        )\n        return self._compile_directive_out(el, compile_context, level)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_field",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_field(self, el, compile_context, level):\n        \"\"\"Compile `t-field` expressions into a python code as a list of\n        strings.\n\n        The compiled code will call ``_get_field`` method at rendering time\n        using the type of value supplied by the field. This behavior can be\n        changed with `t-options-widget` or `t-options={'widget': ...}.\n\n        The code will contain evalution and rendering of the compiled value\n        value from the record field. If the compiled value is None or False,\n        the tag is not added to the render\n        (Except if the widget forces rendering or there is default content.).\n        \"\"\"\n        tagName = el.tag\n        assert tagName not in (\"table\", \"tbody\", \"thead\", \"tfoot\", \"tr\", \"td\",\n                                 \"li\", \"ul\", \"ol\", \"dl\", \"dt\", \"dd\"),\\\n            \"QWeb widgets do not work correctly on %r elements\" % tagName\n        assert tagName != 't',\\\n            \"t-field can not be used on a t element, provide an actual HTML node\"\n        assert \".\" in el.get('t-field'),\\\n            \"t-field must have at least a dot like 'record.field_name'\"\n\n        return self._compile_directive_out(el, compile_context, level)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_call",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_call(self, el, compile_context, level):\n        \"\"\"Compile `t-call` expressions into a python code as a list of\n        strings.\n\n        `t-call` allow formating string dynamic at rendering time.\n        Can use `t-options` used to call and render the sub-template at\n        rendering time.\n        The sub-template is called with a copy of the rendering values\n        dictionary. The dictionary contains the key 0 coming from the\n        compilation of the contents of this element\n\n        The code will contain the call of the template and a function from the\n        compilation of the content of this element.\n        \"\"\"\n        expr = el.attrib.pop('t-call')\n\n        if el.attrib.get('t-call-options'): # retro-compatibility\n            el.attrib.set('t-options', el.attrib.pop('t-call-options'))\n\n        nsmap = compile_context.get('nsmap')\n\n        code = self._flush_text(compile_context, level, rstrip=el.tag.lower() == 't')\n\n        # options\n        el.attrib.pop('t-consumed-options', None)\n        code.append(indent_code(\"t_call_options = values.pop('__qweb_options__', {})\", level))\n        if nsmap:\n            # update this dict with the current nsmap so that the callee know\n            # if he outputting the xmlns attributes is relevenat or not\n            nsmap = []\n            for key, value in compile_context['nsmap'].items():\n                if isinstance(key, str):\n                    nsmap.append(f'{key!r}:{value!r}')\n                else:\n                    nsmap.append(f'None:{value!r}')\n            code.append(indent_code(f\"t_call_options.update(nsmap={{{', '.join(nsmap)}}})\", level))\n\n        # values (t-out=\"0\" from content and variables from t-set)\n        def_name = compile_context['make_name']('t_call')\n\n        # values from content (t-out=\"0\" and t-set inside the content)\n        code_content = [f\"def {def_name}(self, values):\"]\n        code_content.extend(self._compile_directive(el, compile_context, 'inner-content', 1))\n        self._append_text('', compile_context) # To ensure the template function is a generator and doesn't become a regular function\n        code_content.extend(self._flush_text(compile_context, 1, rstrip=True))\n        compile_context['template_functions'][def_name] = code_content\n\n        code.append(indent_code(f\"\"\"\n            t_call_values = values.copy()\n            t_call_values[{T_CALL_SLOT}] = list({def_name}(self, t_call_values))\n            \"\"\", level))\n\n        template = self._compile_format(expr)\n\n        # call\n        code.append(indent_code(f\"\"\"\n            irQweb = self.with_context(**t_call_options)\n            template = {template}\n            if template.isnumeric():\n                template = int(template)\n            t_call_template_functions, def_name = irQweb._compile(template)\n            render_template = t_call_template_functions[def_name]\n            yield from render_template(irQweb, t_call_values)\n            \"\"\", level))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_lang",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_lang(self, el, compile_context, level):\n        if 't-call' not in el.attrib:\n            raise SyntaxError(\"t-lang is an alias of t-options-lang but only available on the same node of t-call\")\n        el.attrib['t-options-lang'] = el.attrib.pop('t-lang')\n        return self._compile_node(el, compile_context, level)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_call_assets",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_call_assets(self, el, compile_context, level):\n        \"\"\" This special 't-call-assets' tag can be used in order to aggregate/minify javascript and css assets\"\"\"\n        if len(el) > 0:\n            raise SyntaxError(\"t-call-assets cannot contain children nodes\")\n\n        code = self._flush_text(compile_context, level)\n        xmlid = el.attrib.pop('t-call-assets')\n        css = self._compile_bool(el.attrib.pop('t-css', True))\n        js = self._compile_bool(el.attrib.pop('t-js', True))\n        # async_load support was removed\n        defer_load = self._compile_bool(el.attrib.pop('defer_load', False))\n        lazy_load = self._compile_bool(el.attrib.pop('lazy_load', False))\n        media = el.attrib.pop('media', False)\n        code.append(indent_code(f\"\"\"\n            t_call_assets_nodes = self._get_asset_nodes(\n                {xmlid!r},\n                css={css},\n                js={js},\n                debug=values.get(\"debug\"),\n                defer_load={defer_load},\n                lazy_load={lazy_load},\n                media={media!r},\n            )\n        \"\"\".strip(), level))\n\n        code.append(indent_code(\"\"\"\n            for index, (tagName, asset_attrs) in enumerate(t_call_assets_nodes):\n                if index:\n                    yield '\\\\n        '\n                yield '<'\n                yield tagName\n\n                attrs = self._post_processing_att(tagName, asset_attrs)\n                for name, value in attrs.items():\n                    if value or isinstance(value, str):\n                        yield f' {escape(str(name))}=\"{escape(str(value))}\"'\n\n                if tagName in VOID_ELEMENTS:\n                    yield '/>'\n                else:\n                    yield '>'\n                    yield '</'\n                    yield tagName\n                    yield '>'\n                \"\"\", level))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_cache",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_cache(self, el, compile_context, level):\n        \"\"\"Compile the `t-cache` tuple expression into a key cache.\n\n        The `t-cache` directive allows you to keep the rendered result\n        of a template part. The supplied key must be a tuple. This tuple\n        can contain recordset in this case the zone will be invalidated\n        each time the write_date of these records changes.\n        The values are scoped into the `t-cache` and are not available\n        outside.\n        see: `t-nocache`\n        \"\"\"\n        expr = el.attrib.pop('t-cache')\n        code = self._flush_text(compile_context, level)\n\n        def_name = compile_context['make_name']('t_cache')\n\n        # Generate the content function\n        def_code = [indent_code(f\"\"\"def {def_name}(self, values):\"\"\", 0)]\n        def_content = self._compile_directives(el, compile_context, 1)\n        if def_content and not compile_context['_text_concat']:\n            self._append_text('', compile_context) # To ensure the template function is a generator and doesn't become a regular function\n        def_code.extend(def_content)\n        def_code.extend(self._flush_text(compile_context, 1))\n        compile_context['template_functions'][def_name] = def_code\n\n        # Get the dynamic key for the cache and load the content.\n        # The t-nocache yield a tuple (ref, function name) instead of a\n        # When reading tuple coming from t-nocache, we check if the\n        # method is already known otherwise the corresponding template\n        # and its functions are loaded.\n        code.append(indent_code(f\"\"\"\n            template_cache_key = {self._compile_expr(expr)} if not self.env.context.get('is_t_cache_disabled') else None\n            cache_key = self._get_cache_key(template_cache_key) if template_cache_key else None\n            uniq_cache_key = cache_key and ({str(self.env.context['__qweb_base_key_cache'])!r}, '{def_name}_cache', cache_key)\n            loaded_values = values['__qweb_loaded_values']\n            def {def_name}_cache():\n                content = []\n                text = []\n                for item in {def_name}(self, {{**values, '__qweb_in_cache': True}}):\n                    if isinstance(item, str):\n                        text.append(item)\n                    else:\n                        content.append(''.join(text))\n                        content.append(item)\n                        text = []\n                if text:\n                    content.append(''.join(text))\n                return content\n            cache_content = self._load_values(uniq_cache_key, {def_name}_cache, loaded_values)\n            if values.get('__qweb_in_cache'):\n                yield from cache_content\n            else:\n                for item in cache_content:\n                    if isinstance(item, str):\n                        yield item\n                    else:\n                        ref, function_name, cached_values = item\n                        t_nocache_function = loaded_values.get(function_name)\n                        if not t_nocache_function:\n                            t_call_template_functions, def_name = self._compile(ref)\n                            t_nocache_function = t_call_template_functions[function_name]\n\n                        nocache_values = values['__qweb_root_values'].copy()\n                        nocache_values.update(cached_values)\n                        yield ''.join(t_nocache_function(self, nocache_values))\n            \"\"\", level))\n\n        return code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compile_directive_nocache",
          "params": [
            "self",
            "el",
            "compile_context",
            "level"
          ],
          "decorators": [],
          "source": "def _compile_directive_nocache(self, el, compile_context, level):\n        \"\"\"\n        The `t-nocache` directive makes it possible to force rendering\n        of a part even if it is in a `t-cache`. The values available in\n        the `t-nocache` are the one provided when calling the template\n        (and therefore ignores any t-set that could have been done).\n\n        The `t-nocache-*` are the values whose result of the\n        expression will be cached and added to the root's values when\n        rendering the no cache part. Only primitive types can be cached.\n\n        see: `t-cache`\n        \"\"\"\n        if 't-nocache' not in el.attrib:\n            raise SyntaxError(\"t-nocache-* must be on the same node as t-nocache\")\n\n        el.attrib.pop('t-nocache')\n        code = self._flush_text(compile_context, level)\n\n        # t-nocache-* will generate the values to put in cache\n        # must cosume this attributes before generate the cached content.\n        code_cache_values = []\n        for key in list(el.attrib):\n            if key.startswith('t-nocache-'):\n                expr = el.attrib.pop(key)\n                varname = key[10:]\n                if not VARNAME_REGEXP.match(varname):\n                    raise ValueError(f'The varname {varname!r} can only contain alphanumeric characters and underscores.')\n                code_cache_values.append(indent_code(f\"\"\"\n                    cached_value = {self._compile_expr(expr)}\n                    if cached_value is not None and not isinstance(cached_value, (str, int, float, bool)):\n                        raise ValueError(f'''The value type of {key!r} cannot be cached: {{cached_value!r}}''')\n                    cached_values[{varname!r}] = cached_value\n                \"\"\", level + 1))\n\n        # generate the cached content method\n        def_name = compile_context['make_name']('t_nocache')\n        def_code = [f\"def {def_name}(self, values):\"]\n        def_code.append(indent_code(\"try:\", 1))\n        def_content = self._compile_directives(el, compile_context, 2)\n        if def_content and not compile_context['_text_concat']:\n            self._append_text('', compile_context) # To ensure the template function is a generator and doesn't become a regular function\n        def_code.extend(def_content)\n        def_code.extend(self._flush_text(compile_context, 2))\n        def_code.append(indent_code(f\"\"\"\n                except QWebException:\n                    raise\n                except Exception as e:\n                    raise QWebException(\"Error while render the template\",\n                        self, template, ref={compile_context['ref']!r}, code=code) from e\n            \"\"\", 1))\n        compile_context['template_functions'][def_name] = def_code\n\n        # if the nocache is inside a cache return a tuple with the method name and the cached values\n        code.append(indent_code(\"\"\"\n            if values.get('__qweb_in_cache'):\n                cached_values = {}\n            \"\"\", level))\n        code.extend(code_cache_values)\n        code.append(indent_code(f\"yield ({compile_context['template']!r}, {def_name!r}, cached_values)\", level+1))\n        # else render the content\n        code.append(indent_code(f\"\"\"\n            else:\n                yield from {def_name}(self, values)\n            \"\"\", level))\n\n        return code\n\n    # methods called by the compiled function at rendering time.",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_debug_trace",
          "params": [
            "self",
            "debugger",
            "values"
          ],
          "decorators": [],
          "source": "def _debug_trace(self, debugger, values):\n        \"\"\"Method called at running time to load debugger.\"\"\"\n        if not debugger:\n            breakpoint()\n        elif debugger in SUPPORTED_DEBUGGER:\n            warnings.warn(\n                \"Using t-debug with an explicit debugger is deprecated \"\n                \"since Odoo 17.0, keep the value empty and configure the \"\n                \"``breakpoint`` builtin instead.\",\n                category=DeprecationWarning,\n                stacklevel=2,\n            )\n            __import__(debugger).set_trace()\n        else:\n            raise ValueError(f\"unsupported t-debug value: {debugger}\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_post_processing_att",
          "params": [
            "self",
            "tagName",
            "atts"
          ],
          "decorators": [],
          "source": "def _post_processing_att(self, tagName, atts):\n        \"\"\" Method called at compile time for the static node and called at\n            runing time for the dynamic attributes.\n\n            This method may be overwrited to filter or modify the attributes\n            (during compilation for static node or after they compilation in\n            the case of dynamic elements).",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_field",
          "params": [
            "self",
            "record",
            "field_name",
            "expression",
            "tagName",
            "field_options",
            "values"
          ],
          "decorators": [],
          "source": "def _get_field(self, record, field_name, expression, tagName, field_options, values):\n        \"\"\"Method called at compile time to return the field value.\n\n        :returns: tuple:\n            * dict: attributes\n            * string or None: content\n            * boolean: force_display display the tag if the content and default_content are None\n        \"\"\"\n        field = record._fields[field_name]\n\n        # adds generic field options\n        field_options['tagName'] = tagName\n        field_options['expression'] = expression\n        field_options['type'] = field_options.get('widget', field.type)\n        inherit_branding = (\n                self.env.context['inherit_branding']\n                if 'inherit_branding' in self.env.context\n                else self.env.context.get('inherit_branding_auto') and record.check_access_rights('write', False))\n        field_options['inherit_branding'] = inherit_branding\n        translate = self.env.context.get('edit_translations') and values.get('translatable') and field.translate\n        field_options['translate'] = translate\n\n        # field converter\n        model = 'ir.qweb.field.' + field_options['type']\n        converter = self.env[model] if model in self.env else self.env['ir.qweb.field']\n\n        # get content (the return values from fields are considered to be markup safe)\n        content = converter.record_to_html(record, field_name, field_options)\n        attributes = converter.attributes(record, field_name, field_options, values)\n\n        return (attributes, content, inherit_branding or translate)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_widget",
          "params": [
            "self",
            "value",
            "expression",
            "tagName",
            "field_options",
            "values"
          ],
          "decorators": [],
          "source": "def _get_widget(self, value, expression, tagName, field_options, values):\n        \"\"\"Method called at compile time to return the widget value.\n\n        :returns: tuple:\n            * dict: attributes\n            * string or None: content\n            * boolean: force_display display the tag if the content and default_content are None\n        \"\"\"\n        field_options['type'] = field_options['widget']\n        field_options['tagName'] = tagName\n        field_options['expression'] = expression\n        inherit_branding = self.env.context.get('inherit_branding')\n        field_options['inherit_branding'] = inherit_branding\n\n        # field converter\n        model = 'ir.qweb.field.' + field_options['type']\n        converter = self.env[model] if model in self.env else self.env['ir.qweb.field']\n\n        # get content (the return values from widget are considered to be markup safe)\n        content = converter.value_to_html(value, field_options)\n        attributes = {}\n        attributes['data-oe-type'] = field_options['type']\n        attributes['data-oe-expression'] = field_options['expression']\n\n        return (attributes, content, inherit_branding)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_nodes",
          "params": [
            "self",
            "bundle",
            "css=True",
            "js=True",
            "debug=False",
            "defer_load=False",
            "lazy_load=False",
            "media=None"
          ],
          "decorators": [],
          "source": "def _get_asset_nodes(self, bundle, css=True, js=True, debug=False, defer_load=False, lazy_load=False, media=None):\n        \"\"\"Generates asset nodes.\n        If debug=assets, the assets will be regenerated when a file which composes them has been modified.\n        Else, the assets will be generated only once and then stored in cache.\n        \"\"\"\n        media = css and media or None\n        links = self._get_asset_links(bundle, css=css, js=js, debug=debug)\n        return self._links_to_nodes(links, defer_load=defer_load, lazy_load=lazy_load, media=media)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_links",
          "params": [
            "self",
            "bundle",
            "css=True",
            "js=True",
            "debug=None"
          ],
          "decorators": [],
          "source": "def _get_asset_links(self, bundle, css=True, js=True, debug=None):\n        \"\"\"Generates asset nodes.\n        If debug=assets, the assets will be regenerated when a file which composes them has been modified.\n        Else, the assets will be generated only once and then stored in cache.\n        \"\"\"\n        rtl = self.env['res.lang'].sudo()._lang_get_direction(self.env.context.get('lang') or self.env.user.lang) == 'rtl'\n        assets_params = self.env['ir.asset']._get_asset_params() # website_id\n        debug_assets = debug and 'assets' in debug\n\n        if debug_assets:\n            return self._generate_asset_links(bundle, css=css, js=js, debug_assets=True, assets_params=assets_params, rtl=rtl)\n        else:\n            return self._generate_asset_links_cache(bundle, css=css, js=js, assets_params=assets_params, rtl=rtl)\n\n    # qweb cache feature",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_cache_key",
          "params": [
            "self",
            "cache_key"
          ],
          "decorators": [],
          "source": "def _get_cache_key(self, cache_key):\n        \"\"\"\n            Convert the template cache key item into a hashable key.\n            :param cache_key: tuple\n            :returns: tuple of hashable items\n        \"\"\"\n        if not isinstance(cache_key, (tuple, list)):\n            cache_key = (cache_key,)\n        keys = []\n        for item in cache_key:\n            try:\n                # use try catch instead of isinstance to detect lazy values\n                keys.append(item._name)\n                keys.append(tuple(item.ids))\n                dates = item.mapped('write_date')\n                if dates:\n                    keys.append(max(dates).timestamp())\n            except AttributeError:\n                keys.append(repr(item))\n        return tuple(keys)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load_values",
          "params": [
            "self",
            "cache_key",
            "get_value",
            "loaded_values=None"
          ],
          "decorators": [],
          "source": "def _load_values(self, cache_key, get_value, loaded_values=None):\n        \"\"\" generate value from the function if the result is not cached. \"\"\"\n        if not cache_key:\n            return get_value()\n        value = loaded_values and loaded_values.get(cache_key)\n        if not value:\n            value = self._get_cached_values(cache_key, get_value)\n        if loaded_values is not None:\n            loaded_values[cache_key] = value\n        return value\n\n    # The cache does not need to be invalidated if the 'base_key_cache'\n    # in '_compile' method contains the write_date of all inherited views.",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_cached_values",
          "params": [
            "self",
            "cache_key",
            "get_value"
          ],
          "decorators": [],
          "source": "def _get_cached_values(self, cache_key, get_value):\n        \"\"\" generate value from the function if the result is not cached. \"\"\"\n        return get_value()\n\n    # other methods used for the asset bundles",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_generate_asset_links_cache",
          "params": [
            "self",
            "bundle",
            "css=True",
            "js=True",
            "assets_params=None",
            "rtl=False"
          ],
          "decorators": [],
          "source": "def _generate_asset_links_cache(self, bundle, css=True, js=True, assets_params=None, rtl=False):\n        return self._generate_asset_links(bundle, css, js, False, assets_params, rtl)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_content",
          "params": [
            "self",
            "bundle",
            "assets_params=None"
          ],
          "decorators": [],
          "source": "def _get_asset_content(self, bundle, assets_params=None):\n        if assets_params is None:\n            assets_params = self.env['ir.asset']._get_asset_params()  # website_id\n        asset_paths = self.env['ir.asset']._get_asset_paths(bundle=bundle, assets_params=assets_params)\n        files = []\n        external_asset = []\n        for path, full_path, _bundle, last_modified in asset_paths:\n            if full_path is not EXTERNAL_ASSET:\n                files.append({\n                    'url': path,\n                    'filename': full_path,\n                    'content': '',\n                    'last_modified': last_modified,\n                })\n            else:\n                external_asset.append(path)\n        return (files, external_asset)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_bundle",
          "params": [
            "self",
            "bundle_name",
            "css=True",
            "js=True",
            "debug_assets=False",
            "rtl=False",
            "assets_params=None"
          ],
          "decorators": [],
          "source": "def _get_asset_bundle(self, bundle_name, css=True, js=True, debug_assets=False, rtl=False, assets_params=None):\n        if assets_params is None:\n            assets_params = self.env['ir.asset']._get_asset_params()\n        files, external_assets = self._get_asset_content(bundle_name, assets_params)\n        return AssetsBundle(bundle_name, files, external_assets, env=self.env, css=css, js=js, debug_assets=debug_assets, rtl=rtl, assets_params=assets_params)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_links_to_nodes",
          "params": [
            "self",
            "paths",
            "defer_load=False",
            "lazy_load=False",
            "media=None"
          ],
          "decorators": [],
          "source": "def _links_to_nodes(self, paths, defer_load=False, lazy_load=False, media=None):\n        return [self._link_to_node(path, defer_load=defer_load, lazy_load=lazy_load, media=media) for path in paths]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_link_to_node",
          "params": [
            "self",
            "path",
            "defer_load=False",
            "lazy_load=False",
            "media=None"
          ],
          "decorators": [],
          "source": "def _link_to_node(self, path, defer_load=False, lazy_load=False, media=None):\n        ext = path.rsplit('.', maxsplit=1)[-1] if path else 'js'\n        is_js = ext in SCRIPT_EXTENSIONS\n        is_xml = ext in TEMPLATE_EXTENSIONS\n        is_css = ext in STYLE_EXTENSIONS\n        if not is_js and not is_xml and not is_css:\n            return\n\n        if is_js:\n            is_asset_bundle = path and path.startswith('/web/assets/')\n            attributes = {\n                'type': 'text/javascript',\n            }\n\n            if (defer_load or lazy_load):\n                attributes['defer'] = 'defer'\n            if path:\n                if lazy_load:\n                    attributes['data-src'] = path\n                else:\n                    attributes['src'] = path\n\n            if is_asset_bundle:\n                attributes['onerror'] = \"__odooAssetError=1\"\n\n            return ('script', attributes)\n\n\n        if is_css:\n            attributes = {\n                'type': f'text/{ext}',  # we don't really expect to have anything else than pure css here\n                'rel': 'stylesheet',\n                'href': path,\n                'media': media,\n            }\n            return ('link', attributes)\n\n        if is_xml:\n            attributes = {\n                'type': 'text/xml',\n                'async': 'async',\n                'rel': 'prefetch',\n                'data-src': path,\n                }\n            return ('script', attributes)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_generate_asset_links",
          "params": [
            "self",
            "bundle",
            "css=True",
            "js=True",
            "debug_assets=False",
            "assets_params=None",
            "rtl=False"
          ],
          "decorators": [],
          "source": "def _generate_asset_links(self, bundle, css=True, js=True, debug_assets=False, assets_params=None, rtl=False):\n        asset_bundle = self._get_asset_bundle(bundle, css=css, js=js, debug_assets=debug_assets, rtl=rtl, assets_params=assets_params)\n        return asset_bundle.get_links()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_asset_link_urls",
          "params": [
            "self",
            "bundle",
            "debug=False"
          ],
          "decorators": [],
          "source": "def _get_asset_link_urls(self, bundle, debug=False):\n        asset_nodes = self._get_asset_nodes(bundle, js=False, debug=debug)\n        return [node[1]['href'] for node in asset_nodes if node[0] == 'link']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_pregenerate_assets_bundles",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _pregenerate_assets_bundles(self):\n        \"\"\"\n        Pregenerates all assets that may be used in web pages to speedup first loading.\n        This may is mainly usefull for tests.\n\n        The current version is looking for all t-call-assets in view to generate the minimal\n        set of bundles to generate.\n\n        Current version only generate assets without extra, not taking care of rtl.\n        \"\"\"\n        _logger.runbot('Pregenerating assets bundles')\n\n        js_bundles, css_bundles = self._get_bundles_to_pregenarate()\n\n        links = []\n        start = time.time()\n        for bundle in sorted(js_bundles):\n            links += self._get_asset_bundle(bundle, css=False, js=True).js()\n        _logger.info('JS Assets bundles generated in %s seconds', time.time()-start)\n        start = time.time()\n        for bundle in sorted(css_bundles):\n            links += self._get_asset_bundle(bundle, css=True, js=False).css()\n        _logger.info('CSS Assets bundles generated in %s seconds', time.time()-start)\n        return links",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_bundles_to_pregenarate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_bundles_to_pregenarate(self):\n        \"\"\"\n        Returns the list of bundles to pregenerate.\n        \"\"\"\n\n        views = self.env['ir.ui.view'].search([('type', '=', 'qweb'), ('arch_db', 'like', 't-call-assets')])\n        js_bundles = set()\n        css_bundles = set()\n        for view in views:\n            for call_asset in etree.fromstring(view.arch_db).xpath(\"//*[@t-call-assets]\"):\n                asset = call_asset.get('t-call-assets')\n                js = str2bool(call_asset.get('t-js', 'True'))\n                css = str2bool(call_asset.get('t-css', 'True'))\n                if js:\n                    js_bundles.add(asset)\n                if css:\n                    css_bundles.add(asset)\n        return (js_bundles, css_bundles)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "render",
          "params": [
            "template_name",
            "values",
            "load",
            "**options"
          ],
          "decorators": [],
          "source": "def render(template_name, values, load, **options):\n    \"\"\" Rendering of a qweb template without database and outside the registry.\n    (Widget, field, or asset rendering is not implemented.)\n    :param (string|int) template_name: template identifier\n    :param dict values: template values to be used for rendering\n    :param def load: function like `load(template_name)` which returns an etree\n        from the given template name (from initial rendering or template\n        `t-call`).\n    :param options: used to compile the template\n    :returns: bytes marked as markup-safe (decode to :class:`markupsafe.Markup`\n                instead of `str`)\n    :rtype: MarkupSafe\n    \"\"\"",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_render (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrQWeb"
    },
    {
      "name": "ir.qweb.field",
      "description": "Qweb Field",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        \"\"\"\n            Get the available option informations.\n\n            Returns a dict of dict with:\n            * key equal to the option key.\n            * dict: type, params, name, description, default_value\n            * type:\n                'string'\n                'integer'\n                'float'\n                'model' (e.g. 'res.partner')\n                'array'\n                'selection' (e.g. [key1, key2...])\n        \"\"\"\n        return {}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "attributes",
          "params": [
            "self",
            "record",
            "field_name",
            "options",
            "values=None"
          ],
          "decorators": [],
          "source": "def attributes(self, record, field_name, options, values=None):\n        \"\"\" attributes(record, field_name, field, options, values)\n\n        Generates the metadata attributes (prefixed by ``data-oe-``) for the\n        root node of the field conversion.\n\n        The default attributes are:\n\n        * ``model``, the name of the record's model\n        * ``id`` the id of the record to which the field belongs\n        * ``type`` the logical field type (widget, may not match the field's\n          ``type``, may not be any Field subclass name)\n        * ``translate``, a boolean flag (``0`` or ``1``) denoting whether the\n          field is translatable\n        * ``readonly``, has this attribute if the field is readonly\n        * ``expression``, the original expression\n\n        :returns: dict (attribute name, attribute value).\n        \"\"\"\n        data = {}\n        field = record._fields[field_name]\n\n        if not options['inherit_branding'] and not options['translate']:\n            return data\n\n        data['data-oe-model'] = record._name\n        data['data-oe-id'] = record.id\n        data['data-oe-field'] = field.name\n        data['data-oe-type'] = options.get('type')\n        data['data-oe-expression'] = options.get('expression')\n        if field.readonly:\n            data['data-oe-readonly'] = 1\n        return data",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        \"\"\" value_to_html(value, field, options=None)\n\n        Converts a single value to its HTML version/output\n        :rtype: unicode\n        \"\"\"\n        return escape(pycompat.to_text(value))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "record_to_html",
          "params": [
            "self",
            "record",
            "field_name",
            "options"
          ],
          "decorators": [],
          "source": "def record_to_html(self, record, field_name, options):\n        \"\"\" record_to_html(record, field_name, options)\n\n        Converts the specified field of the ``record`` to HTML\n\n        :rtype: unicode\n        \"\"\"\n        if not record:\n            return False\n        value = record.with_context(**self.env.context)[field_name]\n        return False if value is False else self.value_to_html(value, options=options)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "user_lang",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def user_lang(self):\n        \"\"\" user_lang()\n\n        Fetches the res.lang record corresponding to the language code stored\n        in the user's context.\n\n        :returns: Model[res.lang]\n        \"\"\"\n        return get_lang(self.env)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "attributes (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "record_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "user_lang (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "FieldConverter"
    },
    {
      "name": "ir.qweb.field.integer",
      "description": "Qweb Field Integer",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(IntegerConverter, self).get_available_options()\n        options.update(\n            format_decimalized_number=dict(type='boolean', string=_('Decimalized number')),\n            precision_digits=dict(type='integer', string=_('Precision Digits')),\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if options.get('format_decimalized_number'):\n            return tools.format_decimalized_number(value, options.get('precision_digits', 1))\n        return pycompat.to_text(self.user_lang().format('%d', value, grouping=True).replace(r'-', '-\\N{ZERO WIDTH NO-BREAK SPACE}'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IntegerConverter"
    },
    {
      "name": "ir.qweb.field.float",
      "description": "Qweb Field Float",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(FloatConverter, self).get_available_options()\n        options.update(\n            precision=dict(type='integer', string=_('Rounding precision')),\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if 'decimal_precision' in options:\n            precision = self.env['decimal.precision'].precision_get(options['decimal_precision'])\n        else:\n            precision = options['precision']\n\n        if precision is None:\n            fmt = '%f'\n        else:\n            value = float_utils.float_round(value, precision_digits=precision)\n            fmt = '%.{precision}f'.format(precision=precision)\n\n        formatted = self.user_lang().format(fmt, value, grouping=True).replace(r'-', '-\\N{ZERO WIDTH NO-BREAK SPACE}')\n\n        # %f does not strip trailing zeroes. %g does but its precision causes\n        # it to switch to scientific notation starting at a million *and* to\n        # strip decimals. So use %f and if no precision was specified manually\n        # strip trailing 0.\n        if precision is None:\n            formatted = re.sub(r'(?:(0|\\d+?)0+)$', r'\\1', formatted)\n\n        return pycompat.to_text(formatted)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "record_to_html",
          "params": [
            "self",
            "record",
            "field_name",
            "options"
          ],
          "decorators": [],
          "source": "def record_to_html(self, record, field_name, options):\n        if 'precision' not in options and 'decimal_precision' not in options:\n            _, precision = record._fields[field_name].get_digits(record.env) or (None, None)\n            options = dict(options, precision=precision)\n        return super(FloatConverter, self).record_to_html(record, field_name, options)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "record_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "FloatConverter"
    },
    {
      "name": "ir.qweb.field.date",
      "description": "Qweb Field Date",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(DateConverter, self).get_available_options()\n        options.update(\n            format=dict(type='string', string=_('Date format'))\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        return format_date(self.env, value, date_format=options.get('format'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "DateConverter"
    },
    {
      "name": "ir.qweb.field.datetime",
      "description": "Qweb Field Datetime",
      "fields": [
        {
          "name": "value",
          "type": "Datetime.from_string"
        },
        {
          "name": "value",
          "type": "Datetime.context_timestamp"
        }
      ],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(DateTimeConverter, self).get_available_options()\n        options.update(\n            format=dict(type='string', string=_('Pattern to format')),\n            tz_name=dict(type='char', string=_('Optional timezone name')),\n            time_only=dict(type='boolean', string=_('Display only the time')),\n            hide_seconds=dict(type='boolean', string=_('Hide seconds')),\n            date_only=dict(type='boolean', string=_('Display only the date')),\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if not value:\n            return ''\n\n        lang = self.user_lang()\n        locale = babel_locale_parse(lang.code)\n        format_func = babel.dates.format_datetime\n        if isinstance(value, str):\n            value = fields.Datetime.from_string(value)\n\n        if options.get('tz_name'):\n            self = self.with_context(tz=options['tz_name'])\n            tzinfo = babel.dates.get_timezone(options['tz_name'])\n        else:\n            tzinfo = None\n\n        value = fields.Datetime.context_timestamp(self, value)\n\n        if 'format' in options:\n            pattern = options['format']\n        else:\n            if options.get('time_only'):\n                strftime_pattern = (\"%s\" % (lang.time_format))\n            elif options.get('date_only'):\n                strftime_pattern = (\"%s\" % (lang.date_format))\n            else:\n                strftime_pattern = (\"%s %s\" % (lang.date_format, lang.time_format))\n\n            pattern = posix_to_ldml(strftime_pattern, locale=locale)\n\n        if options.get('hide_seconds'):\n            pattern = pattern.replace(\":ss\", \"\").replace(\":s\", \"\")\n\n        if options.get('time_only'):\n            format_func = babel.dates.format_time\n            return pycompat.to_text(format_func(value, format=pattern, tzinfo=tzinfo, locale=locale))\n        if options.get('date_only'):\n            format_func = babel.dates.format_date\n            return pycompat.to_text(format_func(value, format=pattern, locale=locale))\n\n        return pycompat.to_text(format_func(value, format=pattern, tzinfo=tzinfo, locale=locale))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "DateTimeConverter"
    },
    {
      "name": "ir.qweb.field.text",
      "description": "Qweb Field Text",
      "fields": [],
      "methods": [
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        \"\"\"\n        Escapes the value and converts newlines to br. This is bullshit.\n        \"\"\"\n        return nl2br(escape(value)) if value else ''",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "TextConverter"
    },
    {
      "name": "ir.qweb.field.selection",
      "description": "Qweb Field Selection",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(SelectionConverter, self).get_available_options()\n        options.update(\n            selection=dict(type='selection', string=_('Selection'), description=_('By default the widget uses the field information'), required=True)\n        )\n        options.update(\n            selection=dict(type='json', string=_('Json'), description=_('By default the widget uses the field information'), required=True)\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if not value:\n            return ''\n        return escape(pycompat.to_text(options['selection'][value]) or '')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "record_to_html",
          "params": [
            "self",
            "record",
            "field_name",
            "options"
          ],
          "decorators": [],
          "source": "def record_to_html(self, record, field_name, options):\n        if 'selection' not in options:\n            options = dict(options, selection=dict(record._fields[field_name].get_description(self.env)['selection']))\n        return super(SelectionConverter, self).record_to_html(record, field_name, options)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "record_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "SelectionConverter"
    },
    {
      "name": "ir.qweb.field.many2one",
      "description": "Qweb Field Many to One",
      "fields": [],
      "methods": [
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if not value:\n            return False\n        value = value.sudo().display_name\n        if not value:\n            return False\n        return nl2br(escape(value))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ManyToOneConverter"
    },
    {
      "name": "ir.qweb.field.many2many",
      "description": "Qweb field many2many",
      "fields": [],
      "methods": [
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if not value:\n            return False\n        text = ', '.join(value.sudo().mapped('display_name'))\n        return nl2br(escape(text))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ManyToManyConverter"
    },
    {
      "name": "ir.qweb.field.html",
      "description": "Qweb Field HTML",
      "fields": [],
      "methods": [
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        irQweb = self.env['ir.qweb']\n        # wrap value inside a body and parse it as HTML\n        body = etree.fromstring(\"<body>%s</body>\" % value, etree.HTMLParser(encoding='utf-8'))[0]\n        # use pos processing for all nodes with attributes\n        for element in body.iter():\n            if element.attrib:\n                attrib = dict(element.attrib)\n                attrib = irQweb._post_processing_att(element.tag, attrib)\n                element.attrib.clear()\n                element.attrib.update(attrib)\n        return Markup(etree.tostring(body, encoding='unicode', method='html')[6:-7])",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "HTMLConverter"
    },
    {
      "name": "ir.qweb.field.image",
      "description": "Qweb Field Image",
      "fields": [],
      "methods": [
        {
          "name": "_get_src_data_b64",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def _get_src_data_b64(self, value, options):\n        try:\n            img_b64 = base64.b64decode(value)\n        except binascii.Error:\n            raise ValueError(\"Invalid image content\") from None\n\n        if img_b64 and guess_mimetype(img_b64, '') == 'image/webp':\n            return self.env[\"ir.qweb\"]._get_converted_image_data_uri(value)\n\n        try:\n            image = Image.open(BytesIO(img_b64))\n            image.verify()\n        except IOError:\n            raise ValueError(\"Non-image binary fields can not be converted to HTML\") from None\n        except: # image.verify() throws \"suitable exceptions\", I have no idea what they are\n            raise ValueError(\"Invalid image content\") from None\n\n        return \"data:%s;base64,%s\" % (Image.MIME[image.format], value.decode('ascii'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        return Markup('<img src=\"%s\">') % self._get_src_data_b64(value, options)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "_get_src_data_b64 (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ImageConverter"
    },
    {
      "name": "ir.qweb.field.image_url",
      "description": "Qweb Field Image",
      "fields": [],
      "methods": [
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        return Markup('<img src=\"%s\">' % (value))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field.image"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ImageUrlConverter"
    },
    {
      "name": "ir.qweb.field.monetary",
      "description": "Qweb Field Monetary",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(MonetaryConverter, self).get_available_options()\n        options.update(\n            from_currency=dict(type='model', params='res.currency', string=_('Original currency')),\n            display_currency=dict(type='model', params='res.currency', string=_('Display currency'), required=\"value_to_html\"),\n            date=dict(type='date', string=_('Date'), description=_('Date used for the original currency (only used for t-esc). by default use the current date.')),\n            company_id=dict(type='model', params='res.company', string=_('Company'), description=_('Company used for the original currency (only used for t-esc). By default use the user company')),\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        display_currency = options['display_currency']\n\n        if not isinstance(value, (int, float)):\n            raise ValueError(_(\"The value send to monetary field is not a number.\"))\n\n        # lang.format mandates a sprintf-style format. These formats are non-\n        # minimal (they have a default fixed precision instead), and\n        # lang.format will not set one by default. currency.round will not\n        # provide one either. So we need to generate a precision value\n        # (integer > 0) from the currency's rounding (a float generally < 1.0).\n        fmt = \"%.{0}f\".format(options.get('decimal_places', display_currency.decimal_places))\n\n        if options.get('from_currency'):\n            date = options.get('date') or fields.Date.today()\n            company_id = options.get('company_id')\n            if company_id:\n                company = self.env['res.company'].browse(company_id)\n            else:\n                company = self.env.company\n            value = options['from_currency']._convert(value, display_currency, company, date)\n\n        lang = self.user_lang()\n        formatted_amount = lang.format(fmt, display_currency.round(value),\n                                grouping=True, monetary=True).replace(r' ', '\\N{NO-BREAK SPACE}').replace(r'-', '-\\N{ZERO WIDTH NO-BREAK SPACE}')\n\n        pre = post = ''\n        if display_currency.position == 'before':\n            pre = '{symbol}\\N{NO-BREAK SPACE}'.format(symbol=display_currency.symbol or '')\n        else:\n            post = '\\N{NO-BREAK SPACE}{symbol}'.format(symbol=display_currency.symbol or '')\n\n        if options.get('label_price') and lang.decimal_point in formatted_amount:\n            sep = lang.decimal_point\n            integer_part, decimal_part = formatted_amount.split(sep)\n            integer_part += sep\n            return Markup('{pre}<span class=\"oe_currency_value\">{0}</span><span class=\"oe_currency_value\" style=\"font-size:0.5em\">{1}</span>{post}').format(integer_part, decimal_part, pre=pre, post=post)\n\n        return Markup('{pre}<span class=\"oe_currency_value\">{0}</span>{post}').format(formatted_amount, pre=pre, post=post)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "record_to_html",
          "params": [
            "self",
            "record",
            "field_name",
            "options"
          ],
          "decorators": [],
          "source": "def record_to_html(self, record, field_name, options):\n        options = dict(options)\n        #currency should be specified by monetary field\n        field = record._fields[field_name]\n\n        if not options.get('display_currency') and field.type == 'monetary' and field.get_currency_field(record):\n            options['display_currency'] = record[field.get_currency_field(record)]\n        if not options.get('display_currency'):\n            # search on the model if they are a res.currency field to set as default\n            fields = record._fields.items()\n            currency_fields = [k for k, v in fields if v.type == 'many2one' and v.comodel_name == 'res.currency']\n            if currency_fields:\n                options['display_currency'] = record[currency_fields[0]]\n        if 'date' not in options:\n            options['date'] = record._context.get('date')\n        if 'company_id' not in options:\n            options['company_id'] = record._context.get('company_id')\n\n        return super(MonetaryConverter, self).record_to_html(record, field_name, options)\n\n\nTIMEDELTA_UNITS = (\n    ('year',   _lt('year'),   3600 * 24 * 365),\n    ('month',  _lt('month'),  3600 * 24 * 30),\n    ('week',   _lt('week'),   3600 * 24 * 7),\n    ('day',    _lt('day'),    3600 * 24),\n    ('hour',   _lt('hour'),   3600),\n    ('minute', _lt('minute'), 60),\n    ('second', _lt('second'), 1)\n)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "record_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "MonetaryConverter"
    },
    {
      "name": "ir.qweb.field.float_time",
      "description": "Qweb Field Float Time",
      "fields": [],
      "methods": [
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        return format_duration(value)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "FloatTimeConverter"
    },
    {
      "name": "ir.qweb.field.time",
      "description": "QWeb Field Time",
      "fields": [],
      "methods": [
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if value < 0:\n            raise ValueError(_(\"The value (%s) passed should be positive\", value))\n        hours, minutes = divmod(int(abs(value) * 60), 60)\n        if hours > 23:\n            raise ValueError(_(\"The hour must be between 0 and 23\"))\n        t = time(hour=hours, minute=minutes)\n\n        locale = babel_locale_parse(self.user_lang().code)\n        pattern = options.get('format', 'short')\n\n        return babel.dates.format_time(t, format=pattern, tzinfo=None, locale=locale)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "TimeConverter"
    },
    {
      "name": "ir.qweb.field.duration",
      "description": "Qweb Field Duration",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(DurationConverter, self).get_available_options()\n        unit = [(value, str(label)) for value, label, ratio in TIMEDELTA_UNITS]\n        options.update(\n            digital=dict(type=\"boolean\", string=_('Digital formatting')),\n            unit=dict(type=\"selection\", params=unit, string=_('Date unit'), description=_('Date unit used for comparison and formatting'), default_value='second', required=True),\n            round=dict(type=\"selection\", params=unit, string=_('Rounding unit'), description=_(\"Date unit used for the rounding. The value must be smaller than 'hour' if you use the digital formatting.\"), default_value='second'),\n            format=dict(\n                type=\"selection\",\n                params=[\n                    ('long', _('Long')),\n                    ('short', _('Short')),\n                    ('narrow', _('Narrow'))],\n                string=_('Format'),\n                description=_(\"Formatting: long, short, narrow (not used for digital)\"),\n                default_value='long'\n            ),\n            add_direction=dict(\n                type=\"boolean\",\n                string=_(\"Add direction\"),\n                description=_(\"Add directional information (not used for digital)\")\n            ),\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        units = {unit: duration for unit, label, duration in TIMEDELTA_UNITS}\n\n        locale = babel_locale_parse(self.user_lang().code)\n        factor = units[options.get('unit', 'second')]\n        round_to = units[options.get('round', 'second')]\n\n        if options.get('digital') and round_to > 3600:\n            round_to = 3600\n\n        r = round((value * factor) / round_to) * round_to\n\n        sections = []\n        sign = ''\n        if value < 0:\n            r = -r\n            sign = '-'\n\n        if options.get('digital'):\n            for unit, label, secs_per_unit in TIMEDELTA_UNITS:\n                if secs_per_unit > 3600:\n                    continue\n                v, r = divmod(r, secs_per_unit)\n                if not v and (secs_per_unit > factor or secs_per_unit < round_to):\n                    continue\n                sections.append(u\"%02.0f\" % int(round(v)))\n            return sign + u':'.join(sections)\n\n        for unit, label, secs_per_unit in TIMEDELTA_UNITS:\n            v, r = divmod(r, secs_per_unit)\n            if not v:\n                continue\n            try:\n                section = babel.dates.format_timedelta(\n                    v*secs_per_unit,\n                    granularity=round_to,\n                    add_direction=options.get('add_direction'),\n                    format=options.get('format', 'long'),\n                    threshold=1,\n                    locale=locale)\n            except KeyError:\n                # in case of wrong implementation of babel, try to fallback on en_US locale.\n                # https://github.com/python-babel/babel/pull/827/files\n                # Some bugs already fixed in 2.10 but ubuntu22 is 2.8\n                localeUS = babel_locale_parse('en_US')\n                section = babel.dates.format_timedelta(\n                    v*secs_per_unit,\n                    granularity=round_to,\n                    add_direction=options.get('add_direction'),\n                    format=options.get('format', 'long'),\n                    threshold=1,\n                    locale=localeUS)\n            if section:\n                sections.append(section)\n\n        if sign:\n            sections.insert(0, sign)\n        return u' '.join(sections)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "DurationConverter"
    },
    {
      "name": "ir.qweb.field.relative",
      "description": "Qweb Field Relative",
      "fields": [
        {
          "name": "value",
          "type": "Datetime.from_string"
        },
        {
          "name": "reference",
          "type": "Datetime.from_string"
        }
      ],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(RelativeDatetimeConverter, self).get_available_options()\n        options.update(\n            now=dict(type='datetime', string=_('Reference date'), description=_('Date to compare with the field value, by default use the current date.'))\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        locale = babel_locale_parse(self.user_lang().code)\n\n        if isinstance(value, str):\n            value = fields.Datetime.from_string(value)\n\n        # value should be a naive datetime in UTC. So is fields.Datetime.now()\n        reference = fields.Datetime.from_string(options['now'])\n\n        return pycompat.to_text(babel.dates.format_timedelta(value - reference, add_direction=True, locale=locale))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "record_to_html",
          "params": [
            "self",
            "record",
            "field_name",
            "options"
          ],
          "decorators": [],
          "source": "def record_to_html(self, record, field_name, options):\n        if 'now' not in options:\n            options = dict(options, now=record._fields[field_name].now())\n        return super(RelativeDatetimeConverter, self).record_to_html(record, field_name, options)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "record_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "RelativeDatetimeConverter"
    },
    {
      "name": "ir.qweb.field.barcode",
      "description": "Qweb Field Barcode",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(BarcodeConverter, self).get_available_options()\n        options.update(\n            symbology=dict(type='string', string=_('Barcode symbology'), description=_('Barcode type, eg: UPCA, EAN13, Code128'), default_value='Code128'),\n            width=dict(type='integer', string=_('Width'), default_value=600),\n            height=dict(type='integer', string=_('Height'), default_value=100),\n            humanreadable=dict(type='integer', string=_('Human Readable'), default_value=0),\n            quiet=dict(type='integer', string='Quiet', default_value=1),\n            mask=dict(type='string', string='Mask', default_value='')\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options=None"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options=None):\n        if not value:\n            return ''\n        barcode_symbology = options.get('symbology', 'Code128')\n        barcode = self.env['ir.actions.report'].barcode(\n            barcode_symbology,\n            value,\n            **{key: value for key, value in options.items() if key in ['width', 'height', 'humanreadable', 'quiet', 'mask']})\n\n        img_element = html.Element('img')\n        for k, v in options.items():\n            if k.startswith('img_') and k[4:] in safe_attrs:\n                img_element.set(k[4:], v)\n        if not img_element.get('alt'):\n            img_element.set('alt', _('Barcode %s', value))\n        img_element.set('src', 'data:image/png;base64,%s' % base64.b64encode(barcode).decode())\n        return Markup(html.tostring(img_element, encoding='unicode'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "BarcodeConverter"
    },
    {
      "name": "ir.qweb.field.contact",
      "description": "Qweb Field Contact",
      "fields": [],
      "methods": [
        {
          "name": "get_available_options",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available_options(self):\n        options = super(Contact, self).get_available_options()\n        contact_fields = [\n            {'field_name': 'name', 'label': _('Name'), 'default': True},\n            {'field_name': 'address', 'label': _('Address'), 'default': True},\n            {'field_name': 'phone', 'label': _('Phone'), 'default': True},\n            {'field_name': 'mobile', 'label': _('Mobile'), 'default': True},\n            {'field_name': 'email', 'label': _('Email'), 'default': True},\n            {'field_name': 'vat', 'label': _('VAT')},\n        ]\n        separator_params = dict(\n            type='selection',\n            selection=[[\" \", _(\"Space\")], [\",\", _(\"Comma\")], [\"-\", _(\"Dash\")], [\"|\", _(\"Vertical bar\")], [\"/\", _(\"Slash\")]],\n            placeholder=_('Linebreak'),\n        )\n        options.update(\n            fields=dict(type='array', params=dict(type='selection', params=contact_fields), string=_('Displayed fields'), description=_('List of contact fields to display in the widget'), default_value=[param.get('field_name') for param in contact_fields if param.get('default')]),\n            separator=dict(type='selection', params=separator_params, string=_('Address separator'), description=_('Separator use to split the address from the display_name.'), default_value=False),\n            no_marker=dict(type='boolean', string=_('Hide badges'), description=_(\"Don't display the font awesome marker\")),\n            no_tag_br=dict(type='boolean', string=_('Use comma'), description=_(\"Use comma instead of the <br> tag to display the address\")),\n            phone_icons=dict(type='boolean', string=_('Display phone icons'), description=_(\"Display the phone icons even if no_marker is True\")),\n            country_image=dict(type='boolean', string=_('Display country image'), description=_(\"Display the country image if the field is present on the record\")),\n        )\n        return options",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "value_to_html",
          "params": [
            "self",
            "value",
            "options"
          ],
          "decorators": [],
          "source": "def value_to_html(self, value, options):\n        if not value:\n            if options.get('null_text'):\n                val = {\n                    'options': options,\n                }\n                template_options = options.get('template_options', {})\n                return self.env['ir.qweb']._render('base.no_contact', val, **template_options)\n            return ''\n\n        opf = options.get('fields') or [\"name\", \"address\", \"phone\", \"mobile\", \"email\"]\n        sep = options.get('separator')\n        if sep:\n            opsep = escape(sep)\n        elif options.get('no_tag_br'):\n            # escaped joiners will auto-escape joined params\n            opsep = escape(', ')\n        else:\n            opsep = Markup('<br/>')\n\n        value = value.sudo().with_context(show_address=True)\n        display_name = value.display_name or ''\n        # Avoid having something like:\n        # display_name = 'Foo\\n  \\n' -> This is a res.partner with a name and no address\n        # That would return markup('<br/>') as address. But there is no address set.\n        if any(elem.strip() for elem in display_name.split(\"\\n\")[1:]):\n            address = opsep.join(display_name.split(\"\\n\")[1:]).strip()\n        else:\n            address = ''\n        val = {\n            'name': display_name.split(\"\\n\")[0],\n            'address': address,\n            'phone': value.phone,\n            'mobile': value.mobile,\n            'city': value.city,\n            'country_id': value.country_id.display_name,\n            'website': value.website,\n            'email': value.email,\n            'vat': value.vat,\n            'vat_label': value.country_id.vat_label or _('VAT'),\n            'fields': opf,\n            'object': value,\n            'options': options\n        }\n        return self.env['ir.qweb']._render('base.contact', val, minimal_qcontext=True)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field.many2one"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_available_options (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "value_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Contact"
    },
    {
      "name": "ir.qweb.field.qweb",
      "description": "Qweb Field qweb",
      "fields": [],
      "methods": [
        {
          "name": "record_to_html",
          "params": [
            "self",
            "record",
            "field_name",
            "options"
          ],
          "decorators": [],
          "source": "def record_to_html(self, record, field_name, options):\n        view = record[field_name]\n        if not view:\n            return ''\n\n        if view._name != \"ir.ui.view\":\n            _logger.warning(\"%s.%s must be a 'ir.ui.view', got %r.\", record, field_name, view._name)\n            return ''\n\n        return self.env['ir.qweb']._render(view.id, options.get('values', {}))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.qweb.field.many2one"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "record_to_html (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "QwebView"
    },
    {
      "name": "ir.rule",
      "description": "Record Rule",
      "fields": [
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "required": true,
          "string": "Model"
        },
        {
          "name": "groups",
          "type": "Many2many",
          "relation": "res.groups"
        },
        {
          "name": "domain_force",
          "type": "Text",
          "string": "Domain"
        },
        {
          "name": "perm_read",
          "type": "Boolean",
          "string": "Read"
        },
        {
          "name": "perm_write",
          "type": "Boolean",
          "string": "Write"
        },
        {
          "name": "perm_create",
          "type": "Boolean",
          "string": "Create"
        },
        {
          "name": "perm_unlink",
          "type": "Boolean",
          "string": "Delete"
        },
        {
          "name": "global_",
          "type": "Boolean",
          "help": "If no group is specified the rule is global and applied to everyone"
        }
      ],
      "methods": [
        {
          "name": "_eval_context",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _eval_context(self):\n        \"\"\"Returns a dictionary to use as evaluation context for\n           ir.rule domains.\n           Note: company_ids contains the ids of the activated companies\n           by the user with the switch company menu. These companies are\n           filtered and trusted.\n        \"\"\"\n        # use an empty context for 'user' to make the domain evaluation\n        # independent from the context\n        return {\n            'user': self.env.user.with_context({}),\n            'time': time,\n            'company_ids': self.env.companies.ids,\n            'company_id': self.env.company.id,\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_global",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_global(self):\n        for rule in self:\n            rule['global'] = not rule.groups",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_model_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_model_name(self):\n        # Don't allow rules on rules records (this model).\n        if any(rule.model_id.model == self._name for rule in self):\n            raise ValidationError(_('Rules can not be applied on the Record Rules model.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_domain",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_domain(self):\n        eval_context = self._eval_context()\n        for rule in self:\n            if rule.active and rule.domain_force:\n                try:\n                    domain = safe_eval(rule.domain_force, eval_context)\n                    expression.expression(domain, self.env[rule.model_id.model].sudo())\n                except Exception as e:\n                    raise ValidationError(_('Invalid domain: %s', e))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_domain_keys",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_domain_keys(self):\n        \"\"\" Return the list of context keys to use for caching ``_compute_domain``. \"\"\"\n        return ['allowed_company_ids']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_failing",
          "params": [
            "self",
            "for_records",
            "mode='read'"
          ],
          "decorators": [],
          "source": "def _get_failing(self, for_records, mode='read'):\n        \"\"\" Returns the rules for the mode for the current user which fail on\n        the specified records.\n\n        Can return any global rule and/or all local rules (since local rules\n        are OR-ed together, the entire group succeeds or fails, while global\n        rules get AND-ed and can each fail)\n        \"\"\"\n        Model = for_records.browse(()).sudo()\n        eval_context = self._eval_context()\n\n        all_rules = self._get_rules(Model._name, mode=mode).sudo()\n\n        # first check if the group rules fail for any record (aka if\n        # searching on (records, group_rules) filters out some of the records)\n        group_rules = all_rules.filtered(lambda r: r.groups and r.groups & self.env.user.groups_id)\n        group_domains = expression.OR([\n            safe_eval(r.domain_force, eval_context) if r.domain_force else []\n            for r in group_rules\n        ])\n        # if all records get returned, the group rules are not failing\n        if Model.search_count(expression.AND([[('id', 'in', for_records.ids)], group_domains])) == len(for_records):\n            group_rules = self.browse(())\n\n        # failing rules are previously selected group rules or any failing global rule",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "is_failing",
          "params": [
            "r",
            "ids=for_records.ids"
          ],
          "decorators": [],
          "source": "def is_failing(r, ids=for_records.ids):\n            dom = safe_eval(r.domain_force, eval_context) if r.domain_force else []\n            return Model.search_count(expression.AND([\n                [('id', 'in', ids)],\n                expression.normalize_domain(dom)\n            ])) < len(ids)\n\n        return all_rules.filtered(lambda r: r in group_rules or (not r.groups and is_failing(r))).with_user(self.env.user)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_rules",
          "params": [
            "self",
            "model_name",
            "mode='read'"
          ],
          "decorators": [],
          "source": "def _get_rules(self, model_name, mode='read'):\n        \"\"\" Returns all the rules matching the model for the mode for the\n        current user.\n        \"\"\"\n        if mode not in self._MODES:\n            raise ValueError('Invalid mode: %r' % (mode,))\n\n        if self.env.su:\n            return self.browse(())\n\n        query = \"\"\" SELECT r.id FROM ir_rule r JOIN ir_model m ON (r.model_id=m.id)\n                    WHERE m.model=%s AND r.active AND r.perm_{mode}\n                    AND (r.id IN (SELECT rule_group_id FROM rule_group_rel rg\n                                  JOIN res_groups_users_rel gu ON (rg.group_id=gu.gid)\n                                  WHERE gu.uid=%s)\n                         OR r.global)\n                    ORDER BY r.id\n                \"\"\".format(mode=mode)\n        self._cr.execute(query, (model_name, self._uid))\n        return self.browse(row[0] for row in self._cr.fetchall())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_domain",
          "params": [
            "self",
            "model_name",
            "mode=\"read\""
          ],
          "decorators": [],
          "source": "def _compute_domain(self, model_name, mode=\"read\"):\n        global_domains = []                     # list of domains\n\n        # add rules for parent models\n        for parent_model_name, parent_field_name in self.env[model_name]._inherits.items():\n            if domain := self._compute_domain(parent_model_name, mode):\n                global_domains.append([(parent_field_name, 'any', domain)])\n\n        rules = self._get_rules(model_name, mode=mode)\n        if not rules:\n            return expression.AND(global_domains) if global_domains else []\n\n        # browse user and rules with sudo to avoid access errors!\n        eval_context = self._eval_context()\n        user_groups = self.env.user.groups_id\n        group_domains = []                      # list of domains\n        for rule in rules.sudo():\n            # evaluate the domain for the current user\n            dom = safe_eval(rule.domain_force, eval_context) if rule.domain_force else []\n            dom = expression.normalize_domain(dom)\n            if not rule.groups:\n                global_domains.append(dom)\n            elif rule.groups & user_groups:\n                group_domains.append(dom)\n\n        # combine global domains and group domains\n        if not group_domains:\n            return expression.AND(global_domains)\n        return expression.AND(global_domains + [expression.OR(group_domains)])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_domain_context_values",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_domain_context_values(self):\n        for k in self._compute_domain_keys():\n            v = self._context.get(k)\n            if isinstance(v, list):\n                # currently this could be a frozenset (to avoid depending on\n                # the order of allowed_company_ids) but it seems safer if\n                # possibly slightly more miss-y to use a tuple\n                v = tuple(v)\n            yield v",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        res = super(IrRule, self).unlink()\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        res = super(IrRule, self).create(vals_list)\n        # DLE P33: tests\n        self.env.flush_all()\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        res = super(IrRule, self).write(vals)\n        # DLE P33: tests\n        # - odoo/addons/test_access_rights/tests/test_feedback.py\n        # - odoo/addons/test_access_rights/tests/test_ir_rules.py\n        # - odoo/addons/base/tests/test_orm.py (/home/dle/src/odoo/master-nochange-fp/odoo/addons/base/tests/test_orm.py)\n        self.env.flush_all()\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_make_access_error",
          "params": [
            "self",
            "operation",
            "records"
          ],
          "decorators": [],
          "source": "def _make_access_error(self, operation, records):\n        _logger.info('Access Denied by record rules for operation: %s on record ids: %r, uid: %s, model: %s', operation, records.ids[:6], self._uid, records._name)\n        self = self.with_context(self.env.user.context_get())\n\n        model = records._name\n        description = self.env['ir.model']._get(model).name or model\n        operations = {\n            'read':  _(\"read\"),\n            'write': _(\"write\"),\n            'create': _(\"create\"),\n            'unlink': _(\"unlink\"),\n        }\n        user_description = f\"{self.env.user.name} (id={self.env.user.id})\"\n        operation_error = _(\"Uh-oh! Looks like you have stumbled upon some top-secret records.\\n\\n\" \\\n            \"Sorry, %s doesn't have '%s' access to:\", user_description, operations[operation])\n        failing_model = _(\"- %s (%s)\", description, model)\n\n        resolution_info = _(\"If you really, really need access, perhaps you can win over your friendly administrator with a batch of freshly baked cookies.\")\n\n        if not self.user_has_groups('base.group_no_one') or not self.env.user.has_group('base.group_user'):\n            records.invalidate_recordset()\n            return AccessError(f\"{operation_error}\\n{failing_model}\\n\\n{resolution_info}\")\n\n        # This extended AccessError is only displayed in debug mode.\n        # Note that by default, public and portal users do not have\n        # the group \"base.group_no_one\", even if debug mode is enabled,\n        # so it is relatively safe here to include the list of rules and record names.\n        rules = self._get_failing(records, mode=operation).sudo()\n\n        records_sudo = records[:6].sudo()\n        company_related = any('company_id' in (r.domain_force or '') for r in rules)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_record_description",
          "params": [
            "rec"
          ],
          "decorators": [],
          "source": "def get_record_description(rec):\n            # If the user has access to the company of the record, add this\n            # information in the description to help them to change company\n            if company_related and 'company_id' in rec and rec.company_id in self.env.user.company_ids:\n                return f'{description}, {rec.display_name} ({model}: {rec.id}, company={rec.company_id.display_name})'\n            return f'{description}, {rec.display_name} ({model}: {rec.id})'\n\n        failing_records = '\\n '.join(f'- {get_record_description(rec)}' for rec in records_sudo)\n\n        rules_description = '\\n'.join(f'- {rule.name}' for rule in rules)\n        failing_rules = _(\"Blame the following rules:\\n%s\", rules_description)\n\n        if company_related:\n            failing_rules += \"\\n\\n\" + _('Note: this might be a multi-company issue. Switching company may help - in Odoo, not in real life!')\n\n        # clean up the cache of records prefetched with display_name above\n        records_sudo.invalidate_recordset()\n\n        msg = f\"{operation_error}\\n{failing_records}\\n\\n{failing_rules}\\n\\n{resolution_info}\"\n        return AccessError(msg)\n\n\n#\n# Hack for field 'global': this field cannot be defined like others, because\n# 'global' is a Python keyword. Therefore, we add it to the class by assignment.\n# Note that the attribute '_module' is normally added by the class' metaclass.\n#\nglobal_ = fields.Boolean(compute='_compute_global', store=True,\n                         help=\"If no group is specified the rule is global and applied to everyone\")\nsetattr(IrRule, 'global', global_)\nglobal_.__set_name__(IrRule, 'global')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "no_access_rights",
          "definition": "CHECK (perm_read!=False or perm_write!=False or perm_create!=False or perm_unlink!=False)",
          "message": "Rule must have at least one checked access right!"
        },
        {
          "type": "python",
          "name": "_check_model_name",
          "definition": "@api.constrains('model_id')\n    def _check_model_name(self):\n        # Don't allow rules on rules records (this model).\n        if any(rule.model_id.model == self._name for rule in self):\n            raise ValidationError(_('Rules can not be applied on the Record Rules model.'))",
          "message": "'model_id'"
        },
        {
          "type": "python",
          "name": "_check_domain",
          "definition": "@api.constrains('active', 'domain_force', 'model_id')\n    def _check_domain(self):\n        eval_context = self._eval_context()\n        for rule in self:\n            if rule.active and rule.domain_force:\n                try:\n                    domain = safe_eval(rule.domain_force, eval_context)\n                    expression.expression(domain, self.env[rule.model_id.model].sudo())\n                except Exception as e:\n                    raise ValidationError(_('Invalid domain: %s', e))",
          "message": "'active', 'domain_force', 'model_id'"
        }
      ],
      "accessRules": [
        {
          "name": "_eval_context (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrRule"
    },
    {
      "name": "ir.sequence",
      "description": "Sequence",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "code",
          "type": "Char",
          "string": "Sequence Code"
        },
        {
          "name": "implementation",
          "type": "Selection"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "prefix",
          "type": "Char",
          "help": "Prefix value of the record for the sequence"
        },
        {
          "name": "suffix",
          "type": "Char",
          "help": "Suffix value of the record for the sequence"
        },
        {
          "name": "number_next",
          "type": "Integer",
          "required": true,
          "string": "Next Number",
          "help": "Next number of this sequence"
        },
        {
          "name": "number_next_actual",
          "type": "Integer",
          "string": "Actual Next Number",
          "help": "Next number that will be used. This number can be incremented "
        },
        {
          "name": "number_increment",
          "type": "Integer",
          "required": true,
          "string": "Step",
          "help": "The next number of the sequence will be incremented by this number"
        },
        {
          "name": "padding",
          "type": "Integer",
          "required": true,
          "string": "Sequence Size",
          "help": "Odoo will automatically adds some "
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company",
          "string": "Company"
        },
        {
          "name": "use_date_range",
          "type": "Boolean",
          "string": "Use subsequences per date_range"
        },
        {
          "name": "date_range_ids",
          "type": "One2many",
          "relation": "ir.sequence.date_range",
          "string": "Subsequences"
        },
        {
          "name": "effective_date",
          "type": "Datetime.from_string"
        },
        {
          "name": "range_date",
          "type": "Datetime.from_string"
        },
        {
          "name": "year",
          "type": "Date.from_string"
        }
      ],
      "methods": [
        {
          "name": "_get_number_next_actual",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_number_next_actual(self):\n        '''Return number from ir_sequence row when no_gap implementation,\n        and number from postgres sequence when standard implementation.'''\n        for seq in self:\n            if not seq.id:\n                seq.number_next_actual = 0\n            elif seq.implementation != 'standard':\n                seq.number_next_actual = seq.number_next\n            else:\n                seq_id = \"%03d\" % seq.id\n                seq.number_next_actual = _predict_nextval(self, seq_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_number_next_actual",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _set_number_next_actual(self):\n        for seq in self:\n            seq.write({'number_next': seq.number_next_actual or 1})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_current_sequence",
          "params": [
            "self",
            "sequence_date=None"
          ],
          "decorators": [],
          "source": "def _get_current_sequence(self, sequence_date=None):\n        '''Returns the object on which we can find the number_next to consider for the sequence.\n        It could be an ir.sequence or an ir.sequence.date_range depending if use_date_range is checked\n        or not. This function will also create the ir.sequence.date_range if none exists yet for today\n        '''\n        if not self.use_date_range:\n            return self\n        sequence_date = sequence_date or fields.Date.today()\n        seq_date = self.env['ir.sequence.date_range'].search(\n            [('sequence_id', '=', self.id), ('date_from', '<=', sequence_date), ('date_to', '>=', sequence_date)], limit=1)\n        if seq_date:\n            return seq_date[0]\n        #no date_range sequence was found, we create a new one\n        return self._create_date_range_seq(sequence_date)\n\n    name = fields.Char(required=True)\n    code = fields.Char(string='Sequence Code')\n    implementation = fields.Selection([('standard', 'Standard'), ('no_gap', 'No gap')],\n                                      string='Implementation', required=True, default='standard',\n                                      help=\"While assigning a sequence number to a record, the 'no gap' sequence implementation ensures that each previous sequence number has been assigned already. \"\n                                      \"While this sequence implementation will not skip any sequence number upon assignment, there can still be gaps in the sequence if records are deleted. \"\n                                      \"The 'no gap' implementation is slower than the standard one.\")\n    active = fields.Boolean(default=True)\n    prefix = fields.Char(help=\"Prefix value of the record for the sequence\", trim=False)\n    suffix = fields.Char(help=\"Suffix value of the record for the sequence\", trim=False)\n    number_next = fields.Integer(string='Next Number', required=True, default=1, help=\"Next number of this sequence\")\n    number_next_actual = fields.Integer(compute='_get_number_next_actual', inverse='_set_number_next_actual',\n                                        string='Actual Next Number',\n                                        help=\"Next number that will be used. This number can be incremented \"\n                                        \"frequently so the displayed value might already be obsolete\")\n    number_increment = fields.Integer(string='Step', required=True, default=1,\n                                      help=\"The next number of the sequence will be incremented by this number\")\n    padding = fields.Integer(string='Sequence Size', required=True, default=0,\n                             help=\"Odoo will automatically adds some '0' on the left of the \"\n                                  \"'Next Number' to get the required padding size.\")\n    company_id = fields.Many2one('res.company', string='Company',\n                                 default=lambda s: s.env.company)\n    use_date_range = fields.Boolean(string='Use subsequences per date_range')\n    date_range_ids = fields.One2many('ir.sequence.date_range', 'sequence_id', string='Subsequences')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        \"\"\" Create a sequence, in implementation == standard a fast gaps-allowed PostgreSQL sequence is used.\n        \"\"\"\n        seqs = super().create(vals_list)\n        for seq in seqs:\n            if seq.implementation == 'standard':\n                _create_sequence(self._cr, \"ir_sequence_%03d\" % seq.id, seq.number_increment or 1, seq.number_next or 1)\n        return seqs",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        _drop_sequences(self._cr, [\"ir_sequence_%03d\" % x.id for x in self])\n        return super(IrSequence, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        new_implementation = values.get('implementation')\n        for seq in self:\n            # 4 cases: we test the previous impl. against the new one.\n            i = values.get('number_increment', seq.number_increment)\n            n = values.get('number_next', seq.number_next)\n            if seq.implementation == 'standard':\n                if new_implementation in ('standard', None):\n                    # Implementation has NOT changed.\n                    # Only change sequence if really requested.\n                    if values.get('number_next'):\n                        _alter_sequence(self._cr, \"ir_sequence_%03d\" % seq.id, number_next=n)\n                    if seq.number_increment != i:\n                        _alter_sequence(self._cr, \"ir_sequence_%03d\" % seq.id, number_increment=i)\n                        seq.date_range_ids._alter_sequence(number_increment=i)\n                else:\n                    _drop_sequences(self._cr, [\"ir_sequence_%03d\" % seq.id])\n                    for sub_seq in seq.date_range_ids:\n                        _drop_sequences(self._cr, [\"ir_sequence_%03d_%03d\" % (seq.id, sub_seq.id)])\n            else:\n                if new_implementation in ('no_gap', None):\n                    pass\n                else:\n                    _create_sequence(self._cr, \"ir_sequence_%03d\" % seq.id, i, n)\n                    for sub_seq in seq.date_range_ids:\n                        _create_sequence(self._cr, \"ir_sequence_%03d_%03d\" % (seq.id, sub_seq.id), i, n)\n        res = super(IrSequence, self).write(values)\n        # DLE P179\n        self.flush_model(values.keys())\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_next_do",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _next_do(self):\n        if self.implementation == 'standard':\n            number_next = _select_nextval(self._cr, 'ir_sequence_%03d' % self.id)\n        else:\n            number_next = _update_nogap(self, self.number_increment)\n        return self.get_next_char(number_next)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_prefix_suffix",
          "params": [
            "self",
            "date=None",
            "date_range=None"
          ],
          "decorators": [],
          "source": "def _get_prefix_suffix(self, date=None, date_range=None):",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_interpolate",
          "params": [
            "s",
            "d"
          ],
          "decorators": [],
          "source": "def _interpolate(s, d):\n            return (s % d) if s else ''",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_interpolation_dict",
          "params": [],
          "decorators": [],
          "source": "def _interpolation_dict():\n            now = range_date = effective_date = datetime.now(pytz.timezone(self._context.get('tz') or 'UTC'))\n            if date or self._context.get('ir_sequence_date'):\n                effective_date = fields.Datetime.from_string(date or self._context.get('ir_sequence_date'))\n            if date_range or self._context.get('ir_sequence_date_range'):\n                range_date = fields.Datetime.from_string(date_range or self._context.get('ir_sequence_date_range'))\n\n            sequences = {\n                'year': '%Y', 'month': '%m', 'day': '%d', 'y': '%y', 'doy': '%j', 'woy': '%W',\n                'weekday': '%w', 'h24': '%H', 'h12': '%I', 'min': '%M', 'sec': '%S'\n            }\n            res = {}\n            for key, format in sequences.items():\n                res[key] = effective_date.strftime(format)\n                res['range_' + key] = range_date.strftime(format)\n                res['current_' + key] = now.strftime(format)\n\n            return res\n\n        self.ensure_one()\n        d = _interpolation_dict()\n        try:\n            interpolated_prefix = _interpolate(self.prefix, d)\n            interpolated_suffix = _interpolate(self.suffix, d)\n        except (ValueError, TypeError):\n            raise UserError(_('Invalid prefix or suffix for sequence %r', self.name))\n        return interpolated_prefix, interpolated_suffix",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_next_char",
          "params": [
            "self",
            "number_next"
          ],
          "decorators": [],
          "source": "def get_next_char(self, number_next):\n        interpolated_prefix, interpolated_suffix = self._get_prefix_suffix()\n        return interpolated_prefix + '%%0%sd' % self.padding % number_next + interpolated_suffix",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_create_date_range_seq",
          "params": [
            "self",
            "date"
          ],
          "decorators": [],
          "source": "def _create_date_range_seq(self, date):\n        year = fields.Date.from_string(date).strftime('%Y')\n        date_from = '{}-01-01'.format(year)\n        date_to = '{}-12-31'.format(year)\n        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_from', '>=', date), ('date_from', '<=', date_to)], order='date_from desc', limit=1)\n        if date_range:\n            date_to = date_range.date_from + timedelta(days=-1)\n        date_range = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_to', '>=', date_from), ('date_to', '<=', date)], order='date_to desc', limit=1)\n        if date_range:\n            date_from = date_range.date_to + timedelta(days=1)\n        seq_date_range = self.env['ir.sequence.date_range'].sudo().create({\n            'date_from': date_from,\n            'date_to': date_to,\n            'sequence_id': self.id,\n        })\n        return seq_date_range",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_next",
          "params": [
            "self",
            "sequence_date=None"
          ],
          "decorators": [],
          "source": "def _next(self, sequence_date=None):\n        \"\"\" Returns the next number in the preferred sequence in all the ones given in self.\"\"\"\n        if not self.use_date_range:\n            return self._next_do()\n        # date mode\n        dt = sequence_date or self._context.get('ir_sequence_date', fields.Date.today())\n        seq_date = self.env['ir.sequence.date_range'].search([('sequence_id', '=', self.id), ('date_from', '<=', dt), ('date_to', '>=', dt)], limit=1)\n        if not seq_date:\n            seq_date = self._create_date_range_seq(dt)\n        return seq_date.with_context(ir_sequence_date_range=seq_date.date_from)._next()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "next_by_id",
          "params": [
            "self",
            "sequence_date=None"
          ],
          "decorators": [],
          "source": "def next_by_id(self, sequence_date=None):\n        \"\"\" Draw an interpolated string using the specified sequence.\"\"\"\n        self.check_access_rights('read')\n        return self._next(sequence_date=sequence_date)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "next_by_code",
          "params": [
            "self",
            "sequence_code",
            "sequence_date=None"
          ],
          "decorators": [],
          "source": "def next_by_code(self, sequence_code, sequence_date=None):\n        \"\"\" Draw an interpolated string using a sequence with the requested code.\n            If several sequences with the correct code are available to the user\n            (multi-company cases), the one from the user's current company will\n            be used.\n        \"\"\"\n        self.check_access_rights('read')\n        company_id = self.env.company.id\n        seq_ids = self.search([('code', '=', sequence_code), ('company_id', 'in', [company_id, False])], order='company_id')\n        if not seq_ids:\n            _logger.debug(\"No ir.sequence has been found for code '%s'. Please make sure a sequence is set for current company.\" % sequence_code)\n            return False\n        seq_id = seq_ids[0]\n        return seq_id._next(sequence_date=sequence_date)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_id",
          "params": [
            "self",
            "sequence_code_or_id",
            "code_or_id='id'"
          ],
          "decorators": [],
          "source": "def get_id(self, sequence_code_or_id, code_or_id='id'):\n        \"\"\" Draw an interpolated string using the specified sequence.\n\n        The sequence to use is specified by the ``sequence_code_or_id``\n        argument, which can be a code or an id (as controlled by the\n        ``code_or_id`` argument. This method is deprecated.\n        \"\"\"\n        _logger.warning(\"ir_sequence.get() and ir_sequence.get_id() are deprecated. \"\n                        \"Please use ir_sequence.next_by_code() or ir_sequence.next_by_id().\")\n        if code_or_id == 'id':\n            return self.browse(sequence_code_or_id).next_by_id()\n        else:\n            return self.next_by_code(sequence_code_or_id)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get",
          "params": [
            "self",
            "code"
          ],
          "decorators": [],
          "source": "def get(self, code):\n        \"\"\" Draw an interpolated string using the specified sequence.\n\n        The sequence to use is specified by its code. This method is\n        deprecated.\n        \"\"\"\n        return self.get_id(code, 'code')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_get_current_sequence (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "next_by_code (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrSequence"
    },
    {
      "name": "ir.sequence.date_range",
      "description": "Sequence Date Range",
      "fields": [
        {
          "name": "date_from",
          "type": "Date",
          "required": true,
          "string": "From"
        },
        {
          "name": "date_to",
          "type": "Date",
          "required": true,
          "string": "To"
        },
        {
          "name": "sequence_id",
          "type": "Many2one",
          "relation": "ir.sequence",
          "required": true,
          "string": "Main Sequence"
        },
        {
          "name": "number_next",
          "type": "Integer",
          "required": true,
          "string": "Next Number",
          "help": "Next number of this sequence"
        },
        {
          "name": "number_next_actual",
          "type": "Integer",
          "string": "Actual Next Number",
          "help": "Next number that will be used. This number can be incremented "
        }
      ],
      "methods": [
        {
          "name": "_get_number_next_actual",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_number_next_actual(self):\n        '''Return number from ir_sequence row when no_gap implementation,\n        and number from postgres sequence when standard implementation.'''\n        for seq in self:\n            if seq.sequence_id.implementation != 'standard':\n                seq.number_next_actual = seq.number_next\n            else:\n                seq_id = \"%03d_%03d\" % (seq.sequence_id.id, seq.id)\n                seq.number_next_actual = _predict_nextval(self, seq_id)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_number_next_actual",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _set_number_next_actual(self):\n        for seq in self:\n            seq.write({'number_next': seq.number_next_actual or 1})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "default_get",
          "params": [
            "self",
            "fields"
          ],
          "decorators": [],
          "source": "def default_get(self, fields):\n        result = super(IrSequenceDateRange, self).default_get(fields)\n        if 'number_next_actual' in fields:\n            result['number_next_actual'] = 1\n        return result\n\n    date_from = fields.Date(string='From', required=True)\n    date_to = fields.Date(string='To', required=True)\n    sequence_id = fields.Many2one(\"ir.sequence\", string='Main Sequence', required=True, ondelete='cascade')\n    number_next = fields.Integer(string='Next Number', required=True, default=1, help=\"Next number of this sequence\")\n    number_next_actual = fields.Integer(compute='_get_number_next_actual', inverse='_set_number_next_actual',\n                                        string='Actual Next Number',\n                                        help=\"Next number that will be used. This number can be incremented \"\n                                             \"frequently so the displayed value might already be obsolete\")",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_next",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _next(self):\n        if self.sequence_id.implementation == 'standard':\n            number_next = _select_nextval(self._cr, 'ir_sequence_%03d_%03d' % (self.sequence_id.id, self.id))\n        else:\n            number_next = _update_nogap(self, self.sequence_id.number_increment)\n        return self.sequence_id.get_next_char(number_next)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_alter_sequence",
          "params": [
            "self",
            "number_increment=None",
            "number_next=None"
          ],
          "decorators": [],
          "source": "def _alter_sequence(self, number_increment=None, number_next=None):\n        for seq in self:\n            _alter_sequence(self._cr, \"ir_sequence_%03d_%03d\" % (seq.sequence_id.id, seq.id), number_increment=number_increment, number_next=number_next)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        \"\"\" Create a sequence, in implementation == standard a fast gaps-allowed PostgreSQL sequence is used.\n        \"\"\"\n        seqs = super().create(vals_list)\n        for seq in seqs:\n            main_seq = seq.sequence_id\n            if main_seq.implementation == 'standard':\n                _create_sequence(self._cr, \"ir_sequence_%03d_%03d\" % (main_seq.id, seq.id), main_seq.number_increment, seq.number_next_actual or 1)\n        return seqs",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        _drop_sequences(self._cr, [\"ir_sequence_%03d_%03d\" % (x.sequence_id.id, x.id) for x in self])\n        return super(IrSequenceDateRange, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        if values.get('number_next'):\n            seq_to_alter = self.filtered(lambda seq: seq.sequence_id.implementation == 'standard')\n            seq_to_alter._alter_sequence(number_next=values.get('number_next'))\n        # DLE P179: `test_in_invoice_line_onchange_sequence_number_1`\n        # _update_nogap do a select to get the next sequence number_next\n        # When changing (writing) the number next of a sequence, the number next must be flushed before doing the select.\n        # Normally in such a case, we flush just above the execute, but for the sake of performance\n        # I believe this is better to flush directly in the write:\n        #  - Changing the number next of a sequence is really really rare,\n        #  - But selecting the number next happens a lot,\n        # Therefore, if I chose to put the flush just above the select, it would check the flush most of the time for no reason.\n        res = super(IrSequenceDateRange, self).write(values)\n        self.flush_model(values.keys())\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "default_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrSequenceDateRange"
    },
    {
      "name": "ir.ui.menu",
      "description": "Menu",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Menu"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "sequence",
          "type": "Integer"
        },
        {
          "name": "child_id",
          "type": "One2many",
          "relation": "ir.ui.menu",
          "string": "Child IDs"
        },
        {
          "name": "parent_id",
          "type": "Many2one",
          "relation": "ir.ui.menu",
          "string": "Parent Menu"
        },
        {
          "name": "parent_path",
          "type": "Char"
        },
        {
          "name": "groups_id",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Groups",
          "help": "If you have groups, the visibility of this menu will be based on these groups. "
        },
        {
          "name": "complete_name",
          "type": "Char",
          "string": "Full Path"
        },
        {
          "name": "web_icon",
          "type": "Char",
          "string": "Web Icon File"
        },
        {
          "name": "action",
          "type": "Reference"
        },
        {
          "name": "web_icon_data",
          "type": "Binary",
          "string": "Web Icon Image"
        }
      ],
      "methods": [
        {
          "name": "_compute_complete_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_complete_name(self):\n        for menu in self:\n            menu.complete_name = menu._get_full_name()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_full_name",
          "params": [
            "self",
            "level=6"
          ],
          "decorators": [],
          "source": "def _get_full_name(self, level=6):\n        \"\"\" Return the full name of ``self`` (up to a certain level). \"\"\"\n        if level <= 0:\n            return '...'\n        if self.parent_id:\n            return self.parent_id._get_full_name(level - 1) + MENU_ITEM_SEPARATOR + (self.name or \"\")\n        else:\n            return self.name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_read_image",
          "params": [
            "self",
            "path"
          ],
          "decorators": [],
          "source": "def _read_image(self, path):\n        if not path:\n            return False\n        path_info = path.split(',')\n        icon_path = opj(path_info[0], path_info[1])\n        try:\n            with tools.file_open(icon_path, 'rb', filter_ext=('.png',)) as icon_file:\n                return base64.encodebytes(icon_file.read())\n        except FileNotFoundError:\n            return False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_parent_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_parent_id(self):\n        if not self._check_recursion():\n            raise ValidationError(_('Error! You cannot create recursive menus.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_visible_menu_ids",
          "params": [
            "self",
            "debug=False"
          ],
          "decorators": [],
          "source": "def _visible_menu_ids(self, debug=False):\n        \"\"\" Return the ids of the menu items visible to the user. \"\"\"\n        # retrieve all menus, and determine which ones are visible\n        context = {'ir.ui.menu.full_list': True}\n        menus = self.with_context(context).search_fetch([], ['action', 'parent_id']).sudo()\n\n        groups = self.env.user.groups_id\n        if not debug:\n            groups = groups - self.env.ref('base.group_no_one')\n        # first discard all menus with groups the user does not have\n        menus = menus.filtered(\n            lambda menu: not menu.groups_id or menu.groups_id & groups)\n\n        # take apart menus that have an action\n        actions_by_model = defaultdict(set)\n        for action in menus.mapped('action'):\n            if action:\n                actions_by_model[action._name].add(action.id)\n        existing_actions = {\n            action\n            for model_name, action_ids in actions_by_model.items()\n            for action in self.env[model_name].browse(action_ids).exists()\n        }\n        action_menus = menus.filtered(lambda m: m.action and m.action in existing_actions)\n        folder_menus = menus - action_menus\n        visible = self.browse()\n\n        # process action menus, check whether their action is allowed\n        access = self.env['ir.model.access']\n        MODEL_BY_TYPE = {\n            'ir.actions.act_window': 'res_model',\n            'ir.actions.report': 'model',\n            'ir.actions.server': 'model_name',\n        }\n\n        # performance trick: determine the ids to prefetch by type\n        prefetch_ids = defaultdict(list)\n        for action in action_menus.mapped('action'):\n            prefetch_ids[action._name].append(action.id)\n\n        for menu in action_menus:\n            action = menu.action\n            action = action.with_prefetch(prefetch_ids[action._name])\n            model_name = action._name in MODEL_BY_TYPE and action[MODEL_BY_TYPE[action._name]]\n            if not model_name or access.check(model_name, 'read', False):\n                # make menu visible, and its folder ancestors, too\n                visible += menu\n                menu = menu.parent_id\n                while menu and menu in folder_menus and menu not in visible:\n                    visible += menu\n                    menu = menu.parent_id\n\n        return set(visible.ids)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_filter_visible_menus",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _filter_visible_menus(self):\n        \"\"\" Filter `self` to only keep the menu items that should be visible in\n            the menu hierarchy of the current user.\n            Uses a cache for speeding up the computation.\n        \"\"\"\n        visible_ids = self._visible_menu_ids(request.session.debug if request else False)\n        return self.filtered(lambda menu: menu.id in visible_ids)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "search_fetch",
          "params": [
            "self",
            "domain",
            "field_names",
            "offset=0",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def search_fetch(self, domain, field_names, offset=0, limit=None, order=None):\n        menus = super().search_fetch(domain, field_names, order=order)\n        if menus:\n            # menu filtering is done only on main menu tree, not other menu lists\n            if not self._context.get('ir.ui.menu.full_list'):\n                menus = menus._filter_visible_menus()\n            if offset:\n                menus = menus[offset:]\n            if limit:\n                menus = menus[:limit]\n        return menus",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "search_count",
          "params": [
            "self",
            "domain",
            "limit=None"
          ],
          "decorators": [],
          "source": "def search_count(self, domain, limit=None):\n        # to be consistent with search() above\n        return len(self.search(domain, limit=limit))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        for menu in self:\n            menu.display_name = menu._get_full_name()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.env.registry.clear_cache()\n        for values in vals_list:\n            if 'web_icon' in values:\n                values['web_icon_data'] = self._compute_web_icon_data(values.get('web_icon'))\n        return super(IrUiMenu, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        self.env.registry.clear_cache()\n        if 'web_icon' in values:\n            values['web_icon_data'] = self._compute_web_icon_data(values.get('web_icon'))\n        return super(IrUiMenu, self).write(values)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_web_icon_data",
          "params": [
            "self",
            "web_icon"
          ],
          "decorators": [],
          "source": "def _compute_web_icon_data(self, web_icon):\n        \"\"\" Returns the image associated to `web_icon`.\n            `web_icon` can either be:\n              - an image icon [module, path]\n              - a built icon [icon_class, icon_color, background_color]\n            and it only has to call `_read_image` if it's an image.\n        \"\"\"\n        if web_icon and len(web_icon.split(',')) == 2:\n            return self._read_image(web_icon)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        # Detach children and promote them to top-level, because it would be unwise to\n        # cascade-delete submenus blindly. We also can't use ondelete=set null because\n        # that is not supported when _parent_store is used (would silently corrupt it).\n        # TODO: ideally we should move them under a generic \"Orphans\" menu somewhere?\n        extra = {'ir.ui.menu.full_list': True,\n                 'active_test': False}\n        direct_children = self.with_context(**extra).search([('parent_id', 'in', self.ids)])\n        direct_children.write({'parent_id': False})\n\n        self.env.registry.clear_cache()\n        return super(IrUiMenu, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        record = super(IrUiMenu, self).copy(default=default)\n        match = NUMBER_PARENS.search(record.name)\n        if match:\n            next_num = int(match.group(1)) + 1\n            record.name = NUMBER_PARENS.sub('(%d)' % next_num, record.name)\n        else:\n            record.name = record.name + '(1)'\n        return record",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_user_roots",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_user_roots(self):\n        \"\"\" Return all root menu ids visible for the user.\n\n        :return: the root menu ids\n        :rtype: list(int)\n        \"\"\"\n        return self.search([('parent_id', '=', False)])",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load_menus_blacklist",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _load_menus_blacklist(self):\n        return []",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "load_menus_root",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def load_menus_root(self):\n        fields = ['name', 'sequence', 'parent_id', 'action', 'web_icon_data']\n        menu_roots = self.get_user_roots()\n        menu_roots_data = menu_roots.read(fields) if menu_roots else []\n\n        menu_root = {\n            'id': False,\n            'name': 'root',\n            'parent_id': [-1, ''],\n            'children': menu_roots_data,\n            'all_menu_ids': menu_roots.ids,\n        }\n\n        xmlids = menu_roots._get_menuitems_xmlids()\n        for menu in menu_roots_data:\n            menu['xmlid'] = xmlids.get(menu['id'], '')\n\n        return menu_root",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "load_menus",
          "params": [
            "self",
            "debug"
          ],
          "decorators": [],
          "source": "def load_menus(self, debug):\n        \"\"\" Loads all menu items (all applications and their sub-menus).\n\n        :return: the menu root\n        :rtype: dict('children': menu_nodes)\n        \"\"\"\n        fields = ['name', 'sequence', 'parent_id', 'action', 'web_icon']\n        menu_roots = self.get_user_roots()\n        menu_roots_data = menu_roots.read(fields) if menu_roots else []\n        menu_root = {\n            'id': False,\n            'name': 'root',\n            'parent_id': [-1, ''],\n            'children': [menu['id'] for menu in menu_roots_data],\n        }\n\n        all_menus = {'root': menu_root}\n\n        if not menu_roots_data:\n            return all_menus\n\n        # menus are loaded fully unlike a regular tree view, cause there are a\n        # limited number of items (752 when all 6.1 addons are installed)\n        menus_domain = [('id', 'child_of', menu_roots.ids)]\n        blacklisted_menu_ids = self._load_menus_blacklist()\n        if blacklisted_menu_ids:\n            menus_domain = expression.AND([menus_domain, [('id', 'not in', blacklisted_menu_ids)]])\n        menus = self.search(menus_domain)\n        menu_items = menus.read(fields)\n        xmlids = (menu_roots + menus)._get_menuitems_xmlids()\n\n        # add roots at the end of the sequence, so that they will overwrite\n        # equivalent menu items from full menu read when put into id:item\n        # mapping, resulting in children being correctly set on the roots.\n        menu_items.extend(menu_roots_data)\n\n        mi_attachments = self.env['ir.attachment'].sudo().search_read(\n            domain=[('res_model', '=', 'ir.ui.menu'),\n                    ('res_id', 'in', [menu_item['id'] for menu_item in menu_items if menu_item['id']]),\n                    ('res_field', '=', 'web_icon_data')],\n            fields=['res_id', 'datas', 'mimetype'])\n\n        mi_attachment_by_res_id = {attachment['res_id']: attachment for attachment in mi_attachments}\n\n        # set children ids and xmlids\n        menu_items_map = {menu_item[\"id\"]: menu_item for menu_item in menu_items}\n        for menu_item in menu_items:\n            menu_item.setdefault('children', [])\n            parent = menu_item['parent_id'] and menu_item['parent_id'][0]\n            menu_item['xmlid'] = xmlids.get(menu_item['id'], \"\")\n            if parent in menu_items_map:\n                menu_items_map[parent].setdefault(\n                    'children', []).append(menu_item['id'])\n            attachment = mi_attachment_by_res_id.get(menu_item['id'])\n            if attachment:\n                menu_item['web_icon_data'] = attachment['datas']\n                menu_item['web_icon_data_mimetype'] = attachment['mimetype']\n            else:\n                menu_item['web_icon_data'] = False\n                menu_item['web_icon_data_mimetype'] = False\n        all_menus.update(menu_items_map)\n\n        # sort by sequence\n        for menu_id in all_menus:\n            all_menus[menu_id]['children'].sort(key=lambda id: all_menus[id]['sequence'])\n\n        # recursively set app ids to related children",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_app_id",
          "params": [
            "app_id",
            "menu"
          ],
          "decorators": [],
          "source": "def _set_app_id(app_id, menu):\n            menu['app_id'] = app_id\n            for child_id in menu['children']:\n                _set_app_id(app_id, all_menus[child_id])\n\n        for app in menu_roots_data:\n            app_id = app['id']\n            _set_app_id(app_id, all_menus[app_id])\n\n        # filter out menus not related to an app (+ keep root menu)\n        all_menus = {menu['id']: menu for menu in all_menus.values() if menu.get('app_id')}\n        all_menus['root'] = menu_root\n\n        return all_menus",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_menuitems_xmlids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_menuitems_xmlids(self):\n        menuitems = self.env['ir.model.data'].sudo().search([\n                ('res_id', 'in', self.ids),\n                ('model', '=', 'ir.ui.menu')\n            ])\n\n        return {\n            menu.res_id: menu.complete_name\n            for menu in menuitems\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_parent_id",
          "definition": "@api.constrains('parent_id')\n    def _check_parent_id(self):\n        if not self._check_recursion():\n            raise ValidationError(_('Error! You cannot create recursive menus.'))",
          "message": "'parent_id'"
        }
      ],
      "accessRules": [
        {
          "name": "search_fetch (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "search_count (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "IrUiMenu"
    },
    {
      "name": "ir.ui.view.custom",
      "description": "Custom View",
      "fields": [
        {
          "name": "ref_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "required": true,
          "string": "Original View"
        },
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "required": true,
          "string": "User"
        },
        {
          "name": "arch",
          "type": "Text",
          "required": true,
          "string": "View Architecture"
        }
      ],
      "methods": [
        {
          "name": "_auto_init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _auto_init(self):\n        res = super(ViewCustom, self)._auto_init()\n        tools.create_index(self._cr, 'ir_ui_view_custom_user_id_ref_id',\n                           self._table, ['user_id', 'ref_id'])\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_hasclass",
          "params": [
            "context",
            "*cls"
          ],
          "decorators": [],
          "source": "def _hasclass(context, *cls):\n    \"\"\" Checks if the context node has all the classes passed as arguments\n    \"\"\"\n    node_classes = set(context.context_node.attrib.get('class', '').split())\n    return node_classes.issuperset(cls)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_view_arch_from_file",
          "params": [
            "filepath",
            "xmlid"
          ],
          "decorators": [],
          "source": "def get_view_arch_from_file(filepath, xmlid):\n    module, view_id = xmlid.split('.')\n\n    xpath = f\"//*[@id='{xmlid}' or @id='{view_id}']\"\n    # when view is created from model with inheritS of ir_ui_view, the\n    # xmlid has been suffixed by '_ir_ui_view'. We need to also search\n    # for views without this prefix.\n    if view_id.endswith('_ir_ui_view'):\n        # len('_ir_ui_view') == 11\n        xpath = xpath[:-1] + f\" or @id='{xmlid[:-11]}' or @id='{view_id[:-11]}']\"\n\n    document = etree.parse(filepath)\n    for node in document.xpath(xpath):\n        if node.tag == 'record':\n            field_arch = node.find('field[@name=\"arch\"]')\n            if field_arch is not None:\n                _fix_multiple_roots(field_arch)\n                inner = ''.join(\n                    etree.tostring(child, encoding='unicode')\n                    for child in field_arch.iterchildren()\n                )\n                return field_arch.text + inner\n\n            field_view = node.find('field[@name=\"view_id\"]')\n            if field_view is not None:\n                ref_module, _, ref_view_id = field_view.attrib.get('ref').rpartition('.')\n                ref_xmlid = f'{ref_module or module}.{ref_view_id}'\n                return get_view_arch_from_file(filepath, ref_xmlid)\n\n            return None\n\n        elif node.tag == 'template':\n            # The following dom operations has been copied from convert.py's _tag_template()\n            if not node.get('inherit_id'):\n                node.set('t-name', xmlid)\n                node.tag = 't'\n            else:\n                node.tag = 'data'\n            node.attrib.pop('id', None)\n            return etree.tostring(node, encoding='unicode')\n\n    _logger.warning(\"Could not find view arch definition in file '%s' for xmlid '%s'\", filepath, xmlid)\n    return None\n\n\nxpath_utils = etree.FunctionNamespace(None)\nxpath_utils['hasclass'] = _hasclass\n\nTRANSLATED_ATTRS_RE = re.compile(r\"@(%s)\\b\" % \"|\".join(TRANSLATED_ATTRS))\nWRONGCLASS = re.compile(r\"(@class\\s*=|=\\s*@class|contains\\(@class)\")",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ViewCustom"
    },
    {
      "name": "ir.ui.view",
      "description": "View",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "View Name"
        },
        {
          "name": "model",
          "type": "Char"
        },
        {
          "name": "key",
          "type": "Char"
        },
        {
          "name": "priority",
          "type": "Integer",
          "required": true,
          "string": "Sequence"
        },
        {
          "name": "type",
          "type": "Selection"
        },
        {
          "name": "arch",
          "type": "Text",
          "string": "View Architecture",
          "help": "\""
        },
        {
          "name": "arch_base",
          "type": "Text",
          "string": "Base View Architecture",
          "help": "This field is the same as `arch` field without translations"
        },
        {
          "name": "arch_db",
          "type": "Text",
          "string": "Arch Blob",
          "help": "This field stores the view arch."
        },
        {
          "name": "arch_fs",
          "type": "Char",
          "string": "Arch Filename",
          "help": "\""
        },
        {
          "name": "arch_updated",
          "type": "Boolean",
          "string": "Modified Architecture"
        },
        {
          "name": "arch_prev",
          "type": "Text",
          "string": "Previous View Architecture",
          "help": "\""
        },
        {
          "name": "inherit_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "string": "Inherited View"
        },
        {
          "name": "inherit_children_ids",
          "type": "One2many",
          "relation": "ir.ui.view",
          "string": "Views which inherit from this one"
        },
        {
          "name": "model_data_id",
          "type": "Many2one",
          "relation": "ir.model.data",
          "string": "Model Data"
        },
        {
          "name": "xml_id",
          "type": "Char",
          "string": "External ID",
          "help": "ID of the view defined in xml file"
        },
        {
          "name": "groups_id",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Groups",
          "help": "If this field is empty, the view applies to all users. Otherwise, the view applies to the users of those groups only."
        },
        {
          "name": "mode",
          "type": "Selection"
        },
        {
          "name": "active",
          "type": "Boolean",
          "help": "\""
        },
        {
          "name": "model_id",
          "type": "Many2one",
          "relation": "ir.model",
          "string": "Model of the view"
        }
      ],
      "methods": [
        {
          "name": "_compute_arch",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_arch(self):",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "resolve_external_ids",
          "params": [
            "arch_fs",
            "view_xml_id"
          ],
          "decorators": [],
          "source": "def resolve_external_ids(arch_fs, view_xml_id):",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "replacer",
          "params": [
            "m"
          ],
          "decorators": [],
          "source": "def replacer(m):\n                xmlid = m.group('xmlid')\n                if '.' not in xmlid:\n                    xmlid = '%s.%s' % (view_xml_id.split('.')[0], xmlid)\n                return m.group('prefix') + str(self.env['ir.model.data']._xmlid_to_res_id(xmlid))\n            return re.sub(r'(?P<prefix>[^%])%\\((?P<xmlid>.*?)\\)[ds]', replacer, arch_fs)\n\n        lang = self.env.lang or 'en_US'\n        env_en = self.with_context(edit_translations=None, lang='en_US').env\n        env_lang = self.with_context(lang=lang).env\n        field_arch_db = self._fields['arch_db']\n        for view in self:\n            arch_fs = None\n            read_file = self._context.get('read_arch_from_file') or \\\n                ('xml' in config['dev_mode'] and not view.arch_updated)\n            if read_file and view.arch_fs and (view.xml_id or view.key):\n                xml_id = view.xml_id or view.key\n                # It is safe to split on / herebelow because arch_fs is explicitely stored with '/'\n                try:\n                    fullpath = file_path(view.arch_fs)\n                except FileNotFoundError:\n                    _logger.warning(\"View %s: Full path [%s] cannot be found.\", xml_id, view.arch_fs)\n                    arch_fs = False\n                    continue\n\n                arch_fs = get_view_arch_from_file(fullpath, xml_id)\n                # replace %(xml_id)s, %(xml_id)d, %%(xml_id)s, %%(xml_id)d by the res_id\n                if arch_fs:\n                    arch_fs = resolve_external_ids(arch_fs, xml_id).replace('%%', '%')\n                    translation_dictionary = field_arch_db.get_translation_dictionary(\n                        view.with_env(env_en).arch_db, {lang: view.with_env(env_lang).arch_db}\n                    )\n                    arch_fs = field_arch_db.translate(\n                        lambda term: translation_dictionary[term][lang],\n                        arch_fs\n                    )\n            view.arch = pycompat.to_text(arch_fs or view.arch_db)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_arch",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_arch(self):\n        for view in self:\n            data = dict(arch_db=view.arch)\n            if 'install_filename' in self._context:\n                # we store the relative path to the resource instead of the absolute path, if found\n                # (it will be missing e.g. when importing data-only modules using base_import_module)\n                path_info = get_resource_from_path(self._context['install_filename'])\n                if path_info:\n                    data['arch_fs'] = '/'.join(path_info[0:2])\n                    data['arch_updated'] = False\n            view.write(data)\n            # the xml_translate will clean the arch_db when write (e.g. ('<div>') -> ('<div></div>'))\n            # view.arch should be reassigned here\n            view.arch = view.arch_db\n        # the field 'arch' depends on the context and has been implicitly\n        # modified in all languages; the invalidation below ensures that the\n        # field does not keep an old value in another environment\n        self.invalidate_recordset(['arch'])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_arch_base",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_arch_base(self):\n        # 'arch_base' is the same as 'arch' without translation\n        for view, view_wo_lang in zip(self, self.with_context(lang=None)):\n            view.arch_base = view_wo_lang.arch",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_arch_base",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_arch_base(self):\n        for view, view_wo_lang in zip(self, self.with_context(lang=None)):\n            view_wo_lang.arch = view.arch_base",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "reset_arch",
          "params": [
            "self",
            "mode='soft'"
          ],
          "decorators": [],
          "source": "def reset_arch(self, mode='soft'):\n        \"\"\" Reset the view arch to its previous arch (soft) or its XML file arch\n        if exists (hard).\n        \"\"\"\n        for view in self:\n            arch = False\n            if mode == 'soft':\n                arch = view.arch_prev\n                write_dict = {'arch_db': arch}\n            elif mode == 'hard' and view.arch_fs:\n                arch = view.with_context(read_arch_from_file=True, lang=None).arch\n                write_dict = {'arch_db': arch, 'arch_prev': False, 'arch_updated': False}\n            if arch:\n                # Don't save current arch in previous since we reset, this arch is probably broken\n                view.with_context(no_save_prev=True, lang=None).write(write_dict)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_model_data_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_model_data_id(self):\n        # get the first ir_model_data record corresponding to self\n        for view in self:\n            view.model_data_id = False\n        domain = [('model', '=', 'ir.ui.view'), ('res_id', 'in', self.ids)]\n        for data in self.env['ir.model.data'].sudo().search_read(domain, ['res_id'], order='id desc'):\n            view = self.browse(data['res_id'])\n            view.model_data_id = data['id']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search_model_data_id",
          "params": [
            "self",
            "operator",
            "value"
          ],
          "decorators": [],
          "source": "def _search_model_data_id(self, operator, value):\n        name = 'name' if isinstance(value, str) else 'id'\n        domain = [('model', '=', 'ir.ui.view'), (name, operator, value)]\n        data = self.env['ir.model.data'].sudo().search(domain)\n        return [('id', 'in', data.mapped('res_id'))]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_model_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_model_id(self):\n        for record in self:\n            record.model_id = self.env['ir.model']._get(record.model)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_compute_model_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_compute_model_id(self):\n        for record in self:\n            record.model = record.model_id.model",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_xml_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_xml_id(self):\n        xml_ids = collections.defaultdict(list)\n        domain = [('model', '=', 'ir.ui.view'), ('res_id', 'in', self.ids)]\n        for data in self.env['ir.model.data'].sudo().search_read(domain, ['module', 'name', 'res_id']):\n            xml_ids[data['res_id']].append(\"%s.%s\" % (data['module'], data['name']))\n        for view in self:\n            view.xml_id = xml_ids.get(view.id, [''])[0]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_valid_inheritance",
          "params": [
            "self",
            "arch"
          ],
          "decorators": [],
          "source": "def _valid_inheritance(self, arch):\n        \"\"\" Check whether view inheritance is based on translated attribute. \"\"\"\n        for node in arch.xpath('//*[@position]'):\n            # inheritance may not use a translated attribute as selector\n            if node.tag == 'xpath':\n                match = TRANSLATED_ATTRS_RE.search(node.get('expr', ''))\n                if match:\n                    message = \"View inheritance may not use attribute %r as a selector.\" % match.group(1)\n                    self._raise_view_error(message, node)\n                if WRONGCLASS.search(node.get('expr', '')):\n                    _logger.warning(\n                        \"Error-prone use of @class in view %s (%s): use the \"\n                        \"hasclass(*classes) function to filter elements by \"\n                        \"their classes\", self.name, self.xml_id\n                    )\n            else:\n                for attr in TRANSLATED_ATTRS:\n                    if node.get(attr):\n                        message = \"View inheritance may not use attribute %r as a selector.\" % attr\n                        self._raise_view_error(message, node)\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_xml",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_xml(self):\n        # Sanity checks: the view should not break anything upon rendering!\n        # Any exception raised below will cause a transaction rollback.\n        partial_validation = self.env.context.get('ir_ui_view_partial_validation')\n        self = self.with_context(validate_view_ids=(self._ids if partial_validation else True))\n\n        for view in self:\n            try:\n                # verify the view is valid xml and that the inheritance resolves\n                if view.inherit_id:\n                    view_arch = etree.fromstring(view.arch)\n                    view._valid_inheritance(view_arch)\n                combined_arch = view._get_combined_arch()\n                if view.type == 'qweb':\n                    continue\n            except (etree.ParseError, ValueError) as e:\n                err = ValidationError(_(\n                    \"Error while parsing or validating view:\\n\\n%(error)s\",\n                    error=tools.ustr(e),\n                    view=view.key or view.id,\n                )).with_traceback(e.__traceback__)\n                err.context = getattr(e, 'context', None)\n                raise err from None\n\n            try:\n                # verify that all fields used are valid, etc.\n                view._validate_view(combined_arch, view.model)\n                combined_archs = [combined_arch]\n\n                if combined_arch.xpath('//*[@attrs]') or combined_arch.xpath('//*[@states]'):\n                    view_name = f'{view.name} ({view.xml_id})' if view.xml_id else view.name\n                    err = ValidationError(_('Since 17.0, the \"attrs\" and \"states\" attributes are no longer used.\\nView: %(name)s in %(file)s',\n                        name=view_name, file=view.arch_fs\n                    ))\n                    err.context = {'name': 'invalid view'}\n                    raise err\n\n                if combined_archs[0].tag == 'data':\n                    # A <data> element is a wrapper for multiple root nodes\n                    combined_archs = combined_archs[0]\n                for view_arch in combined_archs:\n                    for node in view_arch.xpath('//*[@__validate__]'):\n                        del node.attrib['__validate__']\n                    check = valid_view(view_arch, env=self.env, model=view.model)\n                    if not check:\n                        view_name = f'{view.name} ({view.xml_id})' if view.xml_id else view.name\n                        raise ValidationError(_(\n                            'Invalid view %(name)s definition in %(file)s',\n                            name=view_name, file=view.arch_fs\n                        ))\n            except ValueError as e:\n                if hasattr(e, 'context'):\n                    lines = etree.tostring(combined_arch, encoding='unicode').splitlines(keepends=True)\n                    fivelines = \"\".join(lines[max(0, e.context[\"line\"]-3):e.context[\"line\"]+2])\n                    err = ValidationError(_(\n                        \"Error while validating view near:\\n\\n%(fivelines)s\\n%(error)s\",\n                        fivelines=fivelines, error=tools.ustr(e),\n                    ))\n                    err.context = e.context\n                    raise err.with_traceback(e.__traceback__) from None\n                else:\n                    err = ValidationError(_(\n                        \"Error while validating view (%(view)s):\\n\\n%(error)s\", view=self.key or self.id, error=tools.ustr(e.__context__),\n                    ))\n                    err.context = {'name': 'invalid view'}\n                    raise err.with_traceback(e.__context__.__traceback__) from None\n\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_groups",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_groups(self):\n        for view in self:\n            if (view.groups_id and\n                view.inherit_id and\n                view.mode != 'primary'):\n                raise ValidationError(_(\"Inherited view cannot have 'Groups' define on the record. Use 'groups' attributes inside the view definition\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_000_inheritance",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_000_inheritance(self):\n        # NOTE: constraints methods are check alphabetically. Always ensure this method will be\n        #       called before other constraint methods to avoid infinite loop in `_get_combined_arch`.\n        if not self._check_recursion(parent='inherit_id'):\n            raise ValidationError(_('You cannot create recursive inherited views.'))\n\n    _sql_constraints = [\n        ('inheritance_mode',\n         \"CHECK (mode != 'extension' OR inherit_id IS NOT NULL)\",\n         \"Invalid inheritance mode: if the mode is 'extension', the view must\"\n         \" extend an other view\"),\n        ('qweb_required_key',\n         \"CHECK (type != 'qweb' OR key IS NOT NULL)\",\n         \"Invalid key: QWeb view should have a key\"),\n    ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_auto_init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _auto_init(self):\n        res = super(View, self)._auto_init()\n        tools.create_index(self._cr, 'ir_ui_view_model_type_inherit_id',\n                           self._table, ['model', 'inherit_id'])\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_defaults",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _compute_defaults(self, values):\n        if 'inherit_id' in values:\n            # Do not automatically change the mode if the view already has an inherit_id,\n            # and the user change it to another.\n            if not values['inherit_id'] or all(not view.inherit_id for view in self):\n                values.setdefault('mode', 'extension' if values['inherit_id'] else 'primary')\n        return values",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        for values in vals_list:\n            if 'arch_db' in values and not values['arch_db']:\n                # delete empty arch_db to avoid triggering _check_xml before _inverse_arch_base is called\n                del values['arch_db']\n\n            if not values.get('type'):\n                if values.get('inherit_id'):\n                    values['type'] = self.browse(values['inherit_id']).type\n                else:\n\n                    try:\n                        if not values.get('arch') and not values.get('arch_base'):\n                            raise ValidationError(_('Missing view architecture.'))\n                        values['type'] = etree.fromstring(values.get('arch') or values.get('arch_base')).tag\n                    except LxmlError:\n                        # don't raise here, the constraint that runs `self._check_xml` will\n                        # do the job properly.\n                        pass\n            if not values.get('key') and values.get('type') == 'qweb':\n                values['key'] = \"gen_key.%s\" % str(uuid.uuid4())[:6]\n            if not values.get('name'):\n                values['name'] = \"%s %s\" % (values.get('model'), values['type'])\n            # Create might be called with either `arch` (xml files), `arch_base` (form view) or `arch_db`.\n            values['arch_prev'] = values.get('arch_base') or values.get('arch_db') or values.get('arch')\n            # write on arch: bypass _inverse_arch()\n            if 'arch' in values:\n                values['arch_db'] = values.pop('arch')\n                if 'install_filename' in self._context:\n                    # we store the relative path to the resource instead of the absolute path, if found\n                    # (it will be missing e.g. when importing data-only modules using base_import_module)\n                    path_info = get_resource_from_path(self._context['install_filename'])\n                    if path_info:\n                        values['arch_fs'] = '/'.join(path_info[0:2])\n                        values['arch_updated'] = False\n            values.update(self._compute_defaults(values))\n\n        self.env.registry.clear_cache('templates')\n        result = super(View, self.with_context(ir_ui_view_partial_validation=True)).create(vals_list)\n        return result.with_env(self.env)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        # Keep track if view was modified. That will be useful for the --dev mode\n        # to prefer modified arch over file arch.\n        if 'arch_updated' not in vals and ('arch' in vals or 'arch_base' in vals) and 'install_filename' not in self._context:\n            vals['arch_updated'] = True\n\n        # drop the corresponding view customizations (used for dashboards for example), otherwise\n        # not all users would see the updated views\n        custom_view = self.env['ir.ui.view.custom'].sudo().search([('ref_id', 'in', self.ids)])\n        if custom_view:\n            custom_view.unlink()\n\n        self.env.registry.clear_cache('templates')\n        if 'arch_db' in vals and not self.env.context.get('no_save_prev'):\n            vals['arch_prev'] = self.arch_db\n\n        res = super(View, self).write(self._compute_defaults(vals))\n\n        # Check the xml of the view if it gets re-activated.\n        # Ideally, `active` shoud have been added to the `api.constrains` of `_check_xml`,\n        # but the ORM writes and validates regular field (such as `active`) before inverse fields (such as `arch`),\n        # and therefore when writing `active` and `arch` at the same time, `_check_xml` is called twice,\n        # and the first time it tries to validate the view without the modification to the arch,\n        # which is problematic if the user corrects the view at the same time he re-enables it.\n        if vals.get('active'):\n            # Call `_validate_fields` instead of `_check_xml` to have the regular constrains error dialog\n            # instead of the traceback dialog.\n            self._validate_fields(['arch_db'])\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        # if in uninstall mode and has children views, emulate an ondelete cascade\n        if self.env.context.get('_force_unlink', False) and self.inherit_children_ids:\n            self.inherit_children_ids.unlink()\n        self.env.registry.clear_cache('templates')\n        return super(View, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_field_translations",
          "params": [
            "self",
            "fname",
            "translations",
            "digest=None"
          ],
          "decorators": [],
          "source": "def _update_field_translations(self, fname, translations, digest=None):\n        return super(View, self.with_context(no_save_prev=True))._update_field_translations(fname, translations, digest)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        self.ensure_one()\n        if self.key and default and 'key' not in default:\n            new_key = self.key + '_%s' % str(uuid.uuid4())[:6]\n            default = dict(default or {}, key=new_key)\n        return super(View, self).copy(default)\n\n    # default view selection",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "default_view",
          "params": [
            "self",
            "model",
            "view_type"
          ],
          "decorators": [],
          "source": "def default_view(self, model, view_type):\n        \"\"\" Fetches the default view for the provided (model, view_type) pair:\n         primary view with the lowest priority.\n\n        :param str model:\n        :param int view_type:\n        :return: id of the default view of False if none found\n        :rtype: int\n        \"\"\"\n        domain = [('model', '=', model), ('type', '=', view_type), ('mode', '=', 'primary')]\n        return self.search(domain, limit=1).id\n\n    #------------------------------------------------------\n    # Inheritance mecanism\n    #------------------------------------------------------",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_inheriting_views_domain",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_inheriting_views_domain(self):\n        \"\"\" Return a domain to filter the sub-views to inherit from. \"\"\"\n        return [('active', '=', True)]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_filter_xmlid_query",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_filter_xmlid_query(self):\n        \"\"\"This method is meant to be overridden by other modules.\n        \"\"\"\n        return \"\"\"SELECT res_id FROM ir_model_data\n                  WHERE res_id IN %(res_ids)s AND model = 'ir.ui.view' AND module IN %(modules)s\n               \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_inheriting_views",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_inheriting_views(self):\n        \"\"\"\n        Determine the views that inherit from the current recordset, and return\n        them as a recordset, ordered by priority then by id.\n        \"\"\"\n        self.check_access_rights('read')\n        domain = self._get_inheriting_views_domain()\n        e = expression(domain, self.env['ir.ui.view'])\n        from_clause, where_clause, where_params = e.query.get_sql()\n        assert from_clause == '\"ir_ui_view\"', f\"Unexpected from clause: {from_clause}\"\n\n        self._flush_search(domain, fields=['inherit_id', 'priority', 'model', 'mode'])\n        query = f\"\"\"\n            WITH RECURSIVE ir_ui_view_inherits AS (\n                SELECT id, inherit_id, priority, mode, model\n                FROM ir_ui_view\n                WHERE id IN %s AND ({where_clause})\n            UNION\n                SELECT ir_ui_view.id, ir_ui_view.inherit_id, ir_ui_view.priority,\n                       ir_ui_view.mode, ir_ui_view.model\n                FROM ir_ui_view\n                INNER JOIN ir_ui_view_inherits parent ON parent.id = ir_ui_view.inherit_id\n                WHERE coalesce(ir_ui_view.model, '') = coalesce(parent.model, '')\n                      AND ir_ui_view.mode = 'extension'\n                      AND ({where_clause})\n            )\n            SELECT\n                v.id, v.inherit_id, v.mode\n            FROM ir_ui_view_inherits v\n            ORDER BY v.priority, v.id\n        \"\"\"\n        # ORDER BY v.priority, v.id:\n        # 1/ sort by priority: abritrary value set by developers on some\n        #    views to solve \"dependency hell\" problems and force a view\n        #    to be combined earlier or later. e.g. all views created via\n        #    studio have a priority=99 to be loaded last.\n        # 2/ sort by view id: the order the views were inserted in the\n        #    database. e.g. base views are placed before stock ones.\n\n        self.env.cr.execute(query, [tuple(self.ids)] + where_params + where_params)\n        rows = self.env.cr.fetchall()\n\n        views = self.browse(row[0] for row in rows)\n\n        # optimization: fill in cache of inherit_id and mode\n        self.env.cache.update(views, self._fields['inherit_id'], [row[1] for row in rows])\n        self.env.cache.update(views, self._fields['mode'], [row[2] for row in rows])\n\n        # During an upgrade, we can only use the views that have been\n        # fully upgraded already.\n        if self.pool._init and not self._context.get('load_all_views'):\n            views = views._filter_loaded_views()\n\n        return views",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_filter_loaded_views",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _filter_loaded_views(self):\n        \"\"\"\n        During the module upgrade phase it may happen that a view is\n        present in the database but the fields it relies on are not\n        fully loaded yet. This method only considers views that belong\n        to modules whose code is already loaded. Custom views defined\n        directly in the database are loaded only after the module\n        initialization phase is completely finished.\n        \"\"\"\n        # check that all found ids have a corresponding xml_id in a loaded module\n        check_view_ids = self.env.context['check_view_ids']\n        ids_to_check = [vid for vid in self.ids if vid not in check_view_ids]\n        if not ids_to_check:\n            return self\n        loaded_modules = tuple(self.pool._init_modules) + (self._context.get('install_module'),)\n        query = self._get_filter_xmlid_query()\n        self.env.cr.execute(query, {'res_ids': tuple(ids_to_check), 'modules': loaded_modules})\n        valid_view_ids = {r[0] for r in self.env.cr.fetchall()} | set(check_view_ids)\n        return self.browse(vid for vid in self.ids if vid in valid_view_ids)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_view_access",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_view_access(self):\n        \"\"\" Verify that a view is accessible by the current user based on the\n        groups attribute. Views with no groups are considered private.\n        \"\"\"\n        if self.inherit_id and self.mode != 'primary':\n            return self.inherit_id._check_view_access()\n        if self.groups_id & self.env.user.groups_id:\n            return True\n        if self.groups_id:\n            error = _(\n                \"View '%(name)s' accessible only to groups %(groups)s \",\n                name=self.key,\n                groups=\", \".join([g.name for g in self.groups_id]\n            ))\n        else:\n            error = _(\"View '%(name)s' is private\", name=self.key)\n        raise AccessError(error)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_raise_view_error",
          "params": [
            "self",
            "message",
            "node=None",
            "*",
            "from_exception=None",
            "from_traceback=None"
          ],
          "decorators": [],
          "source": "def _raise_view_error(self, message, node=None, *, from_exception=None, from_traceback=None):\n        \"\"\" Handle a view error by raising an exception.\n\n        :param str message: message to raise or log, augmented with contextual\n                            view information\n        :param node: the lxml element where the error is located (if any)\n        :param BaseException from_exception:\n            when raising an exception, chain it to the provided one (default:\n            disable chaining)\n        :param types.TracebackType from_traceback:\n            when raising an exception, start with this traceback (default: start\n            at exception creation)\n        \"\"\"\n        err = ValueError(message).with_traceback(from_traceback)\n        err.context = {\n            'view': self,\n            'name': getattr(self, 'name', None),\n            'xmlid': self.env.context.get('install_xmlid') or self.xml_id,\n            'view.model': self.model,\n            'view.parent': self.inherit_id,\n            'file': self.env.context.get('install_filename'),\n            'line': node.sourceline if node is not None else 1,\n        }\n        raise err from from_exception",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_log_view_warning",
          "params": [
            "self",
            "message",
            "node"
          ],
          "decorators": [],
          "source": "def _log_view_warning(self, message, node):\n        \"\"\" Handle a view issue by logging a warning.\n\n        :param str message: message to raise or log, augmented with contextual\n                            view information\n        :param node: the lxml element where the error is located (if any)\n        \"\"\"\n        error_context = {\n            'view': self,\n            'name': getattr(self, 'name', None),\n            'xmlid': self.env.context.get('install_xmlid') or self.xml_id,\n            'view.model': self.model,\n            'view.parent': self.inherit_id,\n            'file': self.env.context.get('install_filename'),\n            'line': node.sourceline if node is not None else 1,\n        }\n        _logger.warning(\n            \"%s\\nView error context:\\n%s\",\n            message, pprint.pformat(error_context)\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "locate_node",
          "params": [
            "self",
            "arch",
            "spec"
          ],
          "decorators": [],
          "source": "def locate_node(self, arch, spec):\n        \"\"\" Locate a node in a source (parent) architecture.\n\n        Given a complete source (parent) architecture (i.e. the field\n        `arch` in a view), and a 'spec' node (a node in an inheriting\n        view that specifies the location in the source view of what\n        should be changed), return (if it exists) the node in the\n        source view matching the specification.\n\n        :param arch: a parent architecture to modify\n        :param spec: a modifying node in an inheriting view\n        :return: a node in the source matching the spec\n        \"\"\"\n        return locate_node(arch, spec)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "inherit_branding",
          "params": [
            "self",
            "specs_tree"
          ],
          "decorators": [],
          "source": "def inherit_branding(self, specs_tree):\n        for node in specs_tree.iterchildren(tag=etree.Element):\n            xpath = node.getroottree().getpath(node)\n            if node.tag == 'data' or node.tag == 'xpath' or node.get('position'):\n                self.inherit_branding(node)\n            elif node.get('t-field'):\n                node.set('data-oe-xpath', xpath)\n                self.inherit_branding(node)\n            else:\n                node.set('data-oe-id', str(self.id))\n                node.set('data-oe-xpath', xpath)\n                node.set('data-oe-model', 'ir.ui.view')\n                node.set('data-oe-field', 'arch')\n        return specs_tree",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_add_validation_flag",
          "params": [
            "self",
            "combined_arch",
            "view=None",
            "arch=None"
          ],
          "decorators": [],
          "source": "def _add_validation_flag(self, combined_arch, view=None, arch=None):\n        \"\"\" Add a validation flag on elements in ``combined_arch`` or ``arch``.\n        This is part of the partial validation of views.\n\n        :param Element combined_arch: the architecture to be modified by ``arch``\n        :param view: an optional view inheriting ``self``\n        :param Element arch: an optional modifying architecture from inheriting\n            view ``view``\n        \"\"\"\n        # validate_view_ids is either falsy (no validation), True (full\n        # validation) or a collection of ids (partial validation)\n        validate_view_ids = self.env.context.get('validate_view_ids')\n        if not validate_view_ids:\n            return\n\n        if validate_view_ids is True or self.id in validate_view_ids:\n            # optimization, flag the root node\n            combined_arch.set('__validate__', '1')\n            return\n\n        if view is None or view.id not in validate_view_ids:\n            return\n\n        for node in arch.xpath('//*[@position]'):\n            if node.get('position') in ('after', 'before', 'inside'):\n                # validate the elements being inserted, except the ones that\n                # specify a move, as in:\n                #   <field name=\"foo\" position=\"after\">\n                #       <field name=\"bar\" position=\"move\"/>\n                #   </field>\n                for child in node.iterchildren(tag=etree.Element):\n                    if not child.get('position'):\n                        child.set('__validate__', '1')\n            if node.get('position') == 'replace':\n                # validate everything, since this impacts the whole arch\n                combined_arch.set('__validate__', '1')\n                break\n            if node.get('position') == 'attributes':\n                # validate the element being modified by adding\n                # attribute \"__validate__\" on it:\n                #   <field name=\"foo\" position=\"attributes\">\n                #       <attribute name=\"readonly\">1</attribute>\n                #       <attribute name=\"__validate__\">1</attribute>    <!-- add this -->\n                #   </field>\n                node.append(E.attribute('1', name='__validate__'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "apply_inheritance_specs",
          "params": [
            "self",
            "source",
            "specs_tree",
            "pre_locate=lambda s: True"
          ],
          "decorators": [],
          "source": "def apply_inheritance_specs(self, source, specs_tree, pre_locate=lambda s: True):\n        \"\"\" Apply an inheriting view (a descendant of the base view)\n\n        Apply to a source architecture all the spec nodes (i.e. nodes\n        describing where and what changes to apply to some parent\n        architecture) given by an inheriting view.\n\n        :param Element source: a parent architecture to modify\n        :param Element specs_tree: a modifying architecture in an inheriting view\n        :param (optional) pre_locate: function that is execute before locating a node.\n                                        This function receives an arch as argument.\n        :return: a modified source where the specs are applied\n        :rtype: Element\n        \"\"\"\n        # Queue of specification nodes (i.e. nodes describing where and\n        # changes to apply to some parent architecture).\n        try:\n            source = apply_inheritance_specs(\n                source, specs_tree,\n                inherit_branding=self._context.get('inherit_branding'),\n                pre_locate=pre_locate,\n            )\n        except ValueError as e:\n            self._raise_view_error(str(e), specs_tree)\n        return source",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_combine",
          "params": [
            "self",
            "hierarchy: dict"
          ],
          "decorators": [],
          "source": "def _combine(self, hierarchy: dict):\n        \"\"\"\n        Return self's arch combined with its inherited views archs.\n\n        :param hierarchy: mapping from parent views to their child views\n        :return: combined architecture\n        :rtype: Element\n        \"\"\"\n        self.ensure_one()\n        assert self.mode == 'primary'\n\n        # We achieve a pre-order depth-first hierarchy traversal where\n        # primary views (and their children) are traversed after all the\n        # extensions for the current primary view have been visited.\n        #\n        # https://en.wikipedia.org/wiki/Tree_traversal#Depth-first_search_of_binary_tree\n        #\n        # Example:                  hierarchy = {\n        #                               1: [2, 3],  # primary view\n        #             1*                2: [4, 5],\n        #            / \\                3: [],\n        #           2   3               4: [6],     # primary view\n        #          / \\                  5: [7, 8],\n        #         4*  5                 6: [],\n        #        /   / \\                7: [],\n        #       6   7   8               8: [],\n        #                           }\n        #\n        # Tree traversal order (`view` and `queue` at the `while` stmt):\n        #   1 [2, 3]\n        #   2 [5, 3, 4]\n        #   5 [7, 8, 3, 4]\n        #   7 [8, 3, 4]\n        #   8 [3, 4]\n        #   3 [4]\n        #   4 [6]\n        #   6 []\n        combined_arch = etree.fromstring(self.arch)\n        if self.env.context.get('inherit_branding'):\n            combined_arch.attrib.update({\n                'data-oe-model': 'ir.ui.view',\n                'data-oe-id': str(self.id),\n                'data-oe-field': 'arch',\n            })\n        self._add_validation_flag(combined_arch)\n\n        # The depth-first traversal is implemented with a double-ended queue.\n        # The queue is traversed from left to right, and after each view in the\n        # queue is processed, its children are pushed at the left of the queue,\n        # so that they are traversed in order.  The queue is therefore mostly\n        # used as a stack.  An exception is made for primary views, which are\n        # pushed at the other end of the queue, so that they are applied after\n        # all extensions have been applied.\n        queue = collections.deque(sorted(hierarchy[self], key=lambda v: v.mode))\n        while queue:\n            view = queue.popleft()\n            arch = etree.fromstring(view.arch)\n            if view.env.context.get('inherit_branding'):\n                view.inherit_branding(arch)\n            self._add_validation_flag(combined_arch, view, arch)\n            combined_arch = view.apply_inheritance_specs(combined_arch, arch)\n\n            for child_view in reversed(hierarchy[view]):\n                if child_view.mode == 'primary':\n                    queue.append(child_view)\n                else:\n                    queue.appendleft(child_view)\n\n        return combined_arch",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "read_combined",
          "params": [
            "self",
            "fields=None"
          ],
          "decorators": [],
          "source": "def read_combined(self, fields=None):\n        \"\"\"\n        Utility function to get a view combined with its inherited views.\n\n        * Gets the top of the view tree if a sub-view is requested\n        * Applies all inherited archs on the root view\n        * Returns the view with all requested fields\n          .. note:: ``arch`` is always added to the fields list even if not\n                    requested (similar to ``id``)\n        \"\"\"\n        warnings.warn(\"use get_combined_arch() instead\", DeprecationWarning, stacklevel=2)\n        if fields:\n            fields = list({'arch', 'model'}.union(fields))\n        [result] = self.read(fields)\n        result['arch'] = self.get_combined_arch()\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_combined_arch",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_combined_arch(self):\n        \"\"\" Return the arch of ``self`` (as a string) combined with its inherited views. \"\"\"\n        return etree.tostring(self._get_combined_arch(), encoding='unicode')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_combined_arch",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_combined_arch(self):\n        \"\"\" Return the arch of ``self`` (as an etree) combined with its inherited views. \"\"\"\n        root = self\n        view_ids = []\n        while True:\n            view_ids.append(root.id)\n            if not root.inherit_id:\n                break\n            root = root.inherit_id\n\n        views = self.browse(view_ids)\n\n        # Add inherited views to the list of loading forced views\n        # Otherwise, inherited views could not find elements created in\n        # their direct parents if that parent is defined in the same module\n        # introduce check_view_ids in context\n        if 'check_view_ids' not in views.env.context:\n            views = views.with_context(check_view_ids=[])\n        views.env.context['check_view_ids'].extend(view_ids)\n\n        # Map each node to its children nodes. Note that all children nodes are\n        # part of a single prefetch set, which is all views to combine.\n        tree_views = views._get_inheriting_views()\n        hierarchy = collections.defaultdict(list)\n        for view in tree_views:\n            hierarchy[view.inherit_id].append(view)\n\n        # optimization: make root part of the prefetch set, too\n        arch = root.with_prefetch(tree_views._prefetch_ids)._combine(hierarchy)\n        return arch",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_refs",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _get_view_refs(self, node):\n        \"\"\" Extract the `[view_type]_view_ref` keys and values from the node context attribute,\n        giving the views to use for a field node.\n\n        :param node: the field node as an etree\n        :return: a dictonary mapping the `[view_type]_view_ref` key to the xmlid of the view to use for that view type.\n        \"\"\"\n        if not node.get('context'):\n            return {}\n        return {\n            m.group('view_type'): m.group('view_id')\n            for m in ref_re.finditer(node.get('context'))\n        }\n\n    #------------------------------------------------------\n    # Postprocessing: translation, groups and modifiers\n    #------------------------------------------------------\n    # TODO: remove group processing from ir_qweb\n    #------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "postprocess_and_fields",
          "params": [
            "self",
            "node",
            "model=None",
            "**options"
          ],
          "decorators": [],
          "source": "def postprocess_and_fields(self, node, model=None, **options):\n        \"\"\" Return an architecture and a description of all the fields.\n\n        The field description combines the result of fields_get() and\n        postprocess().\n\n        :param self: the view to postprocess\n        :param node: the architecture as an etree\n        :param model: the view's reference model name\n        :return: a tuple (arch, fields) where arch is the given node as a\n            string and fields is the description of all the fields.\n\n        \"\"\"\n        self and self.ensure_one()      # self is at most one view\n\n        name_manager = self._postprocess_view(node, model or self.model, **options)\n\n        arch = etree.tostring(node, encoding=\"unicode\").replace('\\t', '')\n\n        models = {}\n        name_managers = [name_manager]\n        for name_manager in name_managers:\n            models.setdefault(name_manager.model._name, set()).update(name_manager.available_fields)\n            name_managers.extend(name_manager.children)\n        return arch, models",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_access_rights",
          "params": [
            "self",
            "tree"
          ],
          "decorators": [],
          "source": "def _postprocess_access_rights(self, tree):\n        \"\"\"\n        Apply group restrictions: elements with a 'groups' attribute should\n        be removed from the view to people who are not members.\n\n        Compute and set on node access rights based on view type. Specific\n        views can add additional specific rights like creating columns for\n        many2one-based grouping views.\n        \"\"\"\n\n        for node in tree.xpath('//*[@groups]'):\n            attrib_groups = node.attrib.pop('groups')\n            if attrib_groups and not self.user_has_groups(attrib_groups):\n                node.getparent().remove(node)\n            elif node.tag == 't' and (not node.attrib or node.get('postprocess_added')):\n                # Move content of <t groups=\"\"> blocks\n                # and remove the <t> node.\n                # This is to keep the structure\n                # <group>\n                #   <field name=\"foo\"/>\n                #   <field name=\"bar\"/>\n                # <group>\n                # so the web client adds the label as expected.\n                # This is also to avoid having <t> nodes in tree views\n                # e.g.\n                # <tree>\n                #   <field name=\"foo\"/>\n                #   <t groups=\"foo\">\n                #     <field name=\"bar\" groups=\"bar\"/>\n                #   </t>\n                # </tree>\n                for child in reversed(node):\n                    node.addnext(child)\n                node.getparent().remove(node)\n\n        base_model = tree.get('model_access_rights')\n        for node in tree.xpath('//*[@model_access_rights]'):\n            model = self.env[node.attrib.pop('model_access_rights')]\n            if node.tag == 'field':\n                can_create = model.check_access_rights('create', raise_exception=False)\n                can_write = model.check_access_rights('write', raise_exception=False)\n                node.set('can_create', str(bool(can_create)))\n                node.set('can_write', str(bool(can_write)))\n            else:\n                is_base_model = base_model == model._name\n                for action, operation in (('create', 'create'), ('delete', 'unlink'), ('edit', 'write')):\n                    if not node.get(action) and not model.check_access_rights(operation, raise_exception=False):\n                        node.set(action, 'False')\n                if node.tag == 'kanban':\n                    group_by_name = node.get('default_group_by')\n                    group_by_field = model._fields.get(group_by_name)\n                    if group_by_field and group_by_field.type == 'many2one':\n                        group_by_model = model.env[group_by_field.comodel_name]\n                        for action, operation in (('group_create', 'create'), ('group_delete', 'unlink'), ('group_edit', 'write')):\n                            if not node.get(action) and not group_by_model.check_access_rights(operation, raise_exception=False):\n                                node.set(action, 'False')\n\n        return tree",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_view",
          "params": [
            "self",
            "node",
            "model_name",
            "editable=True",
            "parent_name_manager=None",
            "**options"
          ],
          "decorators": [],
          "source": "def _postprocess_view(self, node, model_name, editable=True, parent_name_manager=None, **options):\n        \"\"\" Process the given architecture, modifying it in-place to add and\n        remove stuff.\n\n        :param self: the optional view to postprocess\n        :param node: the combined architecture as an etree\n        :param model_name: the view's reference model name\n        :param editable: whether the view is considered editable\n        :return: the processed architecture's NameManager\n        \"\"\"\n        root = node\n\n        if model_name not in self.env:\n            self._raise_view_error(_('Model not found: %(model)s', model=model_name), root)\n        model = self.env[model_name]\n\n        if self._onchange_able_view(root):\n            self._postprocess_on_change(root, model)\n\n        name_manager = NameManager(model, parent=parent_name_manager)\n\n        root_info = {\n            'view_type': root.tag,\n            'view_editable': editable and self._editable_node(root, name_manager),\n            'mobile': options.get('mobile'),\n        }\n\n        # use a stack to recursively traverse the tree\n        stack = [(root, editable)]\n        while stack:\n            node, editable = stack.pop()\n\n            # compute default\n            tag = node.tag\n            had_parent = node.getparent() is not None\n            node_info = dict(root_info, editable=editable and self._editable_node(node, name_manager))\n\n            # tag-specific postprocessing\n            postprocessor = getattr(self, f\"_postprocess_tag_{tag}\", None)\n            if postprocessor is not None:\n                postprocessor(node, name_manager, node_info)\n                if had_parent and node.getparent() is None:\n                    # the node has been removed, stop processing here\n                    continue\n\n            # if present, iterate on node_info['children'] instead of node\n            for child in reversed(node_info.get('children', node)):\n                stack.append((child, node_info['editable']))\n\n        name_manager.update_available_fields()\n        root.set('model_access_rights', model._name)\n\n        return name_manager",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_on_change",
          "params": [
            "self",
            "arch",
            "model"
          ],
          "decorators": [],
          "source": "def _postprocess_on_change(self, arch, model):\n        \"\"\" Add attribute on_change=\"1\" on fields that are dependencies of\n            computed fields on the same view.\n        \"\"\"\n        # map each field object to its corresponding nodes in arch\n        field_nodes = collections.defaultdict(list)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "collect",
          "params": [
            "node",
            "model"
          ],
          "decorators": [],
          "source": "def collect(node, model):\n            if node.tag == 'field':\n                field = model._fields.get(node.get('name'))\n                if field:\n                    field_nodes[field].append(node)\n                    if field.relational:\n                        model = self.env[field.comodel_name]\n            for child in node:\n                collect(child, model)\n\n        collect(arch, model)\n\n        for field, nodes in field_nodes.items():\n            # if field should trigger an onchange, add on_change=\"1\" on the\n            # nodes referring to field\n            model = self.env[field.model_name]\n            if model._has_onchange(field, field_nodes):\n                for node in nodes:\n                    if not node.get('on_change'):\n                        node.set('on_change', '1')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_x2many_missing_view_archs",
          "params": [
            "self",
            "field",
            "field_node",
            "node_info"
          ],
          "decorators": [],
          "source": "def _get_x2many_missing_view_archs(self, field, field_node, node_info):\n        \"\"\"\n        For x2many fields that require to have some multi-record arch (kanban or list) to display the records\n        be available, this function fetches all arch that are needed and return them.\n        The caller function is responsible to do what it needs with them.\n        \"\"\"\n        current_view_types = [el.tag for el in field_node.xpath(\"./*[descendant::field]\")]\n        missing_view_types = []\n        if not any(view_type in current_view_types for view_type in field_node.get('mode', 'kanban,tree').split(',')):\n            missing_view_types.append(\n                field_node.get('mode', 'kanban' if node_info.get('mobile') else 'tree').split(',')[0]\n            )\n\n        if not missing_view_types:\n            return []\n\n        comodel = self.env[field.comodel_name].sudo(False)\n        refs = self._get_view_refs(field_node)\n        # Do not propagate <view_type>_view_ref of parent call to `_get_view`\n        comodel = comodel.with_context(**{\n            f'{view_type}_view_ref': refs.get(f'{view_type}_view_ref')\n            for view_type in missing_view_types\n        })\n\n        return [comodel._get_view(view_type=view_type) for view_type in missing_view_types]\n\n    #------------------------------------------------------\n    # Specific node postprocessors\n    #------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_tag_calendar",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _postprocess_tag_calendar(self, node, name_manager, node_info):\n        for additional_field in ('date_start', 'date_delay', 'date_stop', 'color', 'all_day'):\n            if node.get(additional_field):\n                name_manager.has_field(node, node.get(additional_field).split('.', 1)[0])\n        for f in node:\n            if f.tag == 'filter':\n                name_manager.has_field(node, f.get('name'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_tag_field",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _postprocess_tag_field(self, node, name_manager, node_info):\n        if node.get('name'):\n            attrs = {'id': node.get('id'), 'select': node.get('select')}\n            field = name_manager.model._fields.get(node.get('name'))\n            if field:\n                if field.groups:\n                    if node.get('groups'):\n                        # if the node has a group (e.g. \"base.group_no_one\")\n                        # and the field in the Python model has a group as well (e.g. \"base.group_system\")\n                        # the user must have both group to see the field.\n                        # groups=\"base.group_no_one,base.group_system\" directly on the node\n                        # would be one of the two groups, not both (OR instead of AND).\n                        # To make mandatory to have both groups, wrap the field node in a <t> node with the group\n                        # set on the field in the Python model\n                        # e.g. <t groups=\"base.group_system\"><field name=\"foo\" groups=\"base.group_no_one\"/></t>\n                        # The <t> node will be removed later, in _postprocess_access_rights.\n                        node_t = E.t(groups=field.groups, postprocess_added='1')\n                        node.getparent().replace(node, node_t)\n                        node_t.append(node)\n                    else:\n                        node.set('groups', field.groups)\n                if (\n                    node_info.get('view_type') == 'form'\n                    and field.type in ('one2many', 'many2many')\n                    and not node.get('widget')\n                    and node.get('invisible') not in ('1', 'True')\n                    and not name_manager.parent\n                ):\n                    # Embed kanban/tree/form views for visible x2many fields in form views\n                    # if no widget or the widget requires it.\n                    # So the web client doesn't have to call `get_views` for x2many fields not embedding their view\n                    # in the main form view.\n                    for arch, _view in self._get_x2many_missing_view_archs(field, node, node_info):\n                        node.append(arch)\n\n                for child in node:\n                    if child.tag in ('form', 'tree', 'graph', 'kanban', 'calendar'):\n                        node_info['children'] = []\n                        self._postprocess_view(\n                            child, field.comodel_name, editable=node_info['editable'], parent_name_manager=name_manager,\n                        )\n                if node_info['editable'] and field.type in ('many2one', 'many2many'):\n                    node.set('model_access_rights', field.comodel_name)\n\n            name_manager.has_field(node, node.get('name'), attrs)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_tag_form",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _postprocess_tag_form(self, node, name_manager, node_info):\n        result = name_manager.model.view_header_get(False, node.tag)\n        if result:\n            node.set('string', result)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_tag_groupby",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _postprocess_tag_groupby(self, node, name_manager, node_info):\n        # groupby nodes should be considered as nested view because they may\n        # contain fields on the comodel\n        name = node.get('name')\n        field = name_manager.model._fields.get(name)\n        if not field or not field.comodel_name:\n            return\n        # post-process the node as a nested view, and associate it to the field\n        self._postprocess_view(node, field.comodel_name, editable=False, parent_name_manager=name_manager)\n        name_manager.has_field(node, name)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_tag_label",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _postprocess_tag_label(self, node, name_manager, node_info):\n        if node.get('for'):\n            field = name_manager.model._fields.get(node.get('for'))\n            if field and field.groups:\n                if node.get('groups'):\n                    # See the comment for this in `_postprocess_tag_field`\n                    node_t = E.t(groups=field.groups, postprocess_added=\"1\")\n                    node.getparent().replace(node, node_t)\n                    node_t.append(node)\n                else:\n                    node.set('groups', field.groups)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_tag_search",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _postprocess_tag_search(self, node, name_manager, node_info):\n        searchpanel = [child for child in node if child.tag == 'searchpanel']\n        if searchpanel:\n            self._postprocess_view(\n                searchpanel[0], name_manager.model._name, editable=False, parent_name_manager=name_manager\n            )\n            node_info['children'] = [child for child in node if child.tag != 'searchpanel']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_postprocess_tag_tree",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _postprocess_tag_tree(self, node, name_manager, node_info):\n        # reuse form view post-processing\n        self._postprocess_tag_form(node, name_manager, node_info)\n\n    #-------------------------------------------------------------------\n    # view editability\n    #-------------------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_editable_node",
          "params": [
            "self",
            "node",
            "name_manager"
          ],
          "decorators": [],
          "source": "def _editable_node(self, node, name_manager):\n        \"\"\" Return whether the given node must be considered editable. \"\"\"\n        func = getattr(self, f\"_editable_tag_{node.tag}\", None)\n        if func is not None:\n            return func(node, name_manager)\n        # by default views are non-editable\n        return node.tag not in (item[0] for item in self._fields['type'].selection)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_editable_tag_form",
          "params": [
            "self",
            "node",
            "name_manager"
          ],
          "decorators": [],
          "source": "def _editable_tag_form(self, node, name_manager):\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_editable_tag_tree",
          "params": [
            "self",
            "node",
            "name_manager"
          ],
          "decorators": [],
          "source": "def _editable_tag_tree(self, node, name_manager):\n        return node.get('editable') or node.get('multi_edit')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_editable_tag_field",
          "params": [
            "self",
            "node",
            "name_manager"
          ],
          "decorators": [],
          "source": "def _editable_tag_field(self, node, name_manager):\n        field = name_manager.model._fields.get(node.get('name'))\n        return field is None or field.is_editable() and node.get('readonly') not in ('1', 'True')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_able_view",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _onchange_able_view(self, node):\n        func = getattr(self, f\"_onchange_able_view_{node.tag}\", None)\n        if func is not None:\n            return func(node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_able_view_form",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _onchange_able_view_form(self, node):\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_able_view_tree",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _onchange_able_view_tree(self, node):\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_able_view_kanban",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _onchange_able_view_kanban(self, node):\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_modifiers_from_model",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _modifiers_from_model(self, node):\n        modifier_names = []\n        if node.tag in ('kanban', 'tree', 'form'):\n            modifier_names += ['readonly', 'required']\n        return modifier_names\n\n    #-------------------------------------------------------------------\n    # view validation\n    #-------------------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_view",
          "params": [
            "self",
            "node",
            "model_name",
            "view_type=None",
            "editable=True",
            "full=False"
          ],
          "decorators": [],
          "source": "def _validate_view(self, node, model_name, view_type=None, editable=True, full=False):\n        \"\"\" Validate the given architecture node, and return its corresponding\n        NameManager.\n\n        :param self: the view being validated\n        :param node: the combined architecture as an etree\n        :param model_name: the reference model name for the given architecture\n        :param editable: whether the view is considered editable\n        :param full: whether the whole view must be validated\n        :return: the combined architecture's NameManager\n        \"\"\"\n        self.ensure_one()\n\n        view_type = view_type or self.type\n        if node.tag != view_type:\n            self._raise_view_error(_(\n                'The root node of a %(view_type)s view should be a <%(view_type)s>, not a <%(tag)s>',\n                view_type=view_type, tag=node.tag,\n            ), node)\n\n        if model_name not in self.env:\n            self._raise_view_error(_('Model not found: %(model)s', model=model_name), node)\n\n        # fields_get() optimization: validation does not require translations\n        model = self.env[model_name].with_context(lang=None)\n        name_manager = NameManager(model)\n\n        view_type = node.tag\n        # use a stack to recursively traverse the tree\n        stack = [(node, editable, full)]\n        while stack:\n            node, editable, validate = stack.pop()\n\n            # compute default\n            tag = node.tag\n            validate = validate or node.get('__validate__')\n            node_info = {\n                'editable': editable and self._editable_node(node, name_manager),\n                'validate': validate,\n                'view_type': view_type,\n            }\n\n            # tag-specific validation\n            validator = getattr(self, f\"_validate_tag_{tag}\", None)\n            if validator is not None:\n                validator(node, name_manager, node_info)\n\n            if validate:\n                self._validate_attributes(node, name_manager, node_info)\n\n            for child in reversed(node):\n                stack.append((child, node_info['editable'], validate))\n\n        name_manager.check(self)\n\n        return name_manager\n\n    #------------------------------------------------------\n    # Node validator\n    #------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_form",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_form(self, node, name_manager, node_info):\n        pass",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_tree",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_tree(self, node, name_manager, node_info):\n        # reuse form view validation\n        self._validate_tag_form(node, name_manager, node_info)\n        if not node_info['validate']:\n            return\n        allowed_tags = ('field', 'button', 'control', 'groupby', 'widget', 'header')\n        for child in node.iterchildren(tag=etree.Element):\n            if child.tag not in allowed_tags and not isinstance(child, etree._Comment):\n                msg = _(\n                    'Tree child can only have one of %(tags)s tag (not %(wrong_tag)s)',\n                    tags=', '.join(allowed_tags), wrong_tag=child.tag,\n                )\n                self._raise_view_error(msg, child)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_graph",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_graph(self, node, name_manager, node_info):\n        if not node_info['validate']:\n            return\n        for child in node.iterchildren(tag=etree.Element):\n            if child.tag != 'field' and not isinstance(child, etree._Comment):\n                msg = _('A <graph> can only contains <field> nodes, found a <%s>', child.tag)\n                self._raise_view_error(msg, child)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_calendar",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_calendar(self, node, name_manager, node_info):\n        for additional_field in ('date_start', 'date_delay', 'date_stop', 'color', 'all_day'):\n            if node.get(additional_field):\n                name_manager.has_field(node, node.get(additional_field).split('.', 1)[0])\n        for f in node:\n            if f.tag == 'filter':\n                name_manager.has_field(node, f.get('name'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_search",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_search(self, node, name_manager, node_info):\n        if node_info['validate'] and not node.iterdescendants(tag=\"field\"):\n            # the field of the search view may be within a group node, which is why we must check\n            # for all descendants containing a node with a field tag, if this is not the case\n            # then a search is not possible.\n            self._log_view_warning('Search tag requires at least one field element', node)\n\n        searchpanels = [child for child in node if child.tag == 'searchpanel']\n        if searchpanels:\n            if len(searchpanels) > 1:\n                self._raise_view_error(_('Search tag can only contain one search panel'), node)\n            node.remove(searchpanels[0])\n            self._validate_view(searchpanels[0], name_manager.model._name, view_type=\"searchpanel\",\n                                editable=False, full=node_info['validate'])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_field",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_field(self, node, name_manager, node_info):\n        validate = node_info['validate']\n\n        name = node.get('name')\n        if not name:\n            self._raise_view_error(_(\"Field tag must have a \\\"name\\\" attribute defined\"), node)\n\n        field = name_manager.model._fields.get(name)\n        if field:\n            if validate and field.relational:\n                domain = (\n                    node.get('domain')\n                    or node_info['editable'] and field._description_domain(self.env)\n                )\n                if isinstance(domain, str):\n                    # dynamic domain: in [('foo', '=', bar)], field 'foo' must\n                    # exist on the comodel and field 'bar' must be in the view\n                    desc = (f'domain of <field name=\"{name}\">' if node.get('domain')\n                            else f\"domain of python field {name!r}\")\n                    try:\n                        self._validate_domain_identifiers(node, name_manager, domain, desc, field.comodel_name)\n                    except ValueError as e:\n                        if 'Modifier must be a domain' in str(e):\n                            warnings.warn(f\"Non-domain syntaxes are deprecated for attribute 'domain': {desc}\\n{domain!r}\", DeprecationWarning, 2)\n                        else:\n                            raise\n\n            elif validate and node.get('domain'):\n                msg = _(\n                    'Domain on non-relational field \"%(name)s\" makes no sense (domain:%(domain)s)',\n                    name=name, domain=node.get('domain'),\n                )\n                self._raise_view_error(msg, node)\n\n            for child in node:\n                if child.tag not in ('form', 'tree', 'graph', 'kanban', 'calendar'):\n                    continue\n                node.remove(child)\n                sub_manager = self._validate_view(\n                    child, field.comodel_name, view_type=child.tag, editable=node_info['editable'], full=validate,\n                )\n                for fname, groups_uses in sub_manager.mandatory_parent_fields.items():\n                    for groups, use in groups_uses.items():\n                        name_manager.must_have_field(node, fname, use, groups=groups)\n\n        elif validate and name not in name_manager.field_info:\n            msg = _(\n                'Field \"%(field_name)s\" does not exist in model \"%(model_name)s\"',\n                field_name=name, model_name=name_manager.model._name,\n            )\n            self._raise_view_error(msg, node)\n\n        name_manager.has_field(node, name, {'id': node.get('id'), 'select': node.get('select')})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_filter",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_filter(self, node, name_manager, node_info):\n        if not node_info['validate']:\n            return\n        domain = node.get('domain')\n        if domain:\n            name = node.get('name')\n            desc = f'domain of <filter name=\"{name}\">' if name else 'domain of <filter>'\n            self._validate_domain_identifiers(node, name_manager, domain, desc, name_manager.model._name)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_button",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_button(self, node, name_manager, node_info):\n        if not node_info['validate']:\n            return\n        name = node.get('name')\n        special = node.get('special')\n        type_ = node.get('type')\n        if special:\n            if special not in ('cancel', 'save', 'add'):\n                self._raise_view_error(_(\"Invalid special '%(value)s' in button\", value=special), node)\n        elif type_:\n            if type_ == 'edit': # list_renderer, used in kanban view\n                return\n            elif not name:\n                self._raise_view_error(_(\"Button must have a name\"), node)\n            elif type_ == 'object':\n                func = getattr(name_manager.model, name, None)\n                if not func:\n                    msg = _(\n                        \"%(action_name)s is not a valid action on %(model_name)s\",\n                        action_name=name, model_name=name_manager.model._name,\n                    )\n                    self._raise_view_error(msg, node)\n                try:\n                    check_method_name(name)\n                except AccessError:\n                    msg = _(\n                        \"%(method)s on %(model)s is private and cannot be called from a button\",\n                        method=name, model=name_manager.model._name,\n                    )\n                    self._raise_view_error(msg, node)\n                try:\n                    inspect.signature(func).bind()\n                except TypeError:\n                    msg = \"%s on %s has parameters and cannot be called from a button\"\n                    self._log_view_warning(msg % (name, name_manager.model._name), node)\n            elif type_ == 'action':\n                name_manager.must_exist_action(name, node)\n\n            name_manager.has_action(name)\n\n        if node.get('icon'):\n            description = 'A button with icon attribute (%s)' % node.get('icon')\n            self._validate_fa_class_accessibility(node, description)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_groupby",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_groupby(self, node, name_manager, node_info):\n        # groupby nodes should be considered as nested view because they may\n        # contain fields on the comodel\n        name = node.get('name')\n        if not name:\n            return\n        field = name_manager.model._fields.get(name)\n        if field:\n            if node_info['validate']:\n                if field.type != 'many2one':\n                    msg = _(\n                        \"Field '%(name)s' found in 'groupby' node can only be of type many2one, found %(type)s\",\n                        name=field.name, type=field.type,\n                    )\n                    self._raise_view_error(msg, node)\n                domain = node_info['editable'] and field._description_domain(self.env)\n                if isinstance(domain, str):\n                    desc = f\"domain of python field '{name}'\"\n                    self._validate_domain_identifiers(node, name_manager, domain, desc, field.comodel_name)\n\n            # move all children nodes into a new node <groupby>\n            groupby_node = E.groupby(*node)\n            # validate the node as a nested view\n            sub_manager = self._validate_view(\n                groupby_node, field.comodel_name, view_type=\"groupby\", editable=False, full=node_info['validate'],\n            )\n            name_manager.has_field(node, name)\n            for fname, groups_uses in sub_manager.mandatory_parent_fields.items():\n                for groups, use in groups_uses.items():\n                    name_manager.must_have_field(node, fname, use, groups=groups)\n\n        elif node_info['validate']:\n            msg = _(\n                \"Field '%(field)s' found in 'groupby' node does not exist in model %(model)s\",\n                field=name, model=name_manager.model._name,\n            )\n            self._raise_view_error(msg, node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_searchpanel",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_searchpanel(self, node, name_manager, node_info):\n        if not node_info['validate']:\n            return\n        for child in node.iterchildren(tag=etree.Element):\n            if child.get('domain') and child.get('select') != 'multi':\n                msg = _('Searchpanel item with select multi cannot have a domain.')\n                self._raise_view_error(msg, child)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_label",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_label(self, node, name_manager, node_info):\n        if not node_info['validate']:\n            return\n        # replace return not arch.xpath('//label[not(@for) and not(descendant::input)]')\n        for_ = node.get('for')\n        if not for_:\n            msg = _('Label tag must contain a \"for\". To match label style '\n                    'without corresponding field or button, use \\'class=\"o_form_label\"\\'.')\n            self._raise_view_error(msg, node)\n        else:\n            name_manager.must_have_name(for_, '<label for=\"...\">')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_page",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_page(self, node, name_manager, node_info):\n        if not node_info['validate']:\n            return\n        if node.getparent() is None or node.getparent().tag != 'notebook':\n            self._raise_view_error(_('Page direct ancestor must be notebook'), node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_img",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_img(self, node, name_manager, node_info):\n        if node_info['validate'] and not any(node.get(alt) for alt in att_names('alt')):\n            self._log_view_warning('<img> tag must contain an alt attribute', node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_a",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_a(self, node, name_manager, node_info):\n        #('calendar', 'form', 'graph', 'kanban', 'pivot', 'search', 'tree', 'activity')\n        if node_info['validate'] and any('btn' in node.get(cl, '') for cl in att_names('class')):\n            if node.get('role') != 'button':\n                msg = '\"<a>\" tag with \"btn\" class must have \"button\" role'\n                self._log_view_warning(msg, node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_ul",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_ul(self, node, name_manager, node_info):\n        if node_info['validate']:\n            # was applied to all nodes, but in practice only used on div and ul\n            self._check_dropdown_menu(node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_tag_div",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_tag_div(self, node, name_manager, node_info):\n        if node_info['validate']:\n            self._check_dropdown_menu(node)\n            self._check_progress_bar(node)\n\n    #------------------------------------------------------\n    # Validation tools\n    #------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_dropdown_menu",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _check_dropdown_menu(self, node):\n        #('calendar', 'form', 'graph', 'kanban', 'pivot', 'search', 'tree', 'activity')\n        if any('dropdown-menu' in node.get(cl, '') for cl in att_names('class')):\n            if node.get('role') != 'menu':\n                msg = 'dropdown-menu class must have menu role'\n                self._log_view_warning(msg, node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_progress_bar",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _check_progress_bar(self, node):\n        if any('o_progressbar' in node.get(cl, '') for cl in att_names('class')):\n            if node.get('role') != 'progressbar':\n                msg = 'o_progressbar class must have progressbar role'\n                self._log_view_warning(msg, node)\n            if not any(node.get(at) for at in att_names('aria-valuenow')):\n                msg = 'o_progressbar class must have aria-valuenow attribute'\n                self._log_view_warning(msg, node)\n            if not any(node.get(at) for at in att_names('aria-valuemin')):\n                msg = 'o_progressbar class must have aria-valuemin attribute'\n                self._log_view_warning(msg, node)\n            if not any(node.get(at) for at in att_names('aria-valuemax')):\n                msg = 'o_progressbar class must have aria-valuemaxattribute'\n                self._log_view_warning(msg, node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_qweb_based_view",
          "params": [
            "self",
            "view_type"
          ],
          "decorators": [],
          "source": "def _is_qweb_based_view(self, view_type):\n        return view_type in (\"kanban\", \"gantt\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_attributes",
          "params": [
            "self",
            "node",
            "name_manager",
            "node_info"
          ],
          "decorators": [],
          "source": "def _validate_attributes(self, node, name_manager, node_info):\n        \"\"\" Generic validation of node attributes. \"\"\"\n\n        # python expression used in for readonly, invisible, ...\n        # and thus are only executed client side\n        for attr in VIEW_MODIFIERS:\n            py_expression = node.attrib.get(attr)\n            if py_expression:\n                self._validate_expression(node, name_manager, py_expression, f\"modifier {attr!r}\")\n\n        for attr, expr in node.items():\n            if attr in ('class', 't-att-class', 't-attf-class'):\n                self._validate_classes(node, expr)\n\n            elif attr == 'context':\n                try:\n                    vnames = get_expression_field_names(expr) - {'id'}\n                except SyntaxError as e:\n                    message = _('Invalid context: %(expr)r is not a valid Python expression \\n\\n %(e)s', expr=expr, e=e)\n                    self._raise_view_error(message)\n                if vnames:\n                    name_manager.must_have_fields(node, vnames, f\"context ({expr})\")\n                for key, val_ast in get_dict_asts(expr).items():\n                    if key == 'group_by':  # only in context\n                        if not isinstance(val_ast, ast.Constant) or not isinstance(val_ast.value, str):\n                            msg = _(\n                                '\"group_by\" value must be a string %(attribute)s=%(value)r',\n                                attribute=attr, value=expr,\n                            )\n                            self._raise_view_error(msg, node)\n                        group_by = val_ast.value\n                        fname = group_by.split(':')[0]\n                        if fname not in name_manager.model._fields:\n                            msg = _(\n                                'Unknown field \"%(field)s\" in \"group_by\" value in %(attribute)s=%(value)r',\n                                field=fname, attribute=attr, value=expr,\n                            )\n                            self._raise_view_error(msg, node)\n\n            elif attr == 'groups':\n                for group in expr.replace('!', '').split(','):\n                    name_manager.must_exist_group(group.strip(), node)\n\n            elif attr in ('col', 'colspan'):\n                # col check is mainly there for the tag 'group', but previous\n                # check was generic in view form\n                if not expr.isdigit():\n                    self._raise_view_error(\n                        _('%(attribute)r value must be an integer (%(value)s)',\n                          attribute=attr, value=expr),\n                        node,\n                    )\n\n            elif attr.startswith('decoration-'):\n                vnames = get_expression_field_names(expr) - {'id'}\n                if vnames:\n                    name_manager.must_have_fields(node, vnames, f\"{attr}={expr!r}\")\n\n            elif attr == 'data-bs-toggle' and expr == 'tab':\n                if node.get('role') != 'tab':\n                    msg = 'tab link (data-bs-toggle=\"tab\") must have \"tab\" role'\n                    self._log_view_warning(msg, node)\n                aria_control = node.get('aria-controls') or node.get('t-att-aria-controls')\n                if not aria_control and not node.get('t-attf-aria-controls'):\n                    msg = 'tab link (data-bs-toggle=\"tab\") must have \"aria_control\" defined'\n                    self._log_view_warning(msg, node)\n                if aria_control and '#' in aria_control:\n                    msg = 'aria-controls in tablink cannot contains \"#\"'\n                    self._log_view_warning(msg, node)\n\n            elif attr == \"role\" and expr in ('presentation', 'none'):\n                msg = (\"A role cannot be `none` or `presentation`. \"\n                    \"All your elements must be accessible with screen readers, describe it.\")\n                self._log_view_warning(msg, node)\n\n            elif attr == 'group':\n                msg = \"attribute 'group' is not valid.  Did you mean 'groups'?\"\n                self._log_view_warning(msg, node)\n\n            elif (re.match(r'^(t\\-att\\-|t\\-attf\\-)?data-tooltip(-template|-info)?$', attr)):\n                self._raise_view_error(_(\"Forbidden attribute used in arch (%s).\", attr), node)\n\n            elif (attr.startswith(\"t-\")):\n                self._validate_qweb_directive(node, attr, node_info[\"view_type\"])\n                if (re.search(COMP_REGEX, expr)):\n                    self._raise_view_error(_(\"Forbidden use of `__comp__` in arch.\"), node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_classes",
          "params": [
            "self",
            "node",
            "expr"
          ],
          "decorators": [],
          "source": "def _validate_classes(self, node, expr):\n        \"\"\" Validate the classes present on node. \"\"\"\n        classes = set(expr.split(' '))\n        # Be careful: not always true if it is an expression\n        # example: <div t-attf-class=\"{{!selection_mode ? 'oe_kanban_color_' + kanban_getcolor(record.color.raw_value) : ''}} oe_kanban_card oe_kanban_global_click oe_applicant_kanban oe_semantic_html_override\">\n        if 'modal' in classes and node.get('role') != 'dialog':\n            msg = '\"modal\" class should only be used with \"dialog\" role'\n            self._log_view_warning(msg, node)\n\n        if 'modal-header' in classes and node.tag != 'header':\n            msg = '\"modal-header\" class should only be used in \"header\" tag'\n            self._log_view_warning(msg, node)\n\n        if 'modal-body' in classes and node.tag != 'main':\n            msg = '\"modal-body\" class should only be used in \"main\" tag'\n            self._log_view_warning(msg, node)\n\n        if 'modal-footer' in classes and node.tag != 'footer':\n            msg = '\"modal-footer\" class should only be used in \"footer\" tag'\n            self._log_view_warning(msg, node)\n\n        if 'tab-pane' in classes and node.get('role') != 'tabpanel':\n            msg = '\"tab-pane\" class should only be used with \"tabpanel\" role'\n            self._log_view_warning(msg, node)\n\n        if 'nav-tabs' in classes and node.get('role') != 'tablist':\n            msg = 'A tab list with class nav-tabs must have role=\"tablist\"'\n            self._log_view_warning(msg, node)\n\n        if any(klass.startswith('alert-') for klass in classes):\n            if (\n                node.get('role') not in ('alert', 'alertdialog', 'status')\n                and 'alert-link' not in classes\n            ):\n                msg = (\"An alert (class alert-*) must have an alert, alertdialog or \"\n                        \"status role or an alert-link class. Please use alert and \"\n                        \"alertdialog only for what expects to stop any activity to \"\n                        \"be read immediately.\")\n                self._log_view_warning(msg, node)\n\n        if any(klass.startswith('fa-') for klass in classes):\n            description = 'A <%s> with fa class (%s)' % (node.tag, expr)\n            self._validate_fa_class_accessibility(node, description)\n\n        if any(klass.startswith('btn') for klass in classes):\n            if node.tag in ('a', 'button', 'select'):\n                pass\n            elif node.tag == 'input' and node.get('type') in ('button', 'submit', 'reset'):\n                pass\n            elif any(klass in classes for klass in ('btn-group', 'btn-toolbar', 'btn-addr')):\n                pass\n            elif node.tag == 'field' and node.get('widget') == 'url':\n                pass\n            else:\n                msg = (\"A simili button must be in tag a/button/select or tag `input` \"\n                        \"with type button/submit/reset or have class in \"\n                        \"btn-group/btn-toolbar/btn-addr\")\n                self._log_view_warning(msg, node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_fa_class_accessibility",
          "params": [
            "self",
            "node",
            "description"
          ],
          "decorators": [],
          "source": "def _validate_fa_class_accessibility(self, node, description):\n        valid_aria_attrs = {\n            *att_names('title'), *att_names('aria-label'), *att_names('aria-labelledby'),\n        }\n        valid_t_attrs = {'t-value', 't-raw', 't-field', 't-esc', 't-out'}\n\n        ## Following or preceding text\n        if (node.tail or '').strip() or (node.getparent().text or '').strip():\n            # text<i class=\"fa-...\"/> or <i class=\"fa-...\"/>text or\n            return\n\n        ## Following or preceding text in span",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "has_text",
          "params": [
            "elem"
          ],
          "decorators": [],
          "source": "def has_text(elem):\n            if elem is None:\n                return False\n            if elem.tag == 'span' and elem.text:\n                return True\n            if elem.tag == 't' and (elem.get('t-esc') or elem.get('t-raw')):\n                return True\n            return False\n\n        if has_text(node.getnext()) or has_text(node.getprevious()):\n            return",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "has_title_or_aria_label",
          "params": [
            "node"
          ],
          "decorators": [],
          "source": "def has_title_or_aria_label(node):\n            return any(node.get(attr) for attr in valid_aria_attrs)\n\n        ## Aria label can be on ancestors\n        if any(map(has_title_or_aria_label, node.iterancestors())):\n            return\n\n        if node.get('string'):\n            return\n\n        ## And we ignore all elements with describing in children",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "contains_description",
          "params": [
            "node",
            "depth=0"
          ],
          "decorators": [],
          "source": "def contains_description(node, depth=0):\n            if depth > 2:\n                _logger.warning('excessive depth in fa')\n            if any(node.get(attr) for attr in valid_t_attrs):\n                return True\n            if has_title_or_aria_label(node):\n                return True\n            if node.tag in ('label', 'field'):\n                return True\n            if node.text:  # not sure, does it match *[text()]\n                return True\n            return any(contains_description(child, depth+1) for child in node)\n\n        if contains_description(node):\n            return\n\n        msg = '%s must have title in its tag, parents, descendants or have text'\n        self._log_view_warning(msg % description, node)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_qweb_directive",
          "params": [
            "self",
            "node",
            "directive",
            "view_type"
          ],
          "decorators": [],
          "source": "def _validate_qweb_directive(self, node, directive, view_type):\n        \"\"\"Some views (e.g. kanban, form) generate owl templates from the archs.\n        However, we don't want to see owl directives directly written in archs.\n        There are exceptions though, since the kanban and gantt archs define qweb templates.\n        We thus here validate that the given directive is allowed, according to the view_type.\n        \"\"\"\n        allowed_directives = [\"t-translation\"]\n        if self._is_qweb_based_view(view_type):\n            allowed_directives.extend([\n                \"t-name\",\n                \"t-esc\",\n                \"t-out\",\n                \"t-set\",\n                \"t-value\",\n                \"t-if\",\n                \"t-else\",\n                \"t-elif\",\n                \"t-foreach\",\n                \"t-as\",\n                \"t-key\",\n                \"t-att.*\",\n                \"t-call\",\n                \"t-debug\",\n            ])\n        if (not next(filter(lambda regex: re.match(regex, directive), allowed_directives), None)):\n            self._raise_view_error(_(\"Forbidden owl directive used in arch (%s).\", directive), node)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_expression",
          "params": [
            "self",
            "node",
            "name_manager",
            "py_expression",
            "use"
          ],
          "decorators": [],
          "source": "def _validate_expression(self, node, name_manager, py_expression, use):\n        try:\n            if py_expression.lower() in (\"0\", \"false\", \"1\", \"true\"):\n                # most (~95%) elements are 1/True/0/False\n                return\n            fnames = get_expression_field_names(py_expression) - {\"id\"}\n        except (SyntaxError, ValueError, AttributeError) as e:\n            msg = _(\"Invalid %(use)s: %(expr)r\\n%(error)s\", use=use, expr=py_expression, error=e)\n            self._raise_view_error(msg, node, from_exception=e)\n        name_manager.must_have_fields(node, fnames, f\"{use} ({py_expression})\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_domain_identifiers",
          "params": [
            "self",
            "node",
            "name_manager",
            "domain",
            "use",
            "target_model"
          ],
          "decorators": [],
          "source": "def _validate_domain_identifiers(self, node, name_manager, domain, use, target_model):\n        try:\n            fnames, vnames = get_domain_value_names(domain)\n        except (SyntaxError, ValueError, AttributeError) as e:\n            msg = _(\"Invalid %(use)s: %(expr)r\\n%(error)s\", use=use, expr=domain, error=e)\n            self._raise_view_error(msg, node, from_exception=e)\n\n        self._check_field_paths(node, fnames, target_model, f\"{use} ({domain})\")\n        name_manager.must_have_fields(node, vnames, f\"{use} ({domain})\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_field_paths",
          "params": [
            "self",
            "node",
            "field_paths",
            "model_name",
            "use"
          ],
          "decorators": [],
          "source": "def _check_field_paths(self, node, field_paths, model_name, use):\n        \"\"\" Check whether the given field paths (dot-separated field names)\n        correspond to actual sequences of fields on the given model.\n        \"\"\"\n        for field_path in field_paths:\n            names = field_path.split('.')\n            Model = self.pool[model_name]\n            if names[0] == 'parent':\n                continue\n            for index, name in enumerate(names):\n                if Model is None:\n                    msg = _(\n                        'Non-relational field %(field)r in path %(field_path)r in %(use)s)',\n                        field=names[index - 1], field_path=field_path, use=use,\n                    )\n                    self._raise_view_error(msg, node)\n                try:\n                    field = Model._fields[name]\n                except KeyError:\n                    msg = _(\n                        'Unknown field \"%(model)s.%(field)s\" in %(use)s)',\n                        model=Model._name, field=name, use=use,\n                    )\n                    self._raise_view_error(msg, node)\n                if not field._description_searchable:\n                    msg = _(\n                        'Unsearchable field %(field)r in path %(field_path)r in %(use)s)',\n                        field=name, field_path=field_path, use=use,\n                    )\n                    self._raise_view_error(msg, node)\n                Model = self.pool.get(field.comodel_name)\n\n    #------------------------------------------------------\n    # QWeb template views\n    #------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_read_template_keys",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _read_template_keys(self):\n        \"\"\" Return the list of context keys to use for caching ``_read_template``. \"\"\"\n        return ['lang', 'inherit_branding', 'edit_translations']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_read_template",
          "params": [
            "self",
            "view_id"
          ],
          "decorators": [],
          "source": "def _read_template(self, view_id):\n        arch_tree = self.browse(view_id)._get_combined_arch()\n        self.distribute_branding(arch_tree)\n        return etree.tostring(arch_tree, encoding='unicode')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_id",
          "params": [
            "self",
            "template"
          ],
          "decorators": [],
          "source": "def _get_view_id(self, template):\n        \"\"\" Return the view ID corresponding to ``template``, which may be a\n        view ID or an XML ID. Note that this method may be overridden for other\n        kinds of template values.\n        \"\"\"\n        if isinstance(template, int):\n            return template\n        if '.' not in template:\n            raise ValueError('Invalid template id: %r' % template)\n        view = self.sudo().search([('key', '=', template)], limit=1)\n        if view:\n            return view.id\n        res_model, res_id = self.env['ir.model.data']._xmlid_to_res_model_res_id(template, raise_if_not_found=True)\n        assert res_model == self._name, \"Call _get_view_id, expected %r, got %r\" % (self._name, res_model)\n        return res_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get",
          "params": [
            "self",
            "view_ref"
          ],
          "decorators": [],
          "source": "def _get(self, view_ref):\n        \"\"\" Return the view corresponding to ``view_ref``, which may be a\n        view ID or an XML ID.\n        \"\"\"\n        return self.browse(self._get_view_id(view_ref))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_contains_branded",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _contains_branded(self, node):\n        return node.tag == 't'\\\n            or 't-raw' in node.attrib\\\n            or 't-call' in node.attrib\\\n            or any(self.is_node_branded(child) for child in node.iterdescendants())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_pop_view_branding",
          "params": [
            "self",
            "element"
          ],
          "decorators": [],
          "source": "def _pop_view_branding(self, element):\n        distributed_branding = dict(\n            (attribute, element.attrib.pop(attribute))\n            for attribute in MOVABLE_BRANDING\n            if element.get(attribute))\n        return distributed_branding",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "is_node_branded",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def is_node_branded(self, node):\n        \"\"\" Finds out whether a node is branded or qweb-active (bears a",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "render_public_asset",
          "params": [
            "self",
            "template",
            "values=None"
          ],
          "decorators": [],
          "source": "def render_public_asset(self, template, values=None):\n        template_sudo = self._get(template).sudo()\n        template_sudo._check_view_access()\n        return self.env['ir.qweb'].sudo()._render(template, values)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_render_template",
          "params": [
            "self",
            "template",
            "values=None"
          ],
          "decorators": [],
          "source": "def _render_template(self, template, values=None):\n        return self.env['ir.qweb']._render(template, values)\n\n    #------------------------------------------------------\n    # Misc\n    #------------------------------------------------------",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_custom_views",
          "params": [
            "self",
            "model"
          ],
          "decorators": [],
          "source": "def _validate_custom_views(self, model):\n        \"\"\"Validate architecture of custom views (= without xml id) for a given model.\n            This method is called at the end of registry update.\n        \"\"\"\n        query = \"\"\"SELECT max(v.id)\n                     FROM ir_ui_view v\n                LEFT JOIN ir_model_data md ON (md.model = 'ir.ui.view' AND md.res_id = v.id)\n                    WHERE md.module IN (SELECT name FROM ir_module_module) IS NOT TRUE\n                      AND v.model = %s\n                      AND v.active = true\n                 GROUP BY coalesce(v.inherit_id, v.id)\"\"\"\n        self._cr.execute(query, [model])\n\n        rec = self.browse(it[0] for it in self._cr.fetchall())\n        return rec.with_context({'load_all_views': True})._check_xml()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_validate_module_views",
          "params": [
            "self",
            "module"
          ],
          "decorators": [],
          "source": "def _validate_module_views(self, module):\n        \"\"\" Validate the architecture of all the views of a given module that\n            are impacted by view updates, but have not been checked yet.\n        \"\"\"\n        assert self.pool._init\n\n        # only validate the views that still exist...\n        prefix = module + '.'\n        prefix_len = len(prefix)\n        names = tuple(\n            xmlid[prefix_len:]\n            for xmlid in self.pool.loaded_xmlids\n            if xmlid.startswith(prefix)\n        )\n        if not names:\n            return\n\n        # retrieve the views with an XML id that has not been checked yet, i.e.,\n        # the views with noupdate=True on their xml id\n        query = \"\"\"\n            SELECT v.id\n            FROM ir_ui_view v\n            JOIN ir_model_data md ON (md.model = 'ir.ui.view' AND md.res_id = v.id)\n            WHERE md.module = %s AND md.name IN %s AND md.noupdate\n        \"\"\"\n        self._cr.execute(query, (module, names))\n        views = self.browse([row[0] for row in self._cr.fetchall()])\n\n        for view in views:\n            view._check_xml()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_create_all_specific_views",
          "params": [
            "self",
            "processed_modules"
          ],
          "decorators": [],
          "source": "def _create_all_specific_views(self, processed_modules):\n        \"\"\"To be overriden and have specific view behaviour on create\"\"\"\n        pass",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_specific_views",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_specific_views(self):\n        \"\"\" Given a view, return a record set containing all the specific views\n            for that view's key.\n        \"\"\"\n        self.ensure_one()\n        # Only qweb views have a specific conterpart\n        if self.type != 'qweb':\n            return self.env['ir.ui.view']\n        # A specific view can have a xml_id if exported/imported but it will not be equals to it's key (only generic view will).\n        return self.with_context(active_test=False).search([('key', '=', self.key)]).filtered(lambda r: not r.xml_id == r.key)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load_records_write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _load_records_write(self, values):\n        \"\"\" During module update, when updating a generic view, we should also\n            update its specific views (COW'd).\n            Note that we will only update unmodified fields. That will mimic the\n            noupdate behavior on views having an ir.model.data.\n        \"\"\"\n        if self.type == 'qweb':\n            for cow_view in self._get_specific_views():\n                authorized_vals = {}\n                for key in values:\n                    if key != 'inherit_id' and cow_view[key] == self[key]:\n                        authorized_vals[key] = values[key]\n                # if inherit_id update, replicate change on cow view but\n                # only if that cow view inherit_id wasn't manually changed\n                inherit_id = values.get('inherit_id')\n                if inherit_id and self.inherit_id.id != inherit_id and \\\n                   cow_view.inherit_id.key == self.inherit_id.key:\n                    self._load_records_write_on_cow(cow_view, inherit_id, authorized_vals)\n                else:\n                    cow_view.with_context(no_cow=True).write(authorized_vals)\n        super(View, self)._load_records_write(values)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load_records_write_on_cow",
          "params": [
            "self",
            "cow_view",
            "inherit_id",
            "values"
          ],
          "decorators": [],
          "source": "def _load_records_write_on_cow(self, cow_view, inherit_id, values):\n        # for modules updated before `website`, we need to\n        # store the change to replay later on cow views\n        if not hasattr(self.pool, 'website_views_to_adapt'):\n            self.pool.website_views_to_adapt = []\n        self.pool.website_views_to_adapt.append((\n            cow_view.id,\n            inherit_id,\n            values,\n        ))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_xml",
          "definition": "@api.constrains('arch_db')\n    def _check_xml(self):\n        # Sanity checks: the view should not break anything upon rendering!\n        # Any exception raised below will cause a transaction rollback.\n        partial_validation = self.env.context.get('ir_ui_view_partial_validation')\n        self = self.with_context(validate_view_ids=(self._ids if partial_validation else True))\n\n        for view in self:\n            try:\n                # verify the view is valid xml and that the inheritance resolves\n                if view.inherit_id:\n                    view_arch = etree.fromstring(view.arch)\n                    view._valid_inheritance(view_arch)\n                combined_arch = view._get_combined_arch()\n                if view.type == 'qweb':\n                    continue\n            except (etree.ParseError, ValueError) as e:\n                err = ValidationError(_(\n                    \"Error while parsing or validating view:\\n\\n%(error)s\",\n                    error=tools.ustr(e),\n                    view=view.key or view.id,\n                )).with_traceback(e.__traceback__)\n                err.context = getattr(e, 'context', None)\n                raise err from None\n\n            try:\n                # verify that all fields used are valid, etc.\n                view._validate_view(combined_arch, view.model)\n                combined_archs = [combined_arch]\n\n                if combined_arch.xpath('//*[@attrs]') or combined_arch.xpath('//*[@states]'):\n                    view_name = f'{view.name} ({view.xml_id})' if view.xml_id else view.name\n                    err = ValidationError(_('Since 17.0, the \"attrs\" and \"states\" attributes are no longer used.\\nView: %(name)s in %(file)s',\n                        name=view_name, file=view.arch_fs\n                    ))\n                    err.context = {'name': 'invalid view'}\n                    raise err\n\n                if combined_archs[0].tag == 'data':\n                    # A <data> element is a wrapper for multiple root nodes\n                    combined_archs = combined_archs[0]\n                for view_arch in combined_archs:\n                    for node in view_arch.xpath('//*[@__validate__]'):\n                        del node.attrib['__validate__']\n                    check = valid_view(view_arch, env=self.env, model=view.model)\n                    if not check:\n                        view_name = f'{view.name} ({view.xml_id})' if view.xml_id else view.name\n                        raise ValidationError(_(\n                            'Invalid view %(name)s definition in %(file)s',\n                            name=view_name, file=view.arch_fs\n                        ))\n            except ValueError as e:\n                if hasattr(e, 'context'):\n                    lines = etree.tostring(combined_arch, encoding='unicode').splitlines(keepends=True)\n                    fivelines = \"\".join(lines[max(0, e.context[\"line\"]-3):e.context[\"line\"]+2])\n                    err = ValidationError(_(\n                        \"Error while validating view near:\\n\\n%(fivelines)s\\n%(error)s\",\n                        fivelines=fivelines, error=tools.ustr(e),\n                    ))\n                    err.context = e.context\n                    raise err.with_traceback(e.__traceback__) from None\n                else:\n                    err = ValidationError(_(\n                        \"Error while validating view (%(view)s):\\n\\n%(error)s\", view=self.key or self.id, error=tools.ustr(e.__context__),\n                    ))\n                    err.context = {'name': 'invalid view'}\n                    raise err.with_traceback(e.__context__.__traceback__) from None\n\n        return True",
          "message": "'arch_db'"
        },
        {
          "type": "python",
          "name": "_check_groups",
          "definition": "@api.constrains('type', 'groups_id', 'inherit_id')\n    def _check_groups(self):\n        for view in self:\n            if (view.groups_id and\n                view.inherit_id and\n                view.mode != 'primary'):\n                raise ValidationError(_(\"Inherited view cannot have 'Groups' define on the record. Use 'groups' attributes inside the view definition\"))",
          "message": "'type', 'groups_id', 'inherit_id'"
        },
        {
          "type": "python",
          "name": "_check_000_inheritance",
          "definition": "@api.constrains('inherit_id')\n    def _check_000_inheritance(self):\n        # NOTE: constraints methods are check alphabetically. Always ensure this method will be\n        #       called before other constraint methods to avoid infinite loop in `_get_combined_arch`.\n        if not self._check_recursion(parent='inherit_id'):\n            raise ValidationError(_('You cannot create recursive inherited views.'))\n\n    _sql_constraints = [\n        ('inheritance_mode',\n         \"CHECK (mode != 'extension' OR inherit_id IS NOT NULL)\",\n         \"Invalid inheritance mode: if the mode is 'extension', the view must\"\n         \" extend an other view\"),\n        ('qweb_required_key',\n         \"CHECK (type != 'qweb' OR key IS NOT NULL)\",\n         \"Invalid key: QWeb view should have a key\"),\n    ]",
          "message": "'inherit_id'"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "default_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_inheriting_views_domain (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_filter_xmlid_query (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "apply_inheritance_specs (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_read_template (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "render_public_asset (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_validate_custom_views (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_validate_module_views (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "View"
    },
    {
      "name": "reset.view.arch.wizard",
      "description": "Reset View Architecture Wizard",
      "fields": [
        {
          "name": "view_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "string": "View"
        },
        {
          "name": "view_name",
          "type": "Char",
          "string": "View Name"
        },
        {
          "name": "has_diff",
          "type": "Boolean"
        },
        {
          "name": "arch_diff",
          "type": "Html",
          "readonly": true,
          "string": "Architecture Diff"
        },
        {
          "name": "reset_mode",
          "type": "Selection"
        },
        {
          "name": "compare_view_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "string": "Compare To View"
        },
        {
          "name": "arch_to_compare",
          "type": "Text"
        }
      ],
      "methods": [
        {
          "name": "default_get",
          "params": [
            "self",
            "fields"
          ],
          "decorators": [],
          "source": "def default_get(self, fields):\n        view_ids = (self._context.get('active_model') == 'ir.ui.view' and\n                    self._context.get('active_ids') or [])\n        if len(view_ids) > 2:\n            raise ValidationError(_(\"Can't compare more than two views.\"))\n\n        result = super().default_get(fields)\n        result['view_id'] = view_ids and view_ids[0]\n        if len(view_ids) == 2:\n            result['reset_mode'] = 'other_view'\n            result['compare_view_id'] = view_ids[1]\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_arch_diff",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_arch_diff(self):\n        \"\"\" Depending of `reset_mode`, return the differences between the\n        current view arch and either its previous arch, its initial arch or\n        another view arch.\n        \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_table_name",
          "params": [
            "view_id"
          ],
          "decorators": [],
          "source": "def get_table_name(view_id):\n            name = view_id.display_name\n            if view_id.key or view_id.xml_id:\n                span = '<span class=\"ml-1 font-weight-normal small\">(%s)</span>'\n                name += span % (view_id.key or view_id.xml_id)\n            return name\n\n        for view in self:\n            diff_to = False\n            diff_to_name = False\n            if view.reset_mode == 'soft':\n                diff_to = view.view_id.arch_prev\n                diff_to_name = _(\"Previous Arch\")\n            elif view.reset_mode == 'other_view':\n                diff_to = view.compare_view_id.with_context(lang=None).arch\n                diff_to_name = get_table_name(view.compare_view_id)\n            elif view.reset_mode == 'hard' and view.view_id.arch_fs:\n                diff_to = view.view_id.with_context(read_arch_from_file=True, lang=None).arch\n                diff_to_name = _(\"File Arch\")\n\n            view.arch_to_compare = diff_to\n\n            if not diff_to:\n                view.arch_diff = False\n                view.has_diff = False\n            else:\n                view_arch = view.view_id.with_context(lang=None).arch\n                view.arch_diff = get_diff(\n                    (view_arch, get_table_name(view.view_id) if view.reset_mode == 'other_view' else _(\"Current Arch\")),\n                    (diff_to, diff_to_name),\n                    custom_style=False,\n                    dark_color_scheme=request and request.httprequest.cookies.get('color_scheme') == 'dark',\n                )\n                view.has_diff = view_arch != diff_to",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "reset_view_button",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def reset_view_button(self):\n        self.ensure_one()\n        if self.reset_mode == 'other_view':\n            self.view_id.write({'arch_db': self.arch_to_compare})\n        else:\n            self.view_id.reset_arch(self.reset_mode)\n        return {'type': 'ir.actions.act_window_close'}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "default_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ResetViewArchWizard"
    },
    {
      "name": "date",
      "description": "",
      "fields": [],
      "methods": [
        {
          "name": "_get_access_action",
          "params": [
            "self",
            "access_uid=None",
            "force_website=False"
          ],
          "decorators": [],
          "source": "def _get_access_action(self, access_uid=None, force_website=False):\n        \"\"\" Return an action to open the document. This method is meant to be\n        overridden in addons that want to give specific access to the document.\n        By default, it opens the formview of the document.\n\n        :param integer access_uid: optional access_uid being the user that\n            accesses the document. May be different from the current user as we\n            may compute an access for someone else.\n        :param integer force_website: force frontend redirection if available\n            on self. Used in overrides, notably with portal / website addons.\n        \"\"\"\n        self.ensure_one()\n        return self.get_formview_action(access_uid=access_uid)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_empty_list_help",
          "params": [
            "self",
            "help_message"
          ],
          "decorators": [],
          "source": "def get_empty_list_help(self, help_message):\n        \"\"\" Hook method to customize the help message in empty list/kanban views.\n\n        By default, it returns the help received as parameter.\n\n        :param str help: ir.actions.act_window help content\n        :return: help message displayed when there is no result to display\n          in a list/kanban view (by default, it returns the action help)\n        :rtype: str\n        \"\"\"\n        return help_message\n\n    #\n    # Override this method if you need a window title that depends on the context\n    #",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "view_header_get",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'"
          ],
          "decorators": [],
          "source": "def view_header_get(self, view_id=None, view_type='form'):\n        return False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_form_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_form_view(self):\n        \"\"\" Generates a default single-line form view using all fields\n        of the current model.\n\n        :returns: a form view as an lxml document\n        :rtype: etree._Element\n        \"\"\"\n        sheet = E.sheet(string=self._description)\n        main_group = E.group()\n        left_group = E.group()\n        right_group = E.group()\n        for fname, field in self._fields.items():\n            if field.automatic:\n                continue\n            elif field.type in ('one2many', 'many2many', 'text', 'html'):\n                # append to sheet left and right group if needed\n                if len(left_group) > 0:\n                    main_group.append(left_group)\n                    left_group = E.group()\n                if len(right_group) > 0:\n                    main_group.append(right_group)\n                    right_group = E.group()\n                if len(main_group) > 0:\n                    sheet.append(main_group)\n                    main_group = E.group()\n                # add an oneline group for field type 'one2many', 'many2many', 'text', 'html'\n                sheet.append(E.group(E.field(name=fname)))\n            else:\n                if len(left_group) > len(right_group):\n                    right_group.append(E.field(name=fname))\n                else:\n                    left_group.append(E.field(name=fname))\n        if len(left_group) > 0:\n            main_group.append(left_group)\n        if len(right_group) > 0:\n            main_group.append(right_group)\n        sheet.append(main_group)\n        sheet.append(E.group(E.separator()))\n        return E.form(sheet)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_search_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_search_view(self):\n        \"\"\" Generates a single-field search view, based on _rec_name.\n\n        :returns: a tree view as an lxml document\n        :rtype: etree._Element\n        \"\"\"\n        element = E.field(name=self._rec_name_fallback())\n        return E.search(element, string=self._description)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_tree_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_tree_view(self):\n        \"\"\" Generates a single-field tree view, based on _rec_name.\n\n        :returns: a tree view as an lxml document\n        :rtype: etree._Element\n        \"\"\"\n        element = E.field(name=self._rec_name_fallback())\n        return E.tree(element, string=self._description)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_pivot_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_pivot_view(self):\n        \"\"\" Generates an empty pivot view.\n\n        :returns: a pivot view as an lxml document\n        :rtype: etree._Element\n        \"\"\"\n        return E.pivot(string=self._description)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_kanban_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_kanban_view(self):\n        \"\"\" Generates a single-field kanban view, based on _rec_name.\n\n        :returns: a kanban view as an lxml document\n        :rtype: etree._Element\n        \"\"\"\n\n        field = E.field(name=self._rec_name_fallback())\n        content_div = E.div(field, {'class': \"o_kanban_card_content\"})\n        card_div = E.div(content_div, {'t-attf-class': \"oe_kanban_card oe_kanban_global_click\"})\n        kanban_box = E.t(card_div, {'t-name': \"kanban-box\"})\n        templates = E.templates(kanban_box)\n        return E.kanban(templates, string=self._description)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_graph_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_graph_view(self):\n        \"\"\" Generates a single-field graph view, based on _rec_name.\n\n        :returns: a graph view as an lxml document\n        :rtype: etree._Element\n        \"\"\"\n        element = E.field(name=self._rec_name_fallback())\n        return E.graph(element, string=self._description)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_calendar_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_calendar_view(self):\n        \"\"\" Generates a default calendar view by trying to infer\n        calendar fields from a number of pre-set attribute names\n\n        :returns: a calendar view\n        :rtype: etree._Element\n        \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "set_first_of",
          "params": [
            "seq",
            "in_",
            "to"
          ],
          "decorators": [],
          "source": "def set_first_of(seq, in_, to):\n            \"\"\"Sets the first value of ``seq`` also found in ``in_`` to\n            the ``to`` attribute of the ``view`` being closed over.\n\n            Returns whether it's found a suitable value (and set it on\n            the attribute) or not\n            \"\"\"\n            for item in seq:\n                if item in in_:\n                    view.set(to, item)\n                    return True\n            return False\n\n        view = E.calendar(string=self._description)\n        view.append(E.field(name=self._rec_name_fallback()))\n\n        if not set_first_of([self._date_name, 'date', 'date_start', 'x_date', 'x_date_start'],\n                            self._fields, 'date_start'):\n            raise UserError(_(\"Insufficient fields for Calendar View!\"))\n\n        set_first_of([\"user_id\", \"partner_id\", \"x_user_id\", \"x_partner_id\"],\n                     self._fields, 'color')\n\n        if not set_first_of([\"date_stop\", \"date_end\", \"x_date_stop\", \"x_date_end\"],\n                            self._fields, 'date_stop'):\n            if not set_first_of([\"date_delay\", \"planned_hours\", \"x_date_delay\", \"x_planned_hours\"],\n                                self._fields, 'date_delay'):\n                raise UserError(_(\n                    \"Insufficient fields to generate a Calendar View for %s, missing a date_stop or a date_delay\",\n                    self._name\n                ))\n\n        return view",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_views",
          "params": [
            "self",
            "views",
            "options=None"
          ],
          "decorators": [],
          "source": "def get_views(self, views, options=None):\n        \"\"\" Returns the fields_views of given views, along with the fields of\n        the current model, and optionally its filters for the given action.\n\n        The return of the method can only depend on the requested view types,\n        access rights (views or other records), view access rules, options,\n        context lang and TYPE_view_ref (other context values cannot be used).\n\n        Python expressions contained in views or representing domains (on\n        python fields) will be evaluated by the client with all the context\n        values as well as the record values it has.\n\n        :param views: list of [view_id, view_type]\n        :param dict options: a dict optional boolean flags, set to enable:\n\n            ``toolbar``\n                includes contextual actions when loading fields_views\n            ``load_filters``\n                returns the model's filters\n            ``action_id``\n                id of the action to get the filters, otherwise loads the global\n                filters or the model\n\n        :return: dictionary with fields_views, fields and optionally filters\n        \"\"\"\n        options = options or {}\n        result = {}\n\n        result['views'] = {\n            v_type: self.get_view(\n                v_id, v_type if v_type != 'list' else 'tree',\n                **options\n            )\n            for [v_id, v_type] in views\n        }\n\n        models = {}\n        for view in result['views'].values():\n            for model, model_fields in view.pop('models').items():\n                models.setdefault(model, set()).update(model_fields)\n\n        result['models'] = {}\n\n        for model, model_fields in models.items():\n            result['models'][model] = self.env[model].fields_get(\n                allfields=model_fields, attributes=self._get_view_field_attributes()\n            )\n\n        # Add related action information if asked\n        if options.get('toolbar'):\n            for view in result['views'].values():\n                view['toolbar'] = {}\n\n            bindings = self.env['ir.actions.actions'].get_bindings(self._name)\n            for action_type, key in (('report', 'print'), ('action', 'action')):\n                for action in bindings.get(action_type, []):\n                    view_types = (\n                        action['binding_view_types'].split(',')\n                        if action.get('binding_view_types')\n                        else result['views'].keys()\n                    )\n                    for view_type in view_types:\n                        view_type = view_type if view_type != 'tree' else 'list'\n                        if view_type in result['views']:\n                            result['views'][view_type]['toolbar'].setdefault(key, []).append(action)\n\n        if options.get('load_filters') and 'search' in result['views']:\n            result['views']['search']['filters'] = self.env['ir.filters'].get_filters(\n                self._name, options.get('action_id')\n            )\n\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view(self, view_id=None, view_type='form', **options):\n        \"\"\"Get the model view combined architecture (the view along all its inheriting views).\n\n        :param int view_id: id of the view or None\n        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)\n        :param dict options: bool options to return additional features:\n            - bool mobile: true if the web client is currently using the responsive mobile view\n              (to use kanban views instead of list views for x2many fields)\n        :return: architecture of the view as an etree node, and the browse record of the view used\n        :rtype: tuple\n        :raise AttributeError:\n            if no view exists for that model, and no method `_get_default_[view_type]_view` exists for the view type\n\n        \"\"\"\n        View = self.env['ir.ui.view'].sudo()\n\n        # try to find a view_id if none provided\n        if not view_id:\n            # <view_type>_view_ref in context can be used to override the default view\n            view_ref_key = view_type + '_view_ref'\n            view_ref = self._context.get(view_ref_key)\n            if view_ref:\n                if '.' in view_ref:\n                    module, view_ref = view_ref.split('.', 1)\n                    query = \"SELECT res_id FROM ir_model_data WHERE model='ir.ui.view' AND module=%s AND name=%s\"\n                    self._cr.execute(query, (module, view_ref))\n                    view_ref_res = self._cr.fetchone()\n                    if view_ref_res:\n                        view_id = view_ref_res[0]\n                else:\n                    _logger.warning(\n                        '%r requires a fully-qualified external id (got: %r for model %s). '\n                        'Please use the complete `module.view_id` form instead.', view_ref_key, view_ref,\n                        self._name\n                    )\n\n            if not view_id:\n                # otherwise try to find the lowest priority matching ir.ui.view\n                view_id = View.default_view(self._name, view_type)\n\n        if view_id:\n            # read the view with inherited views applied\n            view = View.browse(view_id)\n            arch = view._get_combined_arch()\n        else:\n            # fallback on default views methods if no ir.ui.view could be found\n            view = View.browse()\n            try:\n                arch = getattr(self, '_get_default_%s_view' % view_type)()\n            except AttributeError:\n                raise UserError(_(\"No default view of type '%s' could be found!\", view_type))\n        return arch, view",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_cache_key",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view_cache_key(self, view_id=None, view_type='form', **options):\n        \"\"\" Get the key to use for caching `_get_view_cache`.\n\n        This method is meant to be overriden by models needing additional keys.\n\n        :param int view_id: id of the view or None\n        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)\n        :param dict options: bool options to return additional features:\n            - bool mobile: true if the web client is currently using the responsive mobile view\n              (to use kanban views instead of list views for x2many fields)\n        :return: a cache key\n        :rtype: tuple\n        \"\"\"\n        return (view_id, view_type, options.get('mobile'), self.env.lang) + tuple(\n            (key, value) for key, value in self.env.context.items() if key.endswith('_view_ref')\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_cache",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view_cache(self, view_id=None, view_type='form', **options):\n        \"\"\" Get the view information ready to be cached\n\n        The cached view includes the postprocessed view, including inherited views, for all groups.\n        The blocks restricted to groups must therefore be removed after calling this method\n        for users not part of the given groups.\n\n        :param int view_id: id of the view or None\n        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)\n        :param dict options: boolean options to return additional features:\n            - bool mobile: true if the web client is currently using the responsive mobile view\n              (to use kanban views instead of list views for x2many fields)\n        :return: a dictionnary including\n            - string arch: the architecture of the view (including inherited views, postprocessed, for all groups)\n            - int id: the view id\n            - string model: the view model\n            - dict models: the fields of the models used in the view (including sub-views)\n        :rtype: dict\n        \"\"\"\n        # Get the view arch and all other attributes describing the composition of the view\n        arch, view = self._get_view(view_id, view_type, **options)\n\n        # Apply post processing, groups and modifiers etc...\n        arch, models = view.postprocess_and_fields(arch, model=self._name, **options)\n        models = self._get_view_fields(view_type or view.type, models)\n        result = {\n            'arch': arch,\n            # TODO: only `web_studio` seems to require this. I guess this is acceptable to keep it.\n            'id': view.id,\n            # TODO: only `web_studio` seems to require this. But this one on the other hand should be eliminated:\n            # you just called `get_views` for that model, so obviously the web client already knows the model.\n            'model': self._name,\n            # Set a frozendict and tuple for the field list to make sure the value in cache cannot be updated.\n            'models': frozendict({model: tuple(fields) for model, fields in models.items()}),\n        }\n\n        return frozendict(result)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_view",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def get_view(self, view_id=None, view_type='form', **options):\n        \"\"\" get_view([view_id | view_type='form'])\n\n        Get the detailed composition of the requested view like model, view architecture.\n\n        The return of the method can only depend on the requested view types,\n        access rights (views or other records), view access rules, options,\n        context lang and TYPE_view_ref (other context values cannot be used).\n\n        :param int view_id: id of the view or None\n        :param str view_type: type of the view to return if view_id is None ('form', 'tree', ...)\n        :param dict options: boolean options to return additional features:\n            - bool mobile: true if the web client is currently using the responsive mobile view\n            (to use kanban views instead of list views for x2many fields)\n        :return: composition of the requested view (including inherited views and extensions)\n        :rtype: dict\n        :raise AttributeError:\n\n            * if the inherited view has unknown position to work with other than 'before', 'after', 'inside', 'replace'\n            * if some tag other than 'position' is found in parent view\n\n        :raise Invalid ArchitectureError: if there is view type other than form, tree, calendar, search etc... defined on the structure\n        \"\"\"\n        self.check_access_rights('read')\n\n        result = dict(self._get_view_cache(view_id, view_type, **options))\n\n        node = etree.fromstring(result['arch'])\n        node = self.env['ir.ui.view']._postprocess_access_rights(node)\n        result['arch'] = etree.tostring(node, encoding=\"unicode\").replace('\\t', '')\n\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_fields",
          "params": [
            "self",
            "view_type",
            "models"
          ],
          "decorators": [],
          "source": "def _get_view_fields(self, view_type, models):\n        \"\"\" Returns the field names required by the web client to load the views according to the view type.\n\n        The method is meant to be overridden by modules extending web client features and requiring additional\n        fields.\n\n        :param string view_type: type of the view\n        :param dict models: dict holding the models and fields used in the view architecture.\n        :return: dict holding the models and field required by the web client given the view type.\n        :rtype: list\n        \"\"\"\n        if view_type in ('kanban', 'tree', 'form'):\n            for model, model_fields in models.items():\n                model_fields.add('id')\n                if 'write_date' in self.env[model]._fields:\n                    model_fields.add('write_date')\n        elif view_type == 'search':\n            models[self._name] = list(self._fields.keys())\n        elif view_type == 'graph':\n            models[self._name].union(fname for fname, field in self._fields.items() if field.type in ('integer', 'float'))\n        elif view_type == 'pivot':\n            models[self._name].union(fname for fname, field in self._fields.items() if field.groupable)\n        return models",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_field_attributes",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_view_field_attributes(self):\n        \"\"\" Returns the field attributes required by the web client to load the views.\n\n        The method is meant to be overridden by modules extending web client features and requiring additional\n        field attributes.\n\n        :return: string list of field attribute names\n        :rtype: list\n        \"\"\"\n        return [\n            'change_default', 'context', 'currency_field', 'definition_record', 'definition_record_field', 'digits', 'domain', 'group_operator', 'groups',\n            'help', 'name', 'readonly', 'related', 'relation', 'relation_field', 'required', 'searchable', 'selection', 'size',\n            'sortable', 'store', 'string', 'translate', 'trim', 'type',\n        ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_formview_id",
          "params": [
            "self",
            "access_uid=None"
          ],
          "decorators": [],
          "source": "def get_formview_id(self, access_uid=None):\n        \"\"\" Return a view id to open the document ``self`` with. This method is\n            meant to be overridden in addons that want to give specific view ids\n            for example.\n\n            Optional access_uid holds the user that would access the form view\n            id different from the current environment user.\n        \"\"\"\n        return False",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_formview_action",
          "params": [
            "self",
            "access_uid=None"
          ],
          "decorators": [],
          "source": "def get_formview_action(self, access_uid=None):\n        \"\"\" Return an action to open the document ``self``. This method is meant\n            to be overridden in addons that want to give specific view ids for\n            example.\n\n        An optional access_uid holds the user that will access the document\n        that could be different from the current user. \"\"\"\n        view_id = self.sudo().get_formview_id(access_uid=access_uid)\n        return {\n            'type': 'ir.actions.act_window',\n            'res_model': self._name,\n            'views': [(view_id, 'form')],\n            'target': 'current',\n            'res_id': self.id,\n            'context': dict(self._context),\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_records_action",
          "params": [
            "self",
            "**kwargs"
          ],
          "decorators": [],
          "source": "def _get_records_action(self, **kwargs):\n        \"\"\" Return an action to open given records.\n            If there's more than one record, it will be a List, otherwise it's a Form.\n            Given keyword arguments will overwrite default ones. \"\"\"\n        match self.ids:  # `self.ids` will silently filter out new records (`NewId`s)\n            case []:\n                length_dependent = {'views': [(False, 'form')]}\n            case [res_id]:\n                length_dependent = {'views': [(False, 'form')], 'res_id': res_id}\n            case ids:\n                length_dependent = {\n                    'views': [(False, 'list'), (False, 'form')],\n                    'domain': [('id', 'in', ids)]\n                }\n        return {\n            'type': 'ir.actions.act_window',\n            'res_model': self._name,\n            'target': 'current',\n            'context': dict(self._context),\n            **length_dependent,\n            **kwargs\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_spec",
          "params": [
            "self",
            "view_info=None"
          ],
          "decorators": [],
          "source": "def _onchange_spec(self, view_info=None):\n        \"\"\" Return the onchange spec from a view description; if not given, the\n            result of ``self.get_view()`` is used.\n        \"\"\"\n        result = {}\n\n        # for traversing the XML arch and populating result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "process",
          "params": [
            "node",
            "info",
            "prefix"
          ],
          "decorators": [],
          "source": "def process(node, info, prefix):\n            if node.tag == 'field':\n                name = node.attrib['name']\n                names = \"%s.%s\" % (prefix, name) if prefix else name\n                if not result.get(names):\n                    result[names] = node.attrib.get('on_change')\n                # traverse the subviews included in relational fields\n                for child_view in node.xpath(\"./*[descendant::field]\"):\n                    process(child_view, None, names)\n            else:\n                for child in node:\n                    process(child, info, prefix)\n\n        if view_info is None:\n            view_info = self.get_view()\n        process(etree.fromstring(view_info['arch']), view_info, '')\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_fields_spec",
          "params": [
            "self",
            "view_info=None"
          ],
          "decorators": [],
          "source": "def _get_fields_spec(self, view_info=None):\n        \"\"\" Return the fields specification from a view description; if not\n        given, the result of ``self.get_view()`` is used.\n        \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "fill_spec",
          "params": [
            "node",
            "model",
            "fields_spec"
          ],
          "decorators": [],
          "source": "def fill_spec(node, model, fields_spec):\n            if node.tag == 'field':\n                field_name = node.attrib['name']\n                field_spec = fields_spec.setdefault(field_name, {})\n                field = model._fields.get(field_name)\n                if field is not None:\n                    sub_fields_spec = {}\n                    if field.type == 'many2one':\n                        sub_fields_spec.setdefault('display_name', {})\n                    if field.relational:\n                        comodel = model.env[field.comodel_name]\n                        for child in node:\n                            fill_spec(child, comodel, sub_fields_spec)\n                    if field.type == 'one2many':\n                        sub_fields_spec.pop(field.inverse_name, None)\n                    if sub_fields_spec:\n                        field_spec.setdefault('fields', {}).update(sub_fields_spec)\n            else:\n                for child in node:\n                    fill_spec(child, model, fields_spec)\n\n        if view_info is None:\n            view_info = self.get_view()\n\n        result = {}\n        fill_spec(etree.fromstring(view_info['arch']), self, result)\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "__init__",
          "params": [
            "self",
            "model",
            "parent=None"
          ],
          "decorators": [],
          "source": "def __init__(self, model, parent=None):\n        self.model = model\n        self.available_fields = collections.defaultdict(dict)  # {field_name: {'groups': groups, 'info': field_info}}\n        self.available_actions = set()\n        self.available_names = set()\n        self.mandatory_fields = collections.defaultdict(dict)  # {field_name: {'groups': 'use}}\n        self.mandatory_parent_fields = collections.defaultdict(dict)  # {field_name: {'groups': use}}\n        self.mandatory_names = dict()           # {name: use}\n        self.must_exist_actions = {}\n        self.must_exist_groups = {}\n        self.parent = parent\n        self.children = []\n        if self.parent:\n            self.parent.children.append(self)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "field_info",
          "params": [
            "self"
          ],
          "decorators": [
            "@lazy_property"
          ],
          "source": "@lazy_property\n    def field_info(self):\n        field_info = self.model.fields_get(attributes=['readonly', 'required'])\n        has_access = functools.partial(self.model.check_access_rights, raise_exception=False)\n        if not (has_access('write') or has_access('create')):\n            for info in field_info.values():\n                info['readonly'] = True\n        return field_info",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "has_field",
          "params": [
            "self",
            "node",
            "name",
            "info=frozendict()"
          ],
          "decorators": [],
          "source": "def has_field(self, node, name, info=frozendict()):\n        groups = self._get_node_groups(node)\n        self.available_fields[name].setdefault('info', {}).update(info)\n        self.available_fields[name].setdefault('groups', []).append(groups)\n        self.available_names.add(info.get('id') or name)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "has_action",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def has_action(self, name):\n        self.available_actions.add(name)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "must_have_field",
          "params": [
            "self",
            "node",
            "name",
            "use",
            "groups=None"
          ],
          "decorators": [],
          "source": "def must_have_field(self, node, name, use, groups=None):\n        node_groups = self._get_node_groups(node)\n        if groups:\n            groups = groups + node_groups\n        else:\n            groups = node_groups\n        if name.startswith('parent.'):\n            self.mandatory_parent_fields[name[7:]][groups] = use\n        else:\n            self.mandatory_fields[name][groups] = use",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "must_have_fields",
          "params": [
            "self",
            "node",
            "names",
            "use",
            "groups=None"
          ],
          "decorators": [],
          "source": "def must_have_fields(self, node, names, use, groups=None):\n        for name in names:\n            self.must_have_field(node, name, use, groups=groups)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "must_have_name",
          "params": [
            "self",
            "name",
            "use"
          ],
          "decorators": [],
          "source": "def must_have_name(self, name, use):\n        self.mandatory_names[name] = use",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "must_exist_action",
          "params": [
            "self",
            "action_id",
            "node"
          ],
          "decorators": [],
          "source": "def must_exist_action(self, action_id, node):\n        self.must_exist_actions[action_id] = node",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "must_exist_group",
          "params": [
            "self",
            "name",
            "node"
          ],
          "decorators": [],
          "source": "def must_exist_group(self, name, node):\n        self.must_exist_groups[name] = node",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_node_groups",
          "params": [
            "self",
            "node"
          ],
          "decorators": [],
          "source": "def _get_node_groups(self, node):\n        return tuple(tuple(n.get('groups').split(',')) for n in chain([node], node.iterancestors()) if n.get('groups'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "check",
          "params": [
            "self",
            "view"
          ],
          "decorators": [],
          "source": "def check(self, view):\n        # context for translations below\n        context = view.env.context          # pylint: disable=unused-variable\n\n        for name, use in self.mandatory_names.items():\n            if name not in self.available_actions and name not in self.available_names:\n                msg = _(\n                    \"Name or id %(name_or_id)r in %(use)s must be present in view but is missing.\",\n                    name_or_id=name, use=use,\n                )\n                view._raise_view_error(msg)\n\n        for name in self.available_fields:\n            if name not in self.model._fields and name not in self.field_info:\n                message = _(\"Field `%(name)s` does not exist\", name=name)\n                view._raise_view_error(message)\n\n        for name, node in self.must_exist_actions.items():\n            # logic mimics /web/action/load behaviour\n            action = False\n            try:\n                action_id = int(name)\n            except ValueError:\n                model, action_id = view.env['ir.model.data']._xmlid_to_res_model_res_id(name, raise_if_not_found=False)\n                if not action_id:\n                    msg = _(\"Invalid xmlid %(xmlid)s for button of type action.\", xmlid=name)\n                    view._raise_view_error(msg, node)\n                if not issubclass(view.pool[model], view.pool['ir.actions.actions']):\n                    msg = _(\n                        \"%(xmlid)s is of type %(xmlid_model)s, expected a subclass of ir.actions.actions\",\n                        xmlid=name, xmlid_model=model,\n                    )\n                    view._raise_view_error(msg, node)\n            action = view.env['ir.actions.actions'].browse(action_id).exists()\n            if not action:\n                msg = _(\n                    \"Action %(action_reference)s (id: %(action_id)s) does not exist for button of type action.\",\n                    action_reference=name, action_id=action_id,\n                )\n                view._raise_view_error(msg, node)\n\n        for name, node in self.must_exist_groups.items():\n            if not view.env['ir.model.data']._xmlid_to_res_id(name, raise_if_not_found=False):\n                msg = _(\"The group %(name)r defined in view does not exist!\", name=name)\n                view._log_view_warning(msg, node)\n\n        for name, groups_uses in self.mandatory_fields.items():\n            use = next(iter(groups_uses.values()))\n            if name == 'id':  # always available\n                continue\n            if \".\" in name:\n                msg = _(\n                    \"Invalid composed field %(definition)s in %(use)s\",\n                    definition=name, use=use,\n                )\n                view._raise_view_error(msg)\n            info = self.available_fields[name].get('info')\n            if info is None:\n                if name in ['active_id', 'active_ids', 'active_model']:\n                    _logger.warning(\"Using active_id, active_ids and active_model in expressions is deprecated, found %s\", name)\n                    continue\n                msg = _(\n                    \"Field %(name)r used in %(use)s must be present in view but is missing.\",\n                    name=name, use=use,\n                )\n                view._raise_view_error(msg)\n            if info.get('select') == 'multi':  # mainly for searchpanel, but can be a generic behaviour.\n                msg = _(\n                    \"Field %(name)r used in %(use)s is present in view but is in select multi.\",\n                    name=name, use=use,\n                )\n                view._raise_view_error(msg)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "combinate",
          "params": [
            "groups"
          ],
          "decorators": [],
          "source": "def combinate(groups):\n                # [['A'], ['B', 'C'], ['D', 'E']]\n                # returns\n                # [['A', 'B', 'D'], ['A', 'C', 'D'], ['A', 'B', 'E'], ['A', 'C', 'E']]\n\n                # [['!A', '!B'], ['C', 'D']]\n                # returns\n                # [['!A', '!B', 'C'], ['!A', '!B', 'D']]\n\n                # [['A', 'B'], ['!C', '!D']]\n                # returns\n                # [['A', '!C', '!D'], ['B', '!C', '!D']]\n\n                # [['!A', '!B', 'C', 'D'], ['E', 'F']]\n                # returns\n                # [['!A', '!B', 'C', 'E'], ['!A', '!B', 'D', 'E'], ['!A', '!B', 'C', 'F'], ['!A', '!B', 'D', 'F']]\n                if not groups:\n                    return []\n                positive = [(group,) for group in groups[0] if not group or not group.startswith('!')]\n                negative = tuple(group for group in groups[0] if group and group.startswith('!'))\n                combinations = [negative + p for p in positive] if positive else [negative]\n                if len(groups) > 1:\n                    combinations = [group + tuple(c) for c in combinate(groups[1:]) for group in combinations]\n                return [set(combination) for combination in set(tuple(combination) for combination in combinations)]\n\n            for mandatory_for_groups, use in groups_uses.items():\n                mandatory_combinations = combinate(mandatory_for_groups or [(None,)])\n                available_combinations = [\n                    combination\n                    for available_for_groups in self.available_fields[name]['groups']\n                    for combination in combinate(available_for_groups or [(None,)])\n                ]\n                if (\n                    # If (None,) is in available_combinations,\n                    # it means the field is in the view without any group restriction,\n                    # and is therefore available for anyone / any group\n                    {None} not in available_combinations\n                    # If there are two mutually exclusive combinations,\n                    # it means the field is available for anyone / any group\n                    and not any(\n                        {group[1:] if group.startswith('!') else '!' + group for group in combination}\n                        in available_combinations\n                        for combination in available_combinations\n                    )\n                    and ((\n                    # For all mandatory combinations, find an available combination\n                    # which is included in the mandatory combination\n                    # e.g.\n                    # mandatory combination: A B C\n                    # available combination: A B\n                    # The above is valid, the field will be available for users having both A and B groups\n                    # and the field is mandatory only for users having A B and C groups.\n                    not all(\n                        any(\n                            available_combination.issubset(mandatory_combination)\n                            for available_combination in available_combinations\n                        ) for mandatory_combination in mandatory_combinations\n                    )\n                    # Same than above but take into account implied groups (e.g. group_system includes group_erp_manager and group_user)\n                    # for positive groups\n                    and not all(\n                        any(\n                            available_combination.issubset(combination)\n                            for available_combination in available_combinations\n                            for combination in\n                            (\n                                mandatory_combination - {group} | {trans_group}\n                                for group in mandatory_combination if group and not group.startswith('!')\n                                for trans_group in view.env.ref(group).trans_implied_ids.get_external_id().values()\n                            )\n                        )\n                        for mandatory_combination in mandatory_combinations\n                    )\n                    # Same than above but take into account implied groups (e.g. group_system includes group_erp_manager and group_user)\n                    # for negative groups\n                    and not all(\n                        any(\n                            combination.issubset(mandatory_combination)\n                            for available_combination in available_combinations\n                            for combination in\n                            (\n                                available_combination - {group} | {'!' + trans_group}\n                                for group in available_combination if group and group.startswith('!')\n                                for trans_group in view.env.ref(group[1:]).trans_implied_ids.get_external_id().values()\n                            )\n                        ) for mandatory_combination in mandatory_combinations\n                    )\n                    )\n                    # if 'base.group_no_one' is in available_combinations the group\n                    # must be in mandatory_combinations because depending of session\n                    or (\n                        {'base.group_no_one'} in available_combinations and\n                        not all('base.group_no_one' in combination for combination in mandatory_combinations)\n                    ))\n                ):\n                    msg = _(\n                        \"Field %(name)r used in %(use)s is restricted to the group(s) %(groups)s.\",\n                        name=name, use=use, groups=','.join(\n                            group\n                            for availability in self.available_fields[name]['groups']\n                            for combination in availability\n                            for group in combination\n                        )\n                    )\n                    view._raise_view_error(msg)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "update_available_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def update_available_fields(self):\n        for name, info in self.available_fields.items():\n            info.update(self.field_info.get(name, ()))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "base"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "get_empty_list_help (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "view_header_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_form_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_search_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_tree_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_pivot_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_kanban_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_graph_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_calendar_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_views (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view_cache_key (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view_fields (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view_field_attributes (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_onchange_spec (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_fields_spec (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Model"
    },
    {
      "name": "report.layout",
      "description": "Report Layout",
      "fields": [
        {
          "name": "view_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "required": true
        },
        {
          "name": "image",
          "type": "Char",
          "string": "Preview image src"
        },
        {
          "name": "pdf",
          "type": "Char",
          "string": "Preview pdf src"
        },
        {
          "name": "sequence",
          "type": "Integer"
        },
        {
          "name": "name",
          "type": "Char"
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ReportLayout"
    },
    {
      "name": "report.paperformat",
      "description": "Paper Format Config",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "default",
          "type": "Boolean"
        },
        {
          "name": "format",
          "type": "Selection"
        },
        {
          "name": "margin_top",
          "type": "Float"
        },
        {
          "name": "margin_bottom",
          "type": "Float"
        },
        {
          "name": "margin_left",
          "type": "Float"
        },
        {
          "name": "margin_right",
          "type": "Float"
        },
        {
          "name": "page_height",
          "type": "Integer"
        },
        {
          "name": "page_width",
          "type": "Integer"
        },
        {
          "name": "orientation",
          "type": "Selection"
        },
        {
          "name": "header_line",
          "type": "Boolean"
        },
        {
          "name": "header_spacing",
          "type": "Integer"
        },
        {
          "name": "disable_shrinking",
          "type": "Boolean"
        },
        {
          "name": "dpi",
          "type": "Integer",
          "required": true
        },
        {
          "name": "report_ids",
          "type": "One2many",
          "relation": "ir.actions.report",
          "help": "Explicitly associated reports"
        },
        {
          "name": "print_page_width",
          "type": "Float"
        },
        {
          "name": "print_page_height",
          "type": "Float"
        }
      ],
      "methods": [
        {
          "name": "_check_format_or_page",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_format_or_page(self):\n        if self.filtered(lambda x: x.format != 'custom' and (x.page_width or x.page_height)):\n            raise ValidationError(_('You can select either a format or a specific page width/height, but not both.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_print_page_size",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_print_page_size(self):\n        for record in self:\n            width = height = 0.0\n            if record.format:\n                if record.format == 'custom':\n                    width = record.page_width\n                    height = record.page_height\n                else:\n                    paper_size = next(ps for ps in PAPER_SIZES if ps['key'] == record.format)\n                    width = paper_size['width']\n                    height = paper_size['height']\n\n            if record.orientation == 'Landscape':\n                # swap sizes\n                width, height = height, width\n\n            record.print_page_width = width\n            record.print_page_height = height",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_format_or_page",
          "definition": "@api.constrains('format')\n    def _check_format_or_page(self):\n        if self.filtered(lambda x: x.format != 'custom' and (x.page_width or x.page_height)):\n            raise ValidationError(_('You can select either a format or a specific page width/height, but not both.'))",
          "message": "'format'"
        }
      ],
      "accessRules": [],
      "className": "report_paperformat"
    },
    {
      "name": "res.bank",
      "description": "Bank",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "street",
          "type": "Char"
        },
        {
          "name": "street2",
          "type": "Char"
        },
        {
          "name": "zip",
          "type": "Char"
        },
        {
          "name": "city",
          "type": "Char"
        },
        {
          "name": "state",
          "type": "Many2one",
          "relation": "res.country.state"
        },
        {
          "name": "country",
          "type": "Many2one",
          "relation": "res.country"
        },
        {
          "name": "email",
          "type": "Char"
        },
        {
          "name": "phone",
          "type": "Char"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "bic",
          "type": "Char",
          "help": "Sometimes called BIC or Swift."
        }
      ],
      "methods": [
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        for bank in self:\n            name = (bank.name or '') + (bank.bic and (' - ' + bank.bic) or '')\n            bank.display_name = name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_name_search",
          "params": [
            "self",
            "name",
            "domain=None",
            "operator='ilike'",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n        domain = domain or []\n        if name:\n            name_domain = ['|', ('bic', '=ilike', name + '%'), ('name', operator, name)]\n            if operator in expression.NEGATIVE_TERM_OPERATORS:\n                name_domain = ['&', '!'] + name_domain[1:]\n            domain = domain + name_domain\n        return self._search(domain, limit=limit, order=order)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_country_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_country_id(self):\n        if self.country and self.country != self.state.country_id:\n            self.state = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_state",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_state(self):\n        if self.state.country_id:\n            self.country = self.state.country_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_name_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Bank"
    },
    {
      "name": "res.partner.bank",
      "description": "Bank Accounts",
      "fields": [
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "acc_type",
          "type": "Selection"
        },
        {
          "name": "acc_number",
          "type": "Char",
          "required": true
        },
        {
          "name": "sanitized_acc_number",
          "type": "Char",
          "readonly": true,
          "string": "Sanitized Account Number"
        },
        {
          "name": "acc_holder_name",
          "type": "Char",
          "string": "Account Holder Name",
          "help": "Account holder name, in case it is different than the name of the Account Holder"
        },
        {
          "name": "partner_id",
          "type": "Many2one",
          "relation": "res.partner"
        },
        {
          "name": "allow_out_payment",
          "type": "Boolean",
          "help": "This account can be used for outgoing payments"
        },
        {
          "name": "bank_id",
          "type": "Many2one",
          "relation": "res.bank",
          "string": "Bank"
        },
        {
          "name": "bank_name",
          "type": "Char"
        },
        {
          "name": "bank_bic",
          "type": "Char"
        },
        {
          "name": "sequence",
          "type": "Integer"
        },
        {
          "name": "currency_id",
          "type": "Many2one",
          "relation": "res.currency",
          "string": "Currency"
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company",
          "readonly": true
        }
      ],
      "methods": [
        {
          "name": "get_supported_account_types",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_supported_account_types(self):\n        return self._get_supported_account_types()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_supported_account_types",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_supported_account_types(self):\n        return [('bank', _('Normal'))]\n\n    active = fields.Boolean(default=True)\n    acc_type = fields.Selection(selection=lambda x: x.env['res.partner.bank'].get_supported_account_types(), compute='_compute_acc_type', string='Type', help='Bank account type: Normal or IBAN. Inferred from the bank account number.')\n    acc_number = fields.Char('Account Number', required=True)\n    sanitized_acc_number = fields.Char(compute='_compute_sanitized_acc_number', string='Sanitized Account Number', readonly=True, store=True)\n    acc_holder_name = fields.Char(string='Account Holder Name', help=\"Account holder name, in case it is different than the name of the Account Holder\", compute='_compute_account_holder_name', readonly=False, store=True)\n    partner_id = fields.Many2one('res.partner', 'Account Holder', ondelete='cascade', index=True, domain=['|', ('is_company', '=', True), ('parent_id', '=', False)], required=True)\n    allow_out_payment = fields.Boolean('Send Money', help='This account can be used for outgoing payments', default=False, copy=False, readonly=False)\n    bank_id = fields.Many2one('res.bank', string='Bank')\n    bank_name = fields.Char(related='bank_id.name', readonly=False)\n    bank_bic = fields.Char(related='bank_id.bic', readonly=False)\n    sequence = fields.Integer(default=10)\n    currency_id = fields.Many2one('res.currency', string='Currency')\n    company_id = fields.Many2one('res.company', 'Company', related='partner_id.company_id', store=True, readonly=True)\n\n    _sql_constraints = [(\n        'unique_number',\n        'unique(sanitized_acc_number, partner_id)',\n        'The combination Account Number/Partner must be unique.'\n    )]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_sanitized_acc_number",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_sanitized_acc_number(self):\n        for bank in self:\n            bank.sanitized_acc_number = sanitize_account_number(bank.acc_number)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_acc_type",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_acc_type(self):\n        for bank in self:\n            bank.acc_type = self.retrieve_acc_type(bank.acc_number)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_account_holder_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_account_holder_name(self):\n        for bank in self:\n            bank.acc_holder_name = bank.partner_id.name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "retrieve_acc_type",
          "params": [
            "self",
            "acc_number"
          ],
          "decorators": [],
          "source": "def retrieve_acc_type(self, acc_number):\n        \"\"\" To be overridden by subclasses in order to support other account_types.\n        \"\"\"\n        return 'bank'",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        for acc in self:\n            acc.display_name = f'{acc.acc_number} - {acc.bank_id.name}' if acc.bank_id else acc.acc_number",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search",
          "params": [
            "self",
            "domain",
            "offset=0",
            "limit=None",
            "order=None",
            "access_rights_uid=None"
          ],
          "decorators": [],
          "source": "def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "sanitize",
          "params": [
            "arg"
          ],
          "decorators": [],
          "source": "def sanitize(arg):\n            if isinstance(arg, (tuple, list)) and arg[0] == 'acc_number':\n                value = arg[2]\n                if not isinstance(value, str) and isinstance(value, Iterable):\n                    value = [sanitize_account_number(i) for i in value]\n                else:\n                    value = sanitize_account_number(value)\n                return ('sanitized_acc_number', arg[1], value)\n            return arg\n\n        domain = [sanitize(item) for item in domain]\n        return super()._search(domain, offset, limit, order, access_rights_uid)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "unique_number",
          "definition": "unique(sanitized_acc_number, partner_id)",
          "message": "The combination Account Number/Partner must be unique."
        }
      ],
      "accessRules": [
        {
          "name": "get_supported_account_types (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_supported_account_types (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "retrieve_acc_type (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ResPartnerBank"
    },
    {
      "name": "res.company",
      "description": "Companies",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Company Name"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "sequence",
          "type": "Integer",
          "help": "Used to order Companies in the company switcher"
        },
        {
          "name": "parent_id",
          "type": "Many2one",
          "relation": "res.company",
          "string": "Parent Company"
        },
        {
          "name": "child_ids",
          "type": "One2many",
          "relation": "res.company",
          "string": "Branches"
        },
        {
          "name": "all_child_ids",
          "type": "One2many",
          "relation": "res.company"
        },
        {
          "name": "parent_path",
          "type": "Char"
        },
        {
          "name": "parent_ids",
          "type": "Many2many",
          "relation": "res.company"
        },
        {
          "name": "root_id",
          "type": "Many2one",
          "relation": "res.company"
        },
        {
          "name": "partner_id",
          "type": "Many2one",
          "relation": "res.partner",
          "required": true,
          "string": "Partner"
        },
        {
          "name": "report_header",
          "type": "Html",
          "string": "Company Tagline",
          "help": "Company tagline, which is included in a printed document"
        },
        {
          "name": "report_footer",
          "type": "Html",
          "string": "Report Footer",
          "help": "Footer text displayed at the bottom of all reports."
        },
        {
          "name": "company_details",
          "type": "Html",
          "string": "Company Details",
          "help": "Header text displayed at the top of all reports."
        },
        {
          "name": "is_company_details_empty",
          "type": "Boolean"
        },
        {
          "name": "logo",
          "type": "Binary",
          "string": "Company Logo"
        },
        {
          "name": "logo_web",
          "type": "Binary"
        },
        {
          "name": "uses_default_logo",
          "type": "Boolean"
        },
        {
          "name": "currency_id",
          "type": "Many2one",
          "relation": "res.currency",
          "required": true,
          "string": "Currency"
        },
        {
          "name": "user_ids",
          "type": "Many2many",
          "relation": "res.users",
          "string": "Accepted Users"
        },
        {
          "name": "street",
          "type": "Char"
        },
        {
          "name": "street2",
          "type": "Char"
        },
        {
          "name": "zip",
          "type": "Char"
        },
        {
          "name": "city",
          "type": "Char"
        },
        {
          "name": "state_id",
          "type": "Many2one",
          "relation": "res.country.state",
          "string": "Fed. State"
        },
        {
          "name": "bank_ids",
          "type": "One2many"
        },
        {
          "name": "country_id",
          "type": "Many2one",
          "relation": "res.country",
          "string": "Country"
        },
        {
          "name": "email",
          "type": "Char"
        },
        {
          "name": "phone",
          "type": "Char"
        },
        {
          "name": "mobile",
          "type": "Char"
        },
        {
          "name": "website",
          "type": "Char"
        },
        {
          "name": "vat",
          "type": "Char",
          "string": "Tax ID"
        },
        {
          "name": "company_registry",
          "type": "Char",
          "string": "Company ID"
        },
        {
          "name": "paperformat_id",
          "type": "Many2one",
          "relation": "report.paperformat"
        },
        {
          "name": "external_report_layout_id",
          "type": "Many2one",
          "relation": "ir.ui.view"
        },
        {
          "name": "font",
          "type": "Selection"
        },
        {
          "name": "primary_color",
          "type": "Char"
        },
        {
          "name": "secondary_color",
          "type": "Char"
        },
        {
          "name": "color",
          "type": "Integer"
        },
        {
          "name": "layout_background",
          "type": "Selection"
        },
        {
          "name": "layout_background_image",
          "type": "Binary"
        }
      ],
      "methods": [
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        raise UserError(_('Duplicating a company is not allowed. Please create a new company instead.'))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_logo",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_logo(self):\n        with file_open('base/static/img/res_company_logo.png', 'rb') as file:\n            return base64.b64encode(file.read())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_default_currency_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _default_currency_id(self):\n        return self.env.user.company_id.currency_id\n\n    name = fields.Char(related='partner_id.name', string='Company Name', required=True, store=True, readonly=False)\n    active = fields.Boolean(default=True)\n    sequence = fields.Integer(help='Used to order Companies in the company switcher', default=10)\n    parent_id = fields.Many2one('res.company', string='Parent Company', index=True)\n    child_ids = fields.One2many('res.company', 'parent_id', string='Branches')\n    all_child_ids = fields.One2many('res.company', 'parent_id', context={'active_test': False})\n    parent_path = fields.Char(index=True, unaccent=False)\n    parent_ids = fields.Many2many('res.company', compute='_compute_parent_ids', compute_sudo=True)\n    root_id = fields.Many2one('res.company', compute='_compute_parent_ids', compute_sudo=True)\n    partner_id = fields.Many2one('res.partner', string='Partner', required=True)\n    report_header = fields.Html(string='Company Tagline', translate=True, help=\"Company tagline, which is included in a printed document's header or footer (depending on the selected layout).\")\n    report_footer = fields.Html(string='Report Footer', translate=True, help=\"Footer text displayed at the bottom of all reports.\")\n    company_details = fields.Html(string='Company Details', translate=True, help=\"Header text displayed at the top of all reports.\")\n    is_company_details_empty = fields.Boolean(compute='_compute_empty_company_details')\n    logo = fields.Binary(related='partner_id.image_1920', default=_get_logo, string=\"Company Logo\", readonly=False)\n    # logo_web: do not store in attachments, since the image is retrieved in SQL for\n    # performance reasons (see addons/web/controllers/main.py, Binary.company_logo)\n    logo_web = fields.Binary(compute='_compute_logo_web', store=True, attachment=False)\n    uses_default_logo = fields.Boolean(compute='_compute_uses_default_logo', store=True)\n    currency_id = fields.Many2one('res.currency', string='Currency', required=True, default=lambda self: self._default_currency_id())\n    user_ids = fields.Many2many('res.users', 'res_company_users_rel', 'cid', 'user_id', string='Accepted Users')\n    street = fields.Char(compute='_compute_address', inverse='_inverse_street')\n    street2 = fields.Char(compute='_compute_address', inverse='_inverse_street2')\n    zip = fields.Char(compute='_compute_address', inverse='_inverse_zip')\n    city = fields.Char(compute='_compute_address', inverse='_inverse_city')\n    state_id = fields.Many2one(\n        'res.country.state', compute='_compute_address', inverse='_inverse_state',\n        string=\"Fed. State\", domain=\"[('country_id', '=?', country_id)]\"\n    )\n    bank_ids = fields.One2many(related='partner_id.bank_ids', readonly=False)\n    country_id = fields.Many2one('res.country', compute='_compute_address', inverse='_inverse_country', string=\"Country\")\n    email = fields.Char(related='partner_id.email', store=True, readonly=False)\n    phone = fields.Char(related='partner_id.phone', store=True, readonly=False)\n    mobile = fields.Char(related='partner_id.mobile', store=True, readonly=False)\n    website = fields.Char(related='partner_id.website', readonly=False)\n    vat = fields.Char(related='partner_id.vat', string=\"Tax ID\", readonly=False)\n    company_registry = fields.Char(related='partner_id.company_registry', string=\"Company ID\", readonly=False)\n    paperformat_id = fields.Many2one('report.paperformat', 'Paper format', default=lambda self: self.env.ref('base.paperformat_euro', raise_if_not_found=False))\n    external_report_layout_id = fields.Many2one('ir.ui.view', 'Document Template')\n    font = fields.Selection([(\"Lato\", \"Lato\"), (\"Roboto\", \"Roboto\"), (\"Open_Sans\", \"Open Sans\"), (\"Montserrat\", \"Montserrat\"), (\"Oswald\", \"Oswald\"), (\"Raleway\", \"Raleway\"), ('Tajawal', 'Tajawal')], default=\"Lato\")\n    primary_color = fields.Char()\n    secondary_color = fields.Char()\n    color = fields.Integer(compute='_compute_color', inverse='_inverse_color')\n    layout_background = fields.Selection([('Blank', 'Blank'), ('Geometric', 'Geometric'), ('Custom', 'Custom')], default=\"Blank\", required=True)\n    layout_background_image = fields.Binary(\"Background Image\")\n    _sql_constraints = [\n        ('name_uniq', 'unique (name)', 'The company name must be unique!')\n    ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def init(self):\n        for company in self.search([('paperformat_id', '=', False)]):\n            paperformat_euro = self.env.ref('base.paperformat_euro', False)\n            if paperformat_euro:\n                company.write({'paperformat_id': paperformat_euro.id})\n        sup = super(Company, self)\n        if hasattr(sup, 'init'):\n            sup.init()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_company_root_delegated_field_names",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_company_root_delegated_field_names(self):\n        \"\"\"Get the set of fields delegated to the root company.\n\n        Some fields need to be identical on all branches of the company. All\n        fields listed by this function will be copied from the root company and\n        appear as readonly in the form view.\n        :rtype: set\n        \"\"\"\n        return ['currency_id']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_company_address_field_names",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_company_address_field_names(self):\n        \"\"\" Return a list of fields coming from the address partner to match\n        on company address fields. Fields are labeled same on both models. \"\"\"\n        return ['street', 'street2', 'city', 'zip', 'state_id', 'country_id']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_company_address_update",
          "params": [
            "self",
            "partner"
          ],
          "decorators": [],
          "source": "def _get_company_address_update(self, partner):\n        return dict((fname, partner[fname])\n                    for fname in self._get_company_address_field_names())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_parent_ids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_parent_ids(self):\n        for company in self.with_context(active_test=False):\n            company.parent_ids = self.browse(int(id) for id in company.parent_path.split('/') if id) if company.parent_path else company\n            company.root_id = company.parent_ids[0]\n\n    # TODO @api.depends(): currently now way to formulate the dependency on the\n    # partner's contact address",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_address",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_address(self):\n        for company in self.filtered(lambda company: company.partner_id):\n            address_data = company.partner_id.sudo().address_get(adr_pref=['contact'])\n            if address_data['contact']:\n                partner = company.partner_id.browse(address_data['contact']).sudo()\n                company.update(company._get_company_address_update(partner))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_street",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_street(self):\n        for company in self:\n            company.partner_id.street = company.street",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_street2",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_street2(self):\n        for company in self:\n            company.partner_id.street2 = company.street2",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_zip",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_zip(self):\n        for company in self:\n            company.partner_id.zip = company.zip",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_city",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_city(self):\n        for company in self:\n            company.partner_id.city = company.city",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_state",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_state(self):\n        for company in self:\n            company.partner_id.state_id = company.state_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_country",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_country(self):\n        for company in self:\n            company.partner_id.country_id = company.country_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_logo_web",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_logo_web(self):\n        for company in self:\n            img = company.partner_id.image_1920\n            company.logo_web = img and base64.b64encode(tools.image_process(base64.b64decode(img), size=(180, 0)))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_uses_default_logo",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_uses_default_logo(self):\n        default_logo = self._get_logo()\n        for company in self:\n            company.uses_default_logo = not company.logo or company.logo == default_logo",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_color",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_color(self):\n        for company in self:\n            company.color = company.root_id.partner_id.color or (company.root_id._origin.id % 12)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_color",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_color(self):\n        for company in self:\n            company.root_id.partner_id.color = company.color",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_state",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_state(self):\n        if self.state_id.country_id:\n            self.country_id = self.state_id.country_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_country_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_country_id(self):\n        if self.country_id:\n            self.currency_id = self.country_id.currency_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_parent_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_parent_id(self):\n        if self.parent_id:\n            for fname in self._get_company_root_delegated_field_names():\n                if self[fname] != self.parent_id[fname]:\n                    self[fname] = self.parent_id[fname]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view(self, view_id=None, view_type='form', **options):",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "make_delegated_fields_readonly",
          "params": [
            "node"
          ],
          "decorators": [],
          "source": "def make_delegated_fields_readonly(node):\n            for child in node.iterchildren():\n                if child.tag == 'field' and child.get('name') in delegated_fnames:\n                    child.set('readonly', \"parent_id != False\")\n                else:\n                    make_delegated_fields_readonly(child)\n            return node\n\n        delegated_fnames = set(self._get_company_root_delegated_field_names())\n        arch, view = super()._get_view(view_id, view_type, **options)\n        arch = make_delegated_fields_readonly(arch)\n        return arch, view",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_name_search",
          "params": [
            "self",
            "name",
            "domain=None",
            "operator='ilike'",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n        context = dict(self.env.context)\n        newself = self\n        if context.pop('user_preference', None):\n            # We browse as superuser. Otherwise, the user would be able to\n            # select only the currently visible companies (according to rules,\n            # which are probably to allow to see the child companies) even if\n            # she belongs to some other companies.\n            companies = self.env.user.company_ids\n            domain = (domain or []) + [('id', 'in', companies.ids)]\n            newself = newself.sudo()\n        self = newself.with_context(context)\n        return super()._name_search(name, domain, operator, limit, order)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_company_default_get",
          "params": [
            "self",
            "object=False",
            "field=False"
          ],
          "decorators": [],
          "source": "def _company_default_get(self, object=False, field=False):\n        \"\"\" Returns the user's company\n            - Deprecated\n        \"\"\"\n        _logger.warning(\"The method '_company_default_get' on res.company is deprecated and shouldn't be used anymore\")\n        return self.env.company",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_empty_company_details",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_empty_company_details(self):\n        # In recent change when an html field is empty a <p> balise remains with a <br> in it,\n        # but when company details is empty we want to put the info of the company\n        for record in self:\n            record.is_company_details_empty = not html2plaintext(record.company_details or '')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n\n        # create missing partners\n        no_partner_vals_list = [\n            vals\n            for vals in vals_list\n            if vals.get('name') and not vals.get('partner_id')\n        ]\n        if no_partner_vals_list:\n            partners = self.env['res.partner'].with_context(default_parent_id=False).create([\n                {\n                    'name': vals['name'],\n                    'is_company': True,\n                    'image_1920': vals.get('logo'),\n                    'email': vals.get('email'),\n                    'phone': vals.get('phone'),\n                    'website': vals.get('website'),\n                    'vat': vals.get('vat'),\n                    'country_id': vals.get('country_id'),\n                }\n                for vals in no_partner_vals_list\n            ])\n            # compute stored fields, for example address dependent fields\n            partners.flush_model()\n            for vals, partner in zip(no_partner_vals_list, partners):\n                vals['partner_id'] = partner.id\n\n        for vals in vals_list:\n            # Copy delegated fields from root to branches\n            if parent := self.browse(vals.get('parent_id')):\n                for fname in self._get_company_root_delegated_field_names():\n                    vals.setdefault(fname, self._fields[fname].convert_to_write(parent[fname], parent))\n\n        self.env.registry.clear_cache()\n        companies = super().create(vals_list)\n\n        # The write is made on the user to set it automatically in the multi company group.\n        if companies:\n            (self.env.user | self.env['res.users'].browse(SUPERUSER_ID)).write({\n                'company_ids': [Command.link(company.id) for company in companies],\n            })\n\n        # Make sure that the selected currencies are enabled\n        companies.currency_id.sudo().filtered(lambda c: not c.active).active = True\n\n        return companies",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "cache_invalidation_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def cache_invalidation_fields(self):\n        # This list is not well defined and tests should be improved\n        return {\n            'active', # user._get_company_ids and other potential cached search\n            'sequence', # user._get_company_ids and other potential cached search\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_if_company_has_no_children",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_if_company_has_no_children(self):\n        if any(company.child_ids for company in self):\n            raise UserError(_(\"Companies that have associated branches cannot be deleted. Consider archiving them instead.\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        invalidation_fields = self.cache_invalidation_fields()\n        asset_invalidation_fields = {'font', 'primary_color', 'secondary_color', 'external_report_layout_id'}\n        if not invalidation_fields.isdisjoint(values):\n            self.env.registry.clear_cache()\n\n        if not asset_invalidation_fields.isdisjoint(values):\n            # this is used in the content of an asset (see asset_styles_company_report)\n            # and thus needs to invalidate the assets cache when this is changed\n            self.env.registry.clear_cache('assets')  # not 100% it is useful a test is missing if it is the case\n\n        if 'parent_id' in values:\n            raise UserError(_(\"The company hierarchy cannot be changed.\"))\n\n        if values.get('currency_id'):\n            currency = self.env['res.currency'].browse(values['currency_id'])\n            if not currency.active:\n                currency.write({'active': True})\n\n        res = super(Company, self).write(values)\n\n        # Archiving a company should also archive all of its branches\n        if values.get('active') is False:\n            self.child_ids.active = False\n\n        for company in self:\n            # Copy modified delegated fields from root to branches\n            if (changed := set(values) & set(self._get_company_root_delegated_field_names())) and not company.parent_id:\n                branches = self.sudo().search([\n                    ('id', 'child_of', company.id),\n                    ('id', '!=', company.id),\n                ])\n                for fname in sorted(changed):\n                    branches[fname] = company[fname]\n\n        # invalidate company cache to recompute address based on updated partner\n        company_address_fields = self._get_company_address_field_names()\n        company_address_fields_upd = set(company_address_fields) & set(values.keys())\n        if company_address_fields_upd:\n            self.invalidate_model(company_address_fields)\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_active",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_active(self):\n        for company in self:\n            if not company.active:\n                company_active_users = self.env['res.users'].search_count([\n                    ('company_id', '=', company.id),\n                    ('active', '=', True),\n                ])\n                if company_active_users:\n                    # You cannot disable companies with active users\n                    raise ValidationError(_(\n                        'The company %(company_name)s cannot be archived because it is still used '\n                        'as the default company of %(active_users)s users.',\n                        company_name=company.name,\n                        active_users=company_active_users,\n                    ))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_root_delegated_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_root_delegated_fields(self):\n        for company in self:\n            if company.parent_id:\n                for fname in company._get_company_root_delegated_field_names():\n                    if company[fname] != company.parent_id[fname]:\n                        description = self.env['ir.model.fields']._get(\"res.company\", fname).field_description\n                        raise ValidationError(_(\"The %s of a subsidiary must be the same as it's root company.\", description))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "open_company_edit_report",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def open_company_edit_report(self):\n        warnings.warn(\"Since 17.0.\", DeprecationWarning, 2)\n        self.ensure_one()\n        return self.env['res.config.settings'].open_company()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write_company_and_print_report",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def write_company_and_print_report(self):\n        warnings.warn(\"Since 17.0.\", DeprecationWarning, 2)\n        context = self.env.context\n        report_name = context.get('default_report_name')\n        active_ids = context.get('active_ids')\n        active_model = context.get('active_model')\n        if report_name and active_ids and active_model:\n            docids = self.env[active_model].browse(active_ids)\n            return (self.env['ir.actions.report'].search([('report_name', '=', report_name)], limit=1)\n                        .report_action(docids))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_main_company",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_main_company(self):\n        try:\n            main_company = self.sudo().env.ref('base.main_company')\n        except ValueError:\n            main_company = self.env['res.company'].sudo().search([], limit=1, order=\"id\")\n\n        return main_company",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "__accessible_branches",
          "params": [
            "self"
          ],
          "decorators": [
            "@ormcache('tuple(self.env.companies.ids)"
          ],
          "source": "@ormcache('tuple(self.env.companies.ids)', 'self.id', 'self.env.uid')\n    def __accessible_branches(self):\n        # Get branches of this company that the current user can use\n        self.ensure_one()\n\n        accessible_branch_ids = []\n        accessible = self.env.companies\n        current = self.sudo()\n        while current:\n            accessible_branch_ids.extend((current & accessible).ids)\n            current = current.child_ids\n\n        if not accessible_branch_ids and self.env.uid == SUPERUSER_ID:\n            # Accessible companies will always be the same for super user when called in a cron.\n            # Because of that, the intersection between them and self might be empty. The super user anyway always has\n            # access to all companies (as it bypasses the record rules), so we return the current company in this case.\n            return self.ids\n\n        return accessible_branch_ids",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "_accessible_branches",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _accessible_branches(self):\n        return self.browse(self.__accessible_branches())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_all_branches_selected",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _all_branches_selected(self):\n        \"\"\"Return whether or all the branches of the companies in self are selected.\n\n        Is ``True`` if all the branches, and only those, are selected.\n        Can be used when some actions only make sense for whole companies regardless of the\n        branches.\n        \"\"\"\n        return self == self.sudo().search([('id', 'child_of', self.root_id.ids)])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_all_company_branches",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_all_company_branches(self):\n        self.ensure_one()\n        return {\n            'type': 'ir.actions.act_window',\n            'name': _('Branches'),\n            'res_model': 'res.company',\n            'domain': [('parent_id', '=', self.id)],\n            'context': {\n                'active_test': False,\n                'default_parent_id': self.id,\n            },\n            'views': [[False, 'tree'], [False, 'kanban'], [False, 'form']],\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_uniq",
          "definition": "unique (name)",
          "message": "The company name must be unique!"
        },
        {
          "type": "python",
          "name": "_check_active",
          "definition": "@api.constrains('active')\n    def _check_active(self):\n        for company in self:\n            if not company.active:\n                company_active_users = self.env['res.users'].search_count([\n                    ('company_id', '=', company.id),\n                    ('active', '=', True),\n                ])\n                if company_active_users:\n                    # You cannot disable companies with active users\n                    raise ValidationError(_(\n                        'The company %(company_name)s cannot be archived because it is still used '\n                        'as the default company of %(active_users)s users.',\n                        company_name=company.name,\n                        active_users=company_active_users,\n                    ))",
          "message": "'active'"
        }
      ],
      "accessRules": [
        {
          "name": "_get_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_name_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_main_company (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Company"
    },
    {
      "name": "res.config",
      "description": "Config",
      "fields": [],
      "methods": [
        {
          "name": "start",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def start(self):\n        # pylint: disable=next-method-called\n        return self.next()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "next",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def next(self):\n        \"\"\"\n        Reload the settings page\n        \"\"\"\n        return {\n            'type': 'ir.actions.client',\n            'tag': 'reload',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "execute",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def execute(self):\n        \"\"\" Method called when the user clicks on the ``Next`` button.\n\n        Execute *must* be overloaded unless ``action_next`` is overloaded\n        (which is something you generally don't need to do).\n\n        If ``execute`` returns an action dictionary, that action is executed\n        rather than just going to the next configuration item.\n        \"\"\"\n        raise NotImplementedError(\n            'Configuration items need to implement execute')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "cancel",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def cancel(self):\n        \"\"\" Method called when the user click on the ``Skip`` button.\n\n        ``cancel`` should be overloaded instead of ``action_skip``. As with\n        ``execute``, if it returns an action dictionary that action is\n        executed in stead of the default (going to the next configuration item)\n\n        The default implementation is a NOOP.\n\n        ``cancel`` is also called by the default implementation of\n        ``action_cancel``.\n        \"\"\"\n        pass",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_next",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_next(self):\n        \"\"\" Action handler for the ``next`` event.\n\n        Sets the status of the todo the event was sent from to\n        ``done``, calls ``execute`` and -- unless ``execute`` returned\n        an action dictionary -- executes the action provided by calling\n        ``next``.\n        \"\"\"\n        # pylint: disable=next-method-called\n        return self.execute() or self.next()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_skip",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_skip(self):\n        \"\"\" Action handler for the ``skip`` event.\n\n        Sets the status of the todo the event was sent from to\n        ``skip``, calls ``cancel`` and -- unless ``cancel`` returned\n        an action dictionary -- executes the action provided by calling\n        ``next``.\n        \"\"\"\n        # pylint: disable=next-method-called\n        return self.cancel() or self.next()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_cancel",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_cancel(self):\n        \"\"\" Action handler for the ``cancel`` event. That event isn't\n        generated by the res.config.view.base inheritable view, the\n        inherited view has to overload one of the buttons (or add one\n        more).\n\n        Sets the status of the todo the event was sent from to\n        ``cancel``, calls ``cancel`` and -- unless ``cancel`` returned\n        an action dictionary -- executes the action provided by calling\n        ``next``.\n        \"\"\"\n        # pylint: disable=next-method-called\n        return self.cancel() or self.next()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "ResConfigConfigurable"
    },
    {
      "name": "res.config.installer",
      "description": "Config Installer",
      "fields": [],
      "methods": [
        {
          "name": "already_installed",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def already_installed(self):\n        \"\"\" For each module, check if it's already installed and if it\n        is return its name\n\n        :returns: a list of the already installed modules in this\n                  installer\n        :rtype: [str]\n        \"\"\"\n        return [m.name for m in self._already_installed()]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_already_installed",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _already_installed(self):\n        \"\"\" For each module (boolean fields in a res.config.installer),\n        check if it's already installed (either 'to install', 'to upgrade'\n        or 'installed') and if it is return the module's record\n\n        :returns: a list of all installed modules in this installer\n        :rtype: recordset (collection of Record)\n        \"\"\"\n        selectable = [name for name, field in self._fields.items()\n                      if field.type == 'boolean']\n        return self.env['ir.module.module'].search([('name', 'in', selectable),\n                            ('state', 'in', ['to install', 'installed', 'to upgrade'])])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "modules_to_install",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def modules_to_install(self):\n        \"\"\" selects all modules to install:\n\n        * checked boolean fields\n        * return values of hook methods. Hook methods are of the form\n          ``_if_%(addon_name)s``, and are called if the corresponding\n          addon is marked for installation. They take the arguments\n          cr, uid, ids and context, and return an iterable of addon\n          names\n        * additionals, additionals are setup through the ``_install_if``",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "default_get",
          "params": [
            "self",
            "fields_list"
          ],
          "decorators": [],
          "source": "def default_get(self, fields_list):\n        ''' If an addon is already installed, check it by default\n        '''\n        defaults = super(ResConfigInstaller, self).default_get(fields_list)\n        return dict(defaults, **dict.fromkeys(self.already_installed(), True))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "fields_get",
          "params": [
            "self",
            "allfields=None",
            "attributes=None"
          ],
          "decorators": [],
          "source": "def fields_get(self, allfields=None, attributes=None):\n        \"\"\" If an addon is already installed, set it to readonly as\n        res.config.installer doesn't handle uninstallations of already\n        installed addons\n        \"\"\"\n        fields = super().fields_get(allfields=allfields, attributes=attributes)\n\n        for name in self.already_installed():\n            if name not in fields:\n                continue\n            fields[name].update(\n                readonly=True,\n                help= ustr(fields[name].get('help', '')) +\n                     _('\\n\\nThis addon is already installed on your system'))\n        return fields",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "execute",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def execute(self):\n        to_install = list(self.modules_to_install())\n        _logger.info('Selecting addons %s to install', to_install)\n\n        IrModule = self.env['ir.module.module']\n        modules = IrModule.search([('name', 'in', to_install)])\n        return self._install_modules(modules)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "res.config"
        },
        {
          "type": "extends",
          "parent": "models.TransientModel"
        },
        {
          "type": "extends",
          "parent": "ResConfigModuleInstallationMixin"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "default_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "fields_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ResConfigInstaller"
    },
    {
      "name": "resconfigsettings",
      "description": "",
      "fields": [],
      "methods": [],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        },
        {
          "type": "extends",
          "parent": "ResConfigModuleInstallationMixin"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "ResConfigSettings"
    },
    {
      "name": "my.settings",
      "description": "Config Settings",
      "fields": [
        {
          "name": "default_foo",
          "type": "type"
        },
        {
          "name": "group_bar",
          "type": "Boolean"
        },
        {
          "name": "module_baz",
          "type": "Boolean"
        },
        {
          "name": "config_qux",
          "type": "Char"
        },
        {
          "name": "other_field",
          "type": "type"
        },
        {
          "name": "qr_code",
          "type": "Boolean"
        }
      ],
      "methods": [
        {
          "name": "_valid_field_parameter",
          "params": [
            "self",
            "field",
            "name"
          ],
          "decorators": [],
          "source": "def _valid_field_parameter(self, field, name):\n        return (\n            name in ('default_model', 'config_parameter')\n            or field.type in ('boolean', 'selection') and name in ('group', 'implied_group')\n            or super()._valid_field_parameter(field, name)\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        raise UserError(_(\"Cannot duplicate configuration!\"))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "onchange_module",
          "params": [
            "self",
            "field_value",
            "module_name"
          ],
          "decorators": [],
          "source": "def onchange_module(self, field_value, module_name):\n        module_sudo = self.env['ir.module.module']._get(module_name[7:])\n        if not int(field_value) and module_sudo.state in ('to install', 'installed', 'to upgrade'):\n            deps = module_sudo.downstream_dependencies()\n            dep_names = (deps | module_sudo).mapped('shortdesc')\n            message = '\\n'.join(dep_names)\n            return {\n                'warning': {\n                    'title': _('Warning!'),\n                    'message': _('Disabling this option will also uninstall the following modules \\n%s', message),\n                }\n            }\n        return {}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_register_hook",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _register_hook(self):\n        \"\"\" Add an onchange method for each module field. \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "make_method",
          "params": [
            "name"
          ],
          "decorators": [],
          "source": "def make_method(name):\n            return lambda self: self.onchange_module(self[name], name)\n\n        for name in self._fields:\n            if name.startswith('module_'):\n                method = make_method(name)\n                self._onchange_methods[name].append(method)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_classified_fields",
          "params": [
            "self",
            "fnames=None"
          ],
          "decorators": [],
          "source": "def _get_classified_fields(self, fnames=None):\n        \"\"\" return a dictionary with the fields classified by category::\n\n                {   'default': [('default_foo', 'model', 'foo'), ...],\n                    'group':   [('group_bar', [browse_group], browse_implied_group), ...],\n                    'module':  [('module_baz', browse_module), ...],\n                    'config':  [('config_qux', 'my.parameter'), ...],\n                    'other':   ['other_field', ...],\n                }\n        \"\"\"\n        IrModule = self.env['ir.module.module']\n        IrModelData = self.env['ir.model.data']\n        Groups = self.env['res.groups']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "ref",
          "params": [
            "xml_id"
          ],
          "decorators": [],
          "source": "def ref(xml_id):\n            res_model, res_id = IrModelData._xmlid_to_res_model_res_id(xml_id)\n            return self.env[res_model].browse(res_id)\n\n        if fnames is None:\n            fnames = self._fields.keys()\n\n        defaults, groups, configs, others = [], [], [], []\n        modules = IrModule\n        for name in fnames:\n            field = self._fields[name]\n            if name.startswith('default_'):\n                if not hasattr(field, 'default_model'):\n                    raise Exception(\"Field %s without attribute 'default_model'\" % field)\n                defaults.append((name, field.default_model, name[8:]))\n            elif name.startswith('group_'):\n                if field.type not in ('boolean', 'selection'):\n                    raise Exception(\"Field %s must have type 'boolean' or 'selection'\" % field)\n                if not hasattr(field, 'implied_group'):\n                    raise Exception(\"Field %s without attribute 'implied_group'\" % field)\n                field_group_xmlids = getattr(field, 'group', 'base.group_user').split(',')\n                field_groups = Groups.concat(*(ref(it) for it in field_group_xmlids))\n                groups.append((name, field_groups, ref(field.implied_group)))\n            elif name.startswith('module_'):\n                if field.type not in ('boolean', 'selection'):\n                    raise Exception(\"Field %s must have type 'boolean' or 'selection'\" % field)\n                modules += IrModule._get(name[7:])\n            elif hasattr(field, 'config_parameter') and field.config_parameter:\n                if field.type not in ('boolean', 'integer', 'float', 'char', 'selection', 'many2one', 'datetime'):\n                    raise Exception(\"Field %s must have type 'boolean', 'integer', 'float', 'char', 'selection', 'many2one' or 'datetime'\" % field)\n                configs.append((name, field.config_parameter))\n            else:\n                others.append(name)\n\n        return {'default': defaults, 'group': groups, 'module': modules, 'config': configs, 'other': others}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_values",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_values(self):\n        \"\"\"\n        Return values for the fields other that `default`, `group` and `module`\n        \"\"\"\n        return {}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "default_get",
          "params": [
            "self",
            "fields"
          ],
          "decorators": [],
          "source": "def default_get(self, fields):\n        res = super().default_get(fields)\n        if not fields:\n            return res\n\n        IrDefault = self.env['ir.default']\n        IrConfigParameter = self.env['ir.config_parameter'].sudo()\n        classified = self._get_classified_fields(fields)\n\n        # defaults: take the corresponding default value they set\n        for name, model, field in classified['default']:\n            value = IrDefault._get(model, field)\n            if value is not None:\n                res[name] = value\n\n        # groups: which groups are implied by the group Employee\n        for name, groups, implied_group in classified['group']:\n            res[name] = all(implied_group in group.implied_ids for group in groups)\n            if self._fields[name].type == 'selection':\n                res[name] = str(int(res[name]))     # True, False -> '1', '0'\n\n        # modules: which modules are installed/to install\n        for module in classified['module']:\n            res[f'module_{module.name}'] = module.state in ('installed', 'to install', 'to upgrade')\n\n        # config: get & convert stored ir.config_parameter (or default)\n        WARNING_MESSAGE = \"Error when converting value %r of field %s for ir.config.parameter %r\"\n        for name, icp in classified['config']:\n            field = self._fields[name]\n            value = IrConfigParameter.get_param(icp, field.default(self) if field.default else False)\n            if value is not False:\n                if field.type == 'many2one':\n                    try:\n                        # Special case when value is the id of a deleted record, we do not want to\n                        # block the settings screen\n                        value = self.env[field.comodel_name].browse(int(value)).exists().id\n                    except (ValueError, TypeError):\n                        _logger.warning(WARNING_MESSAGE, value, field, icp)\n                        value = False\n                elif field.type == 'integer':\n                    try:\n                        value = int(value)\n                    except (ValueError, TypeError):\n                        _logger.warning(WARNING_MESSAGE, value, field, icp)\n                        value = 0\n                elif field.type == 'float':\n                    try:\n                        value = float(value)\n                    except (ValueError, TypeError):\n                        _logger.warning(WARNING_MESSAGE, value, field, icp)\n                        value = 0.0\n                elif field.type == 'boolean':\n                    value = bool(value)\n            res[name] = value\n\n        res.update(self.get_values())\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "set_values",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def set_values(self):\n        \"\"\"\n        Set values for the fields other that `default`, `group` and `module`\n        \"\"\"\n        self = self.with_context(active_test=False)\n        classified = self._get_classified_fields()\n        current_settings = self.default_get(list(self.fields_get()))\n\n        # default values fields\n        IrDefault = self.env['ir.default'].sudo()\n        for name, model, field in classified['default']:\n            if isinstance(self[name], models.BaseModel):\n                if self._fields[name].type == 'many2one':\n                    value = self[name].id\n                else:\n                    value = self[name].ids\n            else:\n                value = self[name]\n            if name not in current_settings or value != current_settings[name]:\n                IrDefault.set(model, field, value)\n\n        # group fields: modify group / implied groups\n        for name, groups, implied_group in sorted(classified['group'], key=lambda k: self[k[0]]):\n            groups = groups.sudo()\n            implied_group = implied_group.sudo()\n            if self[name] == current_settings[name]:\n                continue\n            if int(self[name]):\n                groups._apply_group(implied_group)\n            else:\n                groups._remove_group(implied_group)\n\n        # config fields: store ir.config_parameters\n        IrConfigParameter = self.env['ir.config_parameter'].sudo()\n        for name, icp in classified['config']:\n            field = self._fields[name]\n            value = self[name]\n            current_value = IrConfigParameter.get_param(icp)\n\n            if field.type == 'char':\n                # storing developer keys as ir.config_parameter may lead to nasty\n                # bugs when users leave spaces around them\n                value = (value or \"\").strip() or False\n            elif field.type in ('integer', 'float'):\n                value = repr(value) if value else False\n            elif field.type == 'many2one':\n                # value is a (possibly empty) recordset\n                value = value.id\n\n            if current_value == str(value) or current_value == value:\n                continue\n            IrConfigParameter.set_param(icp, value)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "execute",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def execute(self):\n        \"\"\"\n        Called when settings are saved.\n\n        This method will call `set_values` and will install/uninstall any modules defined by\n        `module_` Boolean fields and then trigger a web client reload.\n\n        .. warning::\n\n            This method **SHOULD NOT** be overridden, in most cases what you want to override is\n            `~set_values()` since `~execute()` does little more than simply call `~set_values()`.\n\n            The part that installs/uninstalls modules **MUST ALWAYS** be at the end of the\n            transaction, otherwise there's a big risk of registry <-> database desynchronisation.\n        \"\"\"\n        self.ensure_one()\n        if not self.env.is_admin():\n            raise AccessError(_(\"Only administrators can change the settings\"))\n\n        self = self.with_context(active_test=False)\n        classified = self._get_classified_fields()\n\n        self.set_values()\n\n        # module fields: install/uninstall the selected modules\n        to_install = classified['module'].filtered(\n            lambda m: self[f'module_{m.name}'] and m.state != 'installed')\n        to_uninstall = classified['module'].filtered(\n            lambda m: not self[f'module_{m.name}'] and m.state in ('installed', 'to upgrade'))\n\n        if to_install or to_uninstall:\n            self.env.flush_all()\n\n        if to_uninstall:\n            to_uninstall.button_immediate_uninstall()\n\n        installation_status = self._install_modules(to_install)\n\n        if installation_status or to_uninstall:\n            # After the uninstall/install calls, the registry and environments\n            # are no longer valid. So we reset the environment.\n            self.env.reset()\n            self = self.env()[self._name]\n\n        # pylint: disable=next-method-called\n        config = self.env['res.config'].next() or {}\n        if config.get('type') not in ('ir.actions.act_window_close',):\n            return config\n\n        # force client-side reload (update user menu and current view)\n        return {\n            'type': 'ir.actions.client',\n            'tag': 'reload',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "cancel",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def cancel(self):\n        # ignore the current record, and send the action to reopen the view\n        actions = self.env['ir.actions.act_window'].search([('res_model', '=', self._name)], limit=1)\n        if actions:\n            return actions.read()[0]\n        return {}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        \"\"\" Override display_name method to return an appropriate configuration wizard\n        name, and not the generated name.\"\"\"\n        action = self.env['ir.actions.act_window'].search([('res_model', '=', self._name)], limit=1)\n        self.display_name = action.name or self._name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_option_path",
          "params": [
            "self",
            "menu_xml_id"
          ],
          "decorators": [],
          "source": "def get_option_path(self, menu_xml_id):\n        \"\"\"\n        Fetch the path to a specified configuration view and the action id to access it.\n\n        :param string menu_xml_id: the xml id of the menuitem where the view is located,\n            structured as follows: module_name.menuitem_xml_id (e.g.: \"sales_team.menu_sale_config\")\n        :return tuple:\n            - t[0]: string: full path to the menuitem (e.g.: \"Settings/Configuration/Sales\")\n            - t[1]: int or long: id of the menuitem's action\n        \"\"\"\n        ir_ui_menu = self.env.ref(menu_xml_id)\n        return (ir_ui_menu.complete_name, ir_ui_menu.action.id)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_option_name",
          "params": [
            "self",
            "full_field_name"
          ],
          "decorators": [],
          "source": "def get_option_name(self, full_field_name):\n        \"\"\"\n        Fetch the human readable name of a specified configuration option.\n\n        :param string full_field_name: the full name of the field, structured as follows:\n            model_name.field_name (e.g.: \"sale.config.settings.fetchmail_lead\")\n        :return string: human readable name of the field (e.g.: \"Create leads from incoming mails\")\n        \"\"\"\n        model_name, field_name = full_field_name.rsplit('.', 1)\n        return self.env[model_name].fields_get([field_name])[field_name]['string']",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_config_warning",
          "params": [
            "self",
            "msg"
          ],
          "decorators": [],
          "source": "def get_config_warning(self, msg):\n        \"\"\"\n        Helper: return a Warning exception with the given message where the %(field:xxx)s\n        and/or %(menu:yyy)s are replaced by the human readable field's name and/or menuitem's\n        full path.\n\n        Usage:\n        ------\n        Just include in your error message %(field:model_name.field_name)s to obtain the human\n        readable field's name, and/or %(menu:module_name.menuitem_xml_id)s to obtain the menuitem's\n        full path.\n\n        Example of use:\n        ---------------\n        from odoo.addons.base.models.res_config import get_warning_config\n        raise get_warning_config(cr, _(\"Error: this action is prohibited. You should check the field %(field:sale.config.settings.fetchmail_lead)s in %(menu:sales_team.menu_sale_config)s.\"), context=context)\n\n        This will return an exception containing the following message:\n            Error: this action is prohibited. You should check the field Create leads from incoming mails in Settings/Configuration/Sales.\n\n        What if there is another substitution in the message already?\n        -------------------------------------------------------------\n        You could have a situation where the error message you want to upgrade already contains a substitution. Example:\n            Cannot find any account journal of %s type for this company.\\n\\nYou can create one in the menu: \\nConfiguration\\\\Journals\\\\Journals.\n        What you want to do here is simply to replace the path by %menu:account.menu_account_config)s, and leave the rest alone.\n        In order to do that, you can use the double percent (%%) to escape your new substitution, like so:\n            Cannot find any account journal of %s type for this company.\\n\\nYou can create one in the %%(menu:account.menu_account_config)s.\n        \"\"\"\n        self = self.sudo()\n\n        # Process the message\n        # 1/ find the menu and/or field references, put them in a list\n        regex_path = r'%\\(((?:menu|field):[a-z_\\.]*)\\)s'\n        references = re.findall(regex_path, msg, flags=re.I)\n\n        # 2/ fetch the menu and/or field replacement values (full path and\n        #    human readable field's name) and the action_id if any\n        values = {}\n        action_id = None\n        for item in references:\n            ref_type, ref = item.split(':')\n            if ref_type == 'menu':\n                values[item], action_id = self.get_option_path(ref)\n            elif ref_type == 'field':\n                values[item] = self.get_option_name(ref)\n\n        # 3/ substitute and return the result\n        if (action_id):\n            return RedirectWarning(msg % values, action_id, _('Go to the configuration panel'))\n        return UserError(msg % values)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        # Optimisation: saving a res.config.settings even without changing any\n        # values will trigger the write of all related values. This in turn may\n        # trigger chain of further recomputation. To avoid it, delete values\n        # that were not changed.\n        for vals in vals_list:\n            for field in self._fields.values():\n                if not (field.name in vals and field.related and not field.readonly):\n                    continue\n                # we write on a related field like\n                # qr_code = fields.Boolean(related='company_id.qr_code', readonly=False)\n                fname0, *fnames = field.related.split(\".\")\n                if fname0 not in vals:\n                    continue\n\n                # determine the current value\n                field0 = self._fields[fname0]\n                old_value = field0.convert_to_record(\n                    field0.convert_to_cache(vals[fname0], self), self)\n                for fname in fnames:\n                    old_value = next(iter(old_value), old_value)[fname]\n\n                # determine the new value\n                new_value = field.convert_to_record(\n                    field.convert_to_cache(vals[field.name], self), self)\n\n                # drop if the value is the same\n                if old_value == new_value:\n                    vals.pop(field.name)\n\n        return super().create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_open_template_user",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_open_template_user(self):\n        action = self.env[\"ir.actions.actions\"]._for_xml_id(\"base.action_res_users\")\n        template_user_id = literal_eval(self.env['ir.config_parameter'].sudo().get_param('base.template_portal_user_id', 'False'))\n        template_user = self.env['res.users'].browse(template_user_id)\n        if not template_user.exists():\n            raise UserError(_('Invalid template user. It seems it has been deleted.'))\n        action['res_id'] = template_user_id\n        action['views'] = [[self.env.ref('base.view_users_form').id, 'form']]\n        return action",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "res.config.settings"
        },
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "_get_classified_fields (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "default_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_option_path (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_option_name (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_config_warning (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "MyConfigWizard"
    },
    {
      "name": "res.country",
      "description": "Country",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Country Name"
        },
        {
          "name": "code",
          "type": "Char",
          "required": true,
          "string": "Country Code",
          "help": "The ISO country code in two chars. \\nYou can use this field for quick search."
        },
        {
          "name": "address_format",
          "type": "Text",
          "string": "Layout in Reports",
          "help": "Display format to use for addresses belonging to this country.\\n\\n"
        },
        {
          "name": "address_view_id",
          "type": "Many2one",
          "relation": "ir.ui.view",
          "string": "Input View"
        },
        {
          "name": "currency_id",
          "type": "Many2one",
          "relation": "res.currency",
          "string": "Currency"
        },
        {
          "name": "image_url",
          "type": "Char",
          "string": "Flag",
          "help": "Url of static flag image"
        },
        {
          "name": "phone_code",
          "type": "Integer",
          "string": "Country Calling Code"
        },
        {
          "name": "country_group_ids",
          "type": "Many2many",
          "relation": "res.country.group",
          "string": "Country Groups"
        },
        {
          "name": "state_ids",
          "type": "One2many",
          "relation": "res.country.state",
          "string": "States"
        },
        {
          "name": "name_position",
          "type": "Selection"
        },
        {
          "name": "vat_label",
          "type": "Char",
          "string": "Vat Label",
          "help": "Use this field if you want to change vat label."
        },
        {
          "name": "state_required",
          "type": "Boolean"
        },
        {
          "name": "zip_required",
          "type": "Boolean"
        }
      ],
      "methods": [
        {
          "name": "_name_search",
          "params": [
            "self",
            "name",
            "domain=None",
            "operator='ilike'",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n        if domain is None:\n            domain = []\n\n        ids = []\n        if len(name) == 2:\n            ids = list(self._search([('code', 'ilike', name)] + domain, limit=limit, order=order))\n\n        search_domain = [('name', operator, name)]\n        if ids:\n            search_domain.append(('id', 'not in', ids))\n        ids += list(self._search(search_domain + domain, limit=limit, order=order))\n\n        return ids",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_phone_code_for",
          "params": [
            "self",
            "code"
          ],
          "decorators": [],
          "source": "def _phone_code_for(self, code):\n        return self.search([('code', '=', code)]).phone_code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        for vals in vals_list:\n            if vals.get('code'):\n                vals['code'] = vals['code'].upper()\n        return super(Country, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if vals.get('code'):\n            vals['code'] = vals['code'].upper()\n        res = super().write(vals)\n        if ('code' in vals or 'phone_code' in vals):\n            # Intentionally simplified by not clearing the cache in create and unlink.\n            self.env.registry.clear_cache()\n        if 'address_view_id' in vals:\n            # Changing the address view of the company must invalidate the view cached for res.partner\n            # because of _view_get_address\n            self.env.registry.clear_cache('templates')\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_address_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_address_fields(self):\n        self.ensure_one()\n        return re.findall(r'\\((.+?)\\)', self.address_format)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_image_url",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_image_url(self):\n        for country in self:\n            if not country.code or country.code in NO_FLAG_COUNTRIES:\n                country.image_url = False\n            else:\n                code = FLAG_MAPPING.get(country.code, country.code.lower())\n                country.image_url = \"/base/static/img/country_flags/%s.png\" % code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_address_format",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_address_format(self):\n        for record in self:\n            if record.address_format:\n                address_fields = self.env['res.partner']._formatting_address_fields() + ['state_code', 'state_name', 'country_code', 'country_name', 'company_name']\n                try:\n                    record.address_format % {i: 1 for i in address_fields}\n                except (ValueError, KeyError):\n                    raise UserError(_('The layout contains an invalid format key'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_uniq",
          "definition": "unique (name)",
          "message": "The name of the country must be unique!"
        },
        {
          "type": "sql",
          "name": "code_uniq",
          "definition": "unique (code)",
          "message": "The code of the country must be unique!"
        },
        {
          "type": "python",
          "name": "_check_address_format",
          "definition": "@api.constrains('address_format')\n    def _check_address_format(self):\n        for record in self:\n            if record.address_format:\n                address_fields = self.env['res.partner']._formatting_address_fields() + ['state_code', 'state_name', 'country_code', 'country_name', 'company_name']\n                try:\n                    record.address_format % {i: 1 for i in address_fields}\n                except (ValueError, KeyError):\n                    raise UserError(_('The layout contains an invalid format key'))",
          "message": "'address_format'"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Country"
    },
    {
      "name": "res.country.group",
      "description": "Country Group",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "country_ids",
          "type": "Many2many",
          "relation": "res.country",
          "string": "Countries"
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "CountryGroup"
    },
    {
      "name": "res.country.state",
      "description": "Country state",
      "fields": [
        {
          "name": "country_id",
          "type": "Many2one",
          "relation": "res.country",
          "required": true,
          "string": "Country"
        },
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "State Name",
          "help": "Administrative divisions of a country. E.g. Fed. State, Departement, Canton"
        },
        {
          "name": "code",
          "type": "Char",
          "required": true,
          "string": "State Code",
          "help": "The state code."
        }
      ],
      "methods": [
        {
          "name": "_name_search",
          "params": [
            "self",
            "name",
            "domain=None",
            "operator='ilike'",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n        domain = domain or []\n        if self.env.context.get('country_id'):\n            domain = expression.AND([domain, [('country_id', '=', self.env.context.get('country_id'))]])\n\n        if operator == 'ilike' and not (name or '').strip():\n            domain1 = []\n            domain2 = []\n        else:\n            domain1 = [('code', '=ilike', name)]\n            domain2 = [('name', operator, name)]\n\n        first_state_ids = []\n        if domain1:\n            first_state_ids = list(self._search(\n                expression.AND([domain1, domain]), limit=limit, order=order,\n            ))\n        fallback_domain = None\n\n        if name and operator in ['ilike', '=']:\n            fallback_domain = self._get_name_search_domain(name, operator)\n\n        if name and operator in ['in', 'any']:\n            fallback_domain = expression.OR([self._get_name_search_domain(n, '=') for n in name])\n\n        return first_state_ids + [\n            state_id\n            for state_id in self._search(expression.AND([domain2, domain]),\n                                         limit=limit, order=order)\n            if state_id not in first_state_ids\n        ] or (\n            list(self._search(expression.AND([fallback_domain, domain]), limit=limit))\n            if fallback_domain\n            else []\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_name_search_domain",
          "params": [
            "self",
            "name",
            "operator"
          ],
          "decorators": [],
          "source": "def _get_name_search_domain(self, name, operator):\n        m = re.fullmatch(r\"(?P<name>.+)\\((?P<country>.+)\\)\", name)\n        if m:\n            return [\n                ('name', operator, m['name'].strip()),\n                '|', ('country_id.name', 'ilike', m['country'].strip()),\n                ('country_id.code', '=', m['country'].strip()),\n            ]\n        return None",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        for record in self:\n            record.display_name = f\"{record.name} ({record.country_id.code})\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_code_uniq",
          "definition": "unique(country_id, code)",
          "message": "The code of the state must be unique by country!"
        }
      ],
      "accessRules": [
        {
          "name": "_name_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "CountryState"
    },
    {
      "name": "res.currency",
      "description": "Currency",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Currency"
        },
        {
          "name": "full_name",
          "type": "Char",
          "string": "Name"
        },
        {
          "name": "symbol",
          "type": "Char",
          "required": true,
          "help": "Currency sign, to be used when printing amounts."
        },
        {
          "name": "rate",
          "type": "Float",
          "string": "Current Rate",
          "help": "The rate of the currency to the currency of rate 1."
        },
        {
          "name": "inverse_rate",
          "type": "Float",
          "readonly": true,
          "help": "The currency of rate 1 to the rate of the currency."
        },
        {
          "name": "rate_string",
          "type": "Char"
        },
        {
          "name": "rate_ids",
          "type": "One2many",
          "relation": "res.currency.rate",
          "string": "Rates"
        },
        {
          "name": "rounding",
          "type": "Float",
          "string": "Rounding Factor"
        },
        {
          "name": "decimal_places",
          "type": "Integer",
          "help": "Decimal places taken into account for operations on amounts in this currency. It is determined by the rounding factor."
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "position",
          "type": "Selection"
        },
        {
          "name": "date",
          "type": "Date"
        },
        {
          "name": "currency_unit_label",
          "type": "Char",
          "string": "Currency Unit"
        },
        {
          "name": "currency_subunit_label",
          "type": "Char",
          "string": "Currency Subunit"
        },
        {
          "name": "is_current_company_currency",
          "type": "Boolean"
        }
      ],
      "methods": [
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        res = super().create(vals_list)\n        self._toggle_group_multi_currency()\n        # Currency info is cached to reduce the number of SQL queries when building the session\n        # info. See `ir_http.get_currencies`.\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        res = super().unlink()\n        self._toggle_group_multi_currency()\n        # Currency info is cached to reduce the number of SQL queries when building the session\n        # info. See `ir_http.get_currencies`.\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        res = super().write(vals)\n        if vals.keys() & {'active', 'digits', 'position', 'symbol'}:\n            # Currency info is cached to reduce the number of SQL queries when building the session\n            # info. See `ir_http.get_currencies`.\n            self.env.registry.clear_cache()\n        if 'active' not in vals:\n            return res\n        self._toggle_group_multi_currency()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_toggle_group_multi_currency",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _toggle_group_multi_currency(self):\n        \"\"\"\n        Automatically activate group_multi_currency if there is more than 1 active currency; deactivate it otherwise\n        \"\"\"\n        active_currency_count = self.search_count([('active', '=', True)])\n        if active_currency_count > 1:\n            self._activate_group_multi_currency()\n        elif active_currency_count <= 1:\n            self._deactivate_group_multi_currency()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_activate_group_multi_currency",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _activate_group_multi_currency(self):\n        group_user = self.env.ref('base.group_user', raise_if_not_found=False)\n        group_mc = self.env.ref('base.group_multi_currency', raise_if_not_found=False)\n        if group_user and group_mc:\n            group_user.sudo()._apply_group(group_mc)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_deactivate_group_multi_currency",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _deactivate_group_multi_currency(self):\n        group_user = self.env.ref('base.group_user', raise_if_not_found=False)\n        group_mc = self.env.ref('base.group_multi_currency', raise_if_not_found=False)\n        if group_user and group_mc:\n            group_user.sudo()._remove_group(group_mc.sudo())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_company_currency_stays_active",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_company_currency_stays_active(self):\n        if self._context.get('install_mode') or self._context.get('force_deactivate'):\n            # install_mode : At install, when this check is run, the \"active\" field of a currency added to a company will\n            #                still be evaluated as False, despite it's automatically set at True when added to the company.\n            # force_deactivate : Allows deactivation of a currency in tests to enable non multi_currency behaviors\n            return\n\n        currencies = self.filtered(lambda c: not c.active)\n        if self.env['res.company'].search([('currency_id', 'in', currencies.ids)]):\n            raise UserError(_(\"This currency is set on a company and therefore cannot be deactivated.\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_rates",
          "params": [
            "self",
            "company",
            "date"
          ],
          "decorators": [],
          "source": "def _get_rates(self, company, date):\n        if not self.ids:\n            return {}\n        self.env['res.currency.rate'].flush_model(['rate', 'currency_id', 'company_id', 'name'])\n        query = SQL(\n            \"\"\"\n            SELECT c.id,\n                   COALESCE(\n                       (             -- take the first rate before the given date\n                           SELECT r.rate\n                             FROM res_currency_rate r\n                            WHERE r.currency_id = c.id\n                              AND r.name <= %(date)s\n                              AND (r.company_id IS NULL OR r.company_id = %(company_id)s)\n                         ORDER BY r.company_id, r.name DESC\n                            LIMIT 1\n                       ),\n                       (             -- if no rate is found, take the rate for the very first date\n                           SELECT r.rate\n                             FROM res_currency_rate r\n                            WHERE r.currency_id = c.id\n                              AND (r.company_id IS NULL OR r.company_id = %(company_id)s)\n                         ORDER BY r.company_id, r.name ASC\n                            LIMIT 1\n                       ),\n                       1.0           -- fallback to 1\n                   ) AS rate\n              FROM res_currency c\n             WHERE c.id IN %(currency_ids)s\n            \"\"\",\n            date=date,\n            company_id=company.root_id.id,\n            currency_ids=tuple(self.ids),\n        )\n        self._cr.execute(query)\n        currency_rates = dict(self._cr.fetchall())\n        return currency_rates",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_is_current_company_currency",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_is_current_company_currency(self):\n        for currency in self:\n            currency.is_current_company_currency = self.env.company.currency_id == currency",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_current_rate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_current_rate(self):\n        date = self._context.get('date') or fields.Date.context_today(self)\n        company = self.env['res.company'].browse(self._context.get('company_id')) or self.env.company\n        to_currency = self.browse(self.env.context.get('to_currency')) or company.currency_id\n        # the subquery selects the last rate before 'date' for the given currency/company\n        currency_rates = (self + to_currency)._get_rates(self.env.company, date)\n        for currency in self:\n            currency.rate = (currency_rates.get(currency.id) or 1.0) / currency_rates.get(to_currency.id)\n            currency.inverse_rate = 1 / currency.rate\n            if currency != company.currency_id:\n                currency.rate_string = '1 %s = %.6f %s' % (to_currency.name, currency.rate, currency.name)\n            else:\n                currency.rate_string = ''",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_decimal_places",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_decimal_places(self):\n        for currency in self:\n            if 0 < currency.rounding < 1:\n                currency.decimal_places = int(math.ceil(math.log10(1/currency.rounding)))\n            else:\n                currency.decimal_places = 0",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_date",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_date(self):\n        for currency in self:\n            currency.date = currency.rate_ids[:1].name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "amount_to_text",
          "params": [
            "self",
            "amount"
          ],
          "decorators": [],
          "source": "def amount_to_text(self, amount):\n        self.ensure_one()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_num2words",
          "params": [
            "number",
            "lang"
          ],
          "decorators": [],
          "source": "def _num2words(number, lang):\n            try:\n                return num2words(number, lang=lang).title()\n            except NotImplementedError:\n                return num2words(number, lang='en').title()\n\n        if num2words is None:\n            logging.getLogger(__name__).warning(\"The library 'num2words' is missing, cannot render textual amounts.\")\n            return \"\"\n\n        formatted = \"%.{0}f\".format(self.decimal_places) % amount\n        parts = formatted.partition('.')\n        integer_value = int(parts[0])\n        fractional_value = int(parts[2] or 0)\n\n        lang = tools.get_lang(self.env)\n        amount_words = tools.ustr('{amt_value} {amt_word}').format(\n                        amt_value=_num2words(integer_value, lang=lang.iso_code),\n                        amt_word=self.currency_unit_label,\n                        )\n        if not self.is_zero(amount - integer_value):\n            amount_words += ' ' + _('and') + tools.ustr(' {amt_value} {amt_word}').format(\n                        amt_value=_num2words(fractional_value, lang=lang.iso_code),\n                        amt_word=self.currency_subunit_label,\n                        )\n        return amount_words",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "format",
          "params": [
            "self",
            "amount"
          ],
          "decorators": [],
          "source": "def format(self, amount):\n        \"\"\"Return ``amount`` formatted according to ``self``'s rounding rules, symbols and positions.\n\n           Also take care of removing the minus sign when 0.0 is negative\n\n           :param float amount: the amount to round\n           :return: formatted str\n        \"\"\"\n        self.ensure_one()\n        return tools.format_amount(self.env, amount + 0.0, self)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "round",
          "params": [
            "self",
            "amount"
          ],
          "decorators": [],
          "source": "def round(self, amount):\n        \"\"\"Return ``amount`` rounded  according to ``self``'s rounding rules.\n\n           :param float amount: the amount to round\n           :return: rounded float\n        \"\"\"\n        self.ensure_one()\n        return tools.float_round(amount, precision_rounding=self.rounding)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "compare_amounts",
          "params": [
            "self",
            "amount1",
            "amount2"
          ],
          "decorators": [],
          "source": "def compare_amounts(self, amount1, amount2):\n        \"\"\"Compare ``amount1`` and ``amount2`` after rounding them according to the\n           given currency's precision..\n           An amount is considered lower/greater than another amount if their rounded\n           value is different. This is not the same as having a non-zero difference!\n\n           For example 1.432 and 1.431 are equal at 2 digits precision,\n           so this method would return 0.\n           However 0.006 and 0.002 are considered different (returns 1) because\n           they respectively round to 0.01 and 0.0, even though\n           0.006-0.002 = 0.004 which would be considered zero at 2 digits precision.\n\n           :param float amount1: first amount to compare\n           :param float amount2: second amount to compare\n           :return: (resp.) -1, 0 or 1, if ``amount1`` is (resp.) lower than,\n                    equal to, or greater than ``amount2``, according to\n                    ``currency``'s rounding.\n\n           With the new API, call it like: ``currency.compare_amounts(amount1, amount2)``.\n        \"\"\"\n        self.ensure_one()\n        return tools.float_compare(amount1, amount2, precision_rounding=self.rounding)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "is_zero",
          "params": [
            "self",
            "amount"
          ],
          "decorators": [],
          "source": "def is_zero(self, amount):\n        \"\"\"Returns true if ``amount`` is small enough to be treated as\n           zero according to current currency's rounding rules.\n           Warning: ``is_zero(amount1-amount2)`` is not always equivalent to\n           ``compare_amounts(amount1,amount2) == 0``, as the former will round after\n           computing the difference, while the latter will round before, giving\n           different results for e.g. 0.006 and 0.002 at 2 digits precision.\n\n           :param float amount: amount to compare with currency's zero\n\n           With the new API, call it like: ``currency.is_zero(amount)``.\n        \"\"\"\n        self.ensure_one()\n        return tools.float_is_zero(amount, precision_rounding=self.rounding)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_conversion_rate",
          "params": [
            "self",
            "from_currency",
            "to_currency",
            "company=None",
            "date=None"
          ],
          "decorators": [],
          "source": "def _get_conversion_rate(self, from_currency, to_currency, company=None, date=None):\n        if from_currency == to_currency:\n            return 1\n        company = company or self.env.company\n        date = date or fields.Date.context_today(self)\n        return from_currency.with_company(company).with_context(to_currency=to_currency.id, date=str(date)).inverse_rate",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_convert",
          "params": [
            "self",
            "from_amount",
            "to_currency",
            "company=None",
            "date=None",
            "round=True"
          ],
          "decorators": [],
          "source": "def _convert(self, from_amount, to_currency, company=None, date=None, round=True):  # noqa: A002 builtin-argument-shadowing\n        \"\"\"Returns the converted amount of ``from_amount``` from the currency\n           ``self`` to the currency ``to_currency`` for the given ``date`` and\n           company.\n\n           :param company: The company from which we retrieve the convertion rate\n           :param date: The nearest date from which we retriev the conversion rate.\n           :param round: Round the result or not\n        \"\"\"\n        self, to_currency = self or to_currency, to_currency or self\n        assert self, \"convert amount from unknown currency\"\n        assert to_currency, \"convert amount to unknown currency\"\n        # apply conversion rate\n        if from_amount:\n            to_amount = from_amount * self._get_conversion_rate(self, to_currency, company, date)\n        else:\n            return 0.0\n\n        # apply rounding\n        return to_currency.round(to_amount) if round else to_amount",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_select_companies_rates",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _select_companies_rates(self):\n        return \"\"\"\n            SELECT\n                r.currency_id,\n                COALESCE(r.company_id, c.id) as company_id,\n                r.rate,\n                r.name AS date_start,\n                (SELECT name FROM res_currency_rate r2\n                 WHERE r2.name > r.name AND\n                       r2.currency_id = r.currency_id AND\n                       (r2.company_id is null or r2.company_id = c.id)\n                 ORDER BY r2.name ASC\n                 LIMIT 1) AS date_end\n            FROM res_currency_rate r\n            JOIN res_company c ON (r.company_id is null or r.company_id = c.id)\n        \"\"\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_cache_key",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view_cache_key(self, view_id=None, view_type='form', **options):\n        \"\"\"The override of _get_view changing the rate field labels according to the company currency\n        makes the view cache dependent on the company currency\"\"\"\n        key = super()._get_view_cache_key(view_id, view_type, **options)\n        return key + ((self.env['res.company'].browse(self._context.get('company_id')) or self.env.company).currency_id.name,)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view(self, view_id=None, view_type='form', **options):\n        arch, view = super()._get_view(view_id, view_type, **options)\n        if view_type in ('tree', 'form'):\n            currency_name = (self.env['res.company'].browse(self._context.get('company_id')) or self.env.company).currency_id.name\n            fields_maps = [\n                [['company_rate', 'rate'], _('Unit per %s', currency_name)],\n                [['inverse_company_rate', 'inverse_rate'], _('%s per Unit', currency_name)],\n            ]\n            for fnames, label in fields_maps:\n                xpath_expression = '//tree//field[' + \" or \".join(f\"@name='{f}'\" for f in fnames) + \"][1]\"\n                node = arch.xpath(xpath_expression)\n                if node:\n                    node[0].set('string', label)\n        return arch, view",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "unique_name",
          "definition": "unique (name)",
          "message": "The currency code must be unique!"
        },
        {
          "type": "sql",
          "name": "rounding_gt_zero",
          "definition": "CHECK (rounding>0)",
          "message": "The rounding factor must be greater than 0!"
        },
        {
          "type": "python",
          "name": "_check_company_currency_stays_active",
          "definition": "@api.constrains('active')\n    def _check_company_currency_stays_active(self):\n        if self._context.get('install_mode') or self._context.get('force_deactivate'):\n            # install_mode : At install, when this check is run, the \"active\" field of a currency added to a company will\n            #                still be evaluated as False, despite it's automatically set at True when added to the company.\n            # force_deactivate : Allows deactivation of a currency in tests to enable non multi_currency behaviors\n            return\n\n        currencies = self.filtered(lambda c: not c.active)\n        if self.env['res.company'].search([('currency_id', 'in', currencies.ids)]):\n            raise UserError(_(\"This currency is set on a company and therefore cannot be deactivated.\"))",
          "message": "'active'"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_toggle_group_multi_currency (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_activate_group_multi_currency (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_deactivate_group_multi_currency (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_conversion_rate (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view_cache_key (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Currency"
    },
    {
      "name": "res.currency.rate",
      "description": "Currency Rate",
      "fields": [
        {
          "name": "name",
          "type": "Date",
          "required": true,
          "string": "Date"
        },
        {
          "name": "rate",
          "type": "Float",
          "string": "Technical Rate",
          "help": "The rate of the currency to the currency of rate 1"
        },
        {
          "name": "company_rate",
          "type": "Float",
          "help": "The currency of rate 1 to the rate of the currency."
        },
        {
          "name": "inverse_company_rate",
          "type": "Float",
          "help": "The rate of the currency to the currency of rate 1 "
        },
        {
          "name": "currency_id",
          "type": "Many2one",
          "relation": "res.currency",
          "required": true,
          "readonly": true,
          "string": "Currency"
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company",
          "string": "Company"
        }
      ],
      "methods": [
        {
          "name": "_sanitize_vals",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def _sanitize_vals(self, vals):\n        if 'inverse_company_rate' in vals and ('company_rate' in vals or 'rate' in vals):\n            del vals['inverse_company_rate']\n        if 'company_rate' in vals and 'rate' in vals:\n            del vals['company_rate']\n        return vals",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        self.env['res.currency'].invalidate_model(['inverse_rate'])\n        return super().write(self._sanitize_vals(vals))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.env['res.currency'].invalidate_model(['inverse_rate'])\n        return super().create([self._sanitize_vals(vals) for vals in vals_list])",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_latest_rate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_latest_rate(self):\n        # Make sure 'name' is defined when creating a new rate.\n        if not self.name:\n            raise UserError(_(\"The name for the current rate is empty.\\nPlease set it.\"))\n        return self.currency_id.rate_ids.sudo().filtered(lambda x: (\n            x.rate\n            and x.company_id == (self.company_id or self.env.company.root_id)\n            and x.name < (self.name or fields.Date.today())\n        )).sorted('name')[-1:]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_last_rates_for_companies",
          "params": [
            "self",
            "companies"
          ],
          "decorators": [],
          "source": "def _get_last_rates_for_companies(self, companies):\n        return {\n            company: company.sudo().currency_id.rate_ids.filtered(lambda x: (\n                x.rate\n                and x.company_id == company or not x.company_id\n            )).sorted('name')[-1:].rate or 1\n            for company in companies\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_rate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_rate(self):\n        for currency_rate in self:\n            currency_rate.rate = currency_rate.rate or currency_rate._get_latest_rate().rate or 1.0",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_company_rate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_company_rate(self):\n        last_rate = self.env['res.currency.rate']._get_last_rates_for_companies(self.company_id | self.env.company.root_id)\n        for currency_rate in self:\n            company = currency_rate.company_id or self.env.company.root_id\n            currency_rate.company_rate = (currency_rate.rate or currency_rate._get_latest_rate().rate or 1.0) / last_rate[company]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_company_rate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_company_rate(self):\n        last_rate = self.env['res.currency.rate']._get_last_rates_for_companies(self.company_id | self.env.company.root_id)\n        for currency_rate in self:\n            company = currency_rate.company_id or self.env.company.root_id\n            currency_rate.rate = currency_rate.company_rate * last_rate[company]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_inverse_company_rate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_inverse_company_rate(self):\n        for currency_rate in self:\n            if not currency_rate.company_rate:\n                currency_rate.company_rate = 1.0\n            currency_rate.inverse_company_rate = 1.0 / currency_rate.company_rate",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_inverse_inverse_company_rate",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _inverse_inverse_company_rate(self):\n        for currency_rate in self:\n            if not currency_rate.inverse_company_rate:\n                currency_rate.inverse_company_rate = 1.0\n            currency_rate.company_rate = 1.0 / currency_rate.inverse_company_rate",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_rate_warning",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_rate_warning(self):\n        latest_rate = self._get_latest_rate()\n        if latest_rate:\n            diff = (latest_rate.rate - self.rate) / latest_rate.rate\n            if abs(diff) > 0.2:\n                return {\n                    'warning': {\n                        'title': _(\"Warning for %s\", self.currency_id.name),\n                        'message': _(\n                            \"The new rate is quite far from the previous rate.\\n\"\n                            \"Incorrect currency rates may cause critical problems, make sure the rate is correct!\"\n                        )\n                    }\n                }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_company_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_company_id(self):\n        for rate in self:\n            if rate.company_id.sudo().parent_id:\n                raise ValidationError(\"Currency rates should only be created for main companies\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_name_search",
          "params": [
            "self",
            "name",
            "domain=None",
            "operator='ilike'",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n        return super()._name_search(parse_date(self.env, name), domain, operator, limit, order)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_cache_key",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view_cache_key(self, view_id=None, view_type='form', **options):\n        \"\"\"The override of _get_view changing the rate field labels according to the company currency\n        makes the view cache dependent on the company currency\"\"\"\n        key = super()._get_view_cache_key(view_id, view_type, **options)\n        return key + ((self.env['res.company'].browse(self._context.get('company_id')) or self.env.company).currency_id.name,)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view(self, view_id=None, view_type='form', **options):\n        arch, view = super()._get_view(view_id, view_type, **options)\n        if view_type in ('tree'):\n            names = {\n                'company_currency_name': (self.env['res.company'].browse(self._context.get('company_id')) or self.env.company).currency_id.name,\n                'rate_currency_name': self.env['res.currency'].browse(self._context.get('active_id')).name or 'Unit',\n            }\n            for field in [['company_rate', _('%(rate_currency_name)s per %(company_currency_name)s', **names)],\n                          ['inverse_company_rate', _('%(company_currency_name)s per %(rate_currency_name)s', **names)]]:\n                node = arch.xpath(\"//tree//field[@name='%s']\" % field[0])\n                if node:\n                    node[0].set('string', field[1])\n        return arch, view",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "unique_name_per_day",
          "definition": "unique (name,currency_id,company_id)",
          "message": "Only one currency rate per day allowed!"
        },
        {
          "type": "sql",
          "name": "currency_rate_check",
          "definition": "CHECK (rate>0)",
          "message": "The currency rate must be strictly positive."
        },
        {
          "type": "python",
          "name": "_check_company_id",
          "definition": "@api.constrains('company_id')\n    def _check_company_id(self):\n        for rate in self:\n            if rate.company_id.sudo().parent_id:\n                raise ValidationError(\"Currency rates should only be created for main companies\")",
          "message": "'company_id'"
        }
      ],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_name_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view_cache_key (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "CurrencyRate"
    },
    {
      "name": "res.lang",
      "description": "Languages",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "code",
          "type": "Char",
          "required": true,
          "string": "Locale Code",
          "help": "This field is used to set/get locales for user"
        },
        {
          "name": "iso_code",
          "type": "Char",
          "string": "ISO code",
          "help": "This ISO code is the name of po files to use for translations"
        },
        {
          "name": "url_code",
          "type": "Char",
          "required": true,
          "help": "The Lang Code displayed in the URL"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "direction",
          "type": "Selection"
        },
        {
          "name": "date_format",
          "type": "Char",
          "required": true,
          "string": "Date Format"
        },
        {
          "name": "time_format",
          "type": "Char",
          "required": true,
          "string": "Time Format"
        },
        {
          "name": "week_start",
          "type": "Selection"
        },
        {
          "name": "grouping",
          "type": "Char",
          "required": true,
          "string": "Separator Format",
          "help": "The Separator Format should be like [,n] where 0 < n :starting from Unit digit. "
        },
        {
          "name": "decimal_point",
          "type": "Char",
          "required": true,
          "string": "Decimal Separator"
        },
        {
          "name": "thousands_sep",
          "type": "Char",
          "string": "Thousands Separator"
        },
        {
          "name": "flag_image",
          "type": "Image"
        },
        {
          "name": "flag_image_url",
          "type": "Char"
        }
      ],
      "methods": [
        {
          "name": "_compute_field_flag_image_url",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_field_flag_image_url(self):\n        for lang in self:\n            if lang.flag_image:\n                lang.flag_image_url = f\"/web/image/res.lang/{lang.id}/flag_image\"\n            else:\n                lang.flag_image_url = f\"/base/static/img/country_flags/{lang.code.lower().rsplit('_')[-1]}.png\"\n\n    flag_image = fields.Image(\"Image\")\n    flag_image_url = fields.Char(compute=_compute_field_flag_image_url)\n\n    _sql_constraints = [\n        ('name_uniq', 'unique(name)', 'The name of the language must be unique!'),\n        ('code_uniq', 'unique(code)', 'The code of the language must be unique!'),\n        ('url_code_uniq', 'unique(url_code)', 'The URL code of the language must be unique!'),\n    ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_active",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_active(self):\n        # do not check during installation\n        if self.env.registry.ready and not self.search_count([]):\n            raise ValidationError(_('At least one language must be active.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_format",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_format(self):\n        for lang in self:\n            for pattern in lang._disallowed_datetime_patterns:\n                if (lang.time_format and pattern in lang.time_format) or \\\n                        (lang.date_format and pattern in lang.date_format):\n                    raise ValidationError(_('Invalid date/time format directive specified. '\n                                            'Please refer to the list of allowed directives, '\n                                            'displayed when you edit a language.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_format",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_format(self):\n        warning = {\n            'warning': {\n                'title': _(\"Using 24-hour clock format with AM/PM can cause issues.\"),\n                'message': _(\"Changing to 12-hour clock format instead.\"),\n                'type': 'notification'\n            }\n        }\n        for lang in self:\n            if lang.date_format and \"%H\" in lang.date_format and \"%p\" in lang.date_format:\n                lang.date_format = lang.date_format.replace(\"%H\", \"%I\")\n                return warning\n            if lang.time_format and \"%H\" in lang.time_format and \"%p\" in lang.time_format:\n                lang.time_format = lang.time_format.replace(\"%H\", \"%I\")\n                return warning",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_grouping",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_grouping(self):\n        warning = _('The Separator Format should be like [,n] where 0 < n :starting from Unit digit. '\n                    '-1 will end the separation. e.g. [3,2,-1] will represent 106500 to be 1,06,500;'\n                    '[1,2,-1] will represent it to be 106,50,0;[3] will represent it as 106,500. '\n                    'Provided as the thousand separator in each case.')\n        for lang in self:\n            try:\n                if any(not isinstance(x, int) for x in json.loads(lang.grouping)):\n                    raise ValidationError(warning)\n            except Exception:\n                raise ValidationError(warning)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_register_hook",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _register_hook(self):\n        # check that there is at least one active language\n        if not self.search_count([]):\n            _logger.error(\"No language is active.\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_activate_lang",
          "params": [
            "self",
            "code"
          ],
          "decorators": [],
          "source": "def _activate_lang(self, code):\n        \"\"\" Activate languages\n        :param code: code of the language to activate\n        :return: the language matching 'code' activated\n        \"\"\"\n        lang = self.with_context(active_test=False).search([('code', '=', code)])\n        if lang and not lang.active:\n            lang.active = True\n        return lang",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_create_lang",
          "params": [
            "self",
            "lang",
            "lang_name=None"
          ],
          "decorators": [],
          "source": "def _create_lang(self, lang, lang_name=None):\n        \"\"\" Create the given language and make it active. \"\"\"\n        # create the language with locale information\n        fail = True\n        iso_lang = tools.get_iso_codes(lang)\n        for ln in tools.get_locales(lang):\n            try:\n                locale.setlocale(locale.LC_ALL, str(ln))\n                fail = False\n                break\n            except locale.Error:\n                continue\n        if fail:\n            lc = locale.getlocale()[0]\n            msg = 'Unable to get information for locale %s. Information from the default locale (%s) have been used.'\n            _logger.warning(msg, lang, lc)\n\n        if not lang_name:\n            lang_name = lang",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "fix_xa0",
          "params": [
            "s"
          ],
          "decorators": [],
          "source": "def fix_xa0(s):\n            \"\"\"Fix badly-encoded non-breaking space Unicode character from locale.localeconv(),\n               coercing to utf-8, as some platform seem to output localeconv() in their system\n               encoding, e.g. Windows-1252\"\"\"\n            if s == '\\xa0':\n                return '\\xc2\\xa0'\n            return s",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "fix_datetime_format",
          "params": [
            "format"
          ],
          "decorators": [],
          "source": "def fix_datetime_format(format):\n            \"\"\"Python's strftime supports only the format directives\n               that are available on the platform's libc, so in order to\n               be 100% cross-platform we map to the directives required by\n               the C standard (1989 version), always available on platforms\n               with a C standard implementation.\"\"\"\n            # For some locales, nl_langinfo returns a D_FMT/T_FMT that contains\n            # unsupported '%-' patterns, e.g. for cs_CZ\n            format = format.replace('%-', '%')\n            for pattern, replacement in tools.DATETIME_FORMATS_MAP.items():\n                format = format.replace(pattern, replacement)\n            return str(format)\n\n        conv = locale.localeconv()\n        lang_info = {\n            'code': lang,\n            'iso_code': iso_lang,\n            'name': lang_name,\n            'active': True,\n            'date_format' : fix_datetime_format(locale.nl_langinfo(locale.D_FMT)),\n            'time_format' : fix_datetime_format(locale.nl_langinfo(locale.T_FMT)),\n            'decimal_point' : fix_xa0(str(conv['decimal_point'])),\n            'thousands_sep' : fix_xa0(str(conv['thousands_sep'])),\n            'grouping' : str(conv.get('grouping', [])),\n        }\n        try:\n            return self.create(lang_info)\n        finally:\n            tools.resetlocale()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "install_lang",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def install_lang(self):\n        \"\"\"\n\n        This method is called from odoo/addons/base/data/res_lang_data.xml to load\n        some language and set it as the default for every partners. The\n        language is set via tools.config by the '_initialize_db' method on the\n        'db' object. This is a fragile solution and something else should be\n        found.\n\n        \"\"\"\n        # config['load_language'] is a comma-separated list or None\n        lang_code = (tools.config.get('load_language') or 'en_US').split(',')[0]\n        lang = self._activate_lang(lang_code) or self._create_lang(lang_code)\n        IrDefault = self.env['ir.default']\n        default_value = IrDefault._get('res.partner', 'lang')\n        if default_value is None:\n            IrDefault.set('res.partner', 'lang', lang_code)\n            # set language of main company, created directly by db bootstrap SQL\n            partner = self.env.company.partner_id\n            if not partner.lang:\n                partner.write({'lang': lang_code})\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_lang_get_id",
          "params": [
            "self",
            "code"
          ],
          "decorators": [],
          "source": "def _lang_get_id(self, code):\n        return self.with_context(active_test=True).search([('code', '=', code)]).id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_lang_get_direction",
          "params": [
            "self",
            "code"
          ],
          "decorators": [],
          "source": "def _lang_get_direction(self, code):\n        return self.with_context(active_test=True).search([('code', '=', code)]).direction",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_lang_get_code",
          "params": [
            "self",
            "url_code"
          ],
          "decorators": [],
          "source": "def _lang_get_code(self, url_code):\n        return self.with_context(active_test=True).search([('url_code', '=', url_code)]).code or url_code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_lang_get",
          "params": [
            "self",
            "code"
          ],
          "decorators": [],
          "source": "def _lang_get(self, code):\n        \"\"\" Return the language using this code if it is active \"\"\"\n        return self.browse(self._lang_get_id(code))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_data_get",
          "params": [
            "self",
            "monetary=False"
          ],
          "decorators": [],
          "source": "def _data_get(self, monetary=False):\n        thousands_sep = self.thousands_sep or ''\n        decimal_point = self.decimal_point\n        grouping = self.grouping\n        return grouping, thousands_sep, decimal_point",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_available",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_available(self):\n        \"\"\" Return the available languages as a list of (code, url_code, name,\n            active) sorted by name.\n        \"\"\"\n        langs = self.with_context(active_test=False).search([])\n        return langs.get_sorted()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_sorted",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_sorted(self):\n        return sorted([(lang.code, lang.url_code, lang.name, lang.active, lang.flag_image_url) for lang in self], key=itemgetter(2))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_cached_values",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_cached_values(self):\n        self.ensure_one()\n        return {\n            'id': self.id,\n            'code': self.code,\n            'url_code': self.url_code,\n            'name': self.name,\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_cached",
          "params": [
            "self",
            "field"
          ],
          "decorators": [],
          "source": "def _get_cached(self, field):\n        return self._get_cached_values()[field]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_lang_code_to_urlcode",
          "params": [
            "self",
            "code"
          ],
          "decorators": [],
          "source": "def _lang_code_to_urlcode(self, code):\n        for c, urlc, name, *_ in self.get_available():\n            if c == code:\n                return urlc\n        return self._lang_get(code).url_code",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_installed",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_installed(self):\n        \"\"\" Return the installed languages as a list of (code, name) sorted by name. \"\"\"\n        langs = self.with_context(active_test=True).search([])\n        return sorted([(lang.code, lang.name) for lang in langs], key=itemgetter(1))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "toggle_active",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def toggle_active(self):\n        super().toggle_active()\n        # Automatically load translation\n        active_lang = [lang.code for lang in self.filtered(lambda l: l.active)]\n        if active_lang:\n            mods = self.env['ir.module.module'].search([('state', '=', 'installed')])\n            mods._update_translations(active_lang)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        self.env.registry.clear_cache()\n        for vals in vals_list:\n            if not vals.get('url_code'):\n                vals['url_code'] = vals.get('iso_code') or vals['code']\n        return super(Lang, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        lang_codes = self.mapped('code')\n        if 'code' in vals and any(code != vals['code'] for code in lang_codes):\n            raise UserError(_(\"Language code cannot be modified.\"))\n        if vals.get('active') == False:\n            if self.env['res.users'].with_context(active_test=True).search_count([('lang', 'in', lang_codes)], limit=1):\n                raise UserError(_(\"Cannot deactivate a language that is currently used by users.\"))\n            if self.env['res.partner'].with_context(active_test=True).search_count([('lang', 'in', lang_codes)], limit=1):\n                raise UserError(_(\"Cannot deactivate a language that is currently used by contacts.\"))\n            if self.env['res.users'].with_context(active_test=False).search_count([('lang', 'in', lang_codes)], limit=1):\n                raise UserError(_(\"You cannot archive the language in which Odoo was setup as it is used by automated processes.\"))\n            # delete linked ir.default specifying default partner's language\n            self.env['ir.default'].discard_values('res.partner', 'lang', lang_codes)\n\n        res = super(Lang, self).write(vals)\n        self.env.flush_all()\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_except_default_lang",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_except_default_lang(self):\n        for language in self:\n            if language.code == 'en_US':\n                raise UserError(_(\"Base Language 'en_US' can not be deleted.\"))\n            ctx_lang = self._context.get('lang')\n            if ctx_lang and (language.code == ctx_lang):\n                raise UserError(_(\"You cannot delete the language which is the user's preferred language.\"))\n            if language.active:\n                raise UserError(_(\"You cannot delete the language which is Active!\\nPlease de-activate the language first.\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        self.env.registry.clear_cache()\n        return super(Lang, self).unlink()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy_data",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy_data(self, default=None):\n        default = dict(default or {})\n\n        if \"name\" not in default:\n            default[\"name\"] = _(\"%s (copy)\", self.name)\n        if \"code\" not in default:\n            default[\"code\"] = _(\"%s (copy)\", self.code)\n        if \"url_code\" not in default:\n            default[\"url_code\"] = _(\"%s (copy)\", self.url_code)\n        return super().copy_data(default=default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "format",
          "params": [
            "self",
            "percent",
            "value",
            "grouping=False",
            "monetary=False"
          ],
          "decorators": [],
          "source": "def format(self, percent, value, grouping=False, monetary=False):\n        \"\"\" Format() will return the language-specific output for float values\"\"\"\n        self.ensure_one()\n        if percent[0] != '%':\n            raise ValueError(_(\"format() must be given exactly one %char format specifier\"))\n\n        formatted = percent % value\n\n        # floats and decimal ints need special action!\n        if grouping:\n            lang_grouping, thousands_sep, decimal_point = self._data_get(monetary)\n            eval_lang_grouping = ast.literal_eval(lang_grouping)\n\n            if percent[-1] in 'eEfFgG':\n                parts = formatted.split('.')\n                parts[0] = intersperse(parts[0], eval_lang_grouping, thousands_sep)[0]\n\n                formatted = decimal_point.join(parts)\n\n            elif percent[-1] in 'diu':\n                formatted = intersperse(formatted, eval_lang_grouping, thousands_sep)[0]\n\n        return formatted",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_activate_langs",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_activate_langs(self):\n        \"\"\" Activate the selected languages \"\"\"\n        for lang in self.filtered(lambda l: not l.active):\n            lang.toggle_active()\n        message = _(\"The languages that you selected have been successfully installed. Users can choose their favorite language in their preferences.\")\n        return {\n            'type': 'ir.actions.client',\n            'tag': 'display_notification',\n            'target': 'new',\n            'params': {\n                'message': message,\n                'type': 'success',\n                'sticky': False,\n                'next': {'type': 'ir.actions.act_window_close'},\n            }\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "split",
          "params": [
            "l",
            "counts"
          ],
          "decorators": [],
          "source": "def split(l, counts):\n    \"\"\"\n\n    >>> split(\"hello world\", [])\n    ['hello world']\n    >>> split(\"hello world\", [1])\n    ['h', 'ello world']\n    >>> split(\"hello world\", [2])\n    ['he', 'llo world']\n    >>> split(\"hello world\", [2,3])\n    ['he', 'llo', ' world']\n    >>> split(\"hello world\", [2,3,0])\n    ['he', 'llo', ' wo', 'rld']\n    >>> split(\"hello world\", [2,-1,3])\n    ['he', 'llo world']\n\n    \"\"\"\n    res = []\n    saved_count = len(l) # count to use when encoutering a zero\n    for count in counts:\n        if not l:\n            break\n        if count == -1:\n            break\n        if count == 0:\n            while l:\n                res.append(l[:saved_count])\n                l = l[saved_count:]\n            break\n        res.append(l[:count])\n        l = l[count:]\n        saved_count = count\n    if l:\n        res.append(l)\n    return res\n\nintersperse_pat = re.compile('([^0-9]*)([^ ]*)(.*)')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "intersperse",
          "params": [
            "string",
            "counts",
            "separator=''"
          ],
          "decorators": [],
          "source": "def intersperse(string, counts, separator=''):\n    \"\"\"\n\n    See the asserts below for examples.\n\n    \"\"\"\n    left, rest, right = intersperse_pat.match(string).groups()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "reverse",
          "params": [
            "s"
          ],
          "decorators": [],
          "source": "def reverse(s): return s[::-1]\n    splits = split(reverse(rest), counts)\n    res = separator.join(reverse(s) for s in reverse(splits))\n    return left + res + right, len(splits) > 0 and len(splits) -1 or 0",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_uniq",
          "definition": "unique(name)",
          "message": "The name of the language must be unique!"
        },
        {
          "type": "sql",
          "name": "code_uniq",
          "definition": "unique(code)",
          "message": "The code of the language must be unique!"
        },
        {
          "type": "sql",
          "name": "url_code_uniq",
          "definition": "unique(url_code)",
          "message": "The URL code of the language must be unique!"
        },
        {
          "type": "python",
          "name": "_check_active",
          "definition": "@api.constrains('active')\n    def _check_active(self):\n        # do not check during installation\n        if self.env.registry.ready and not self.search_count([]):\n            raise ValidationError(_('At least one language must be active.'))",
          "message": "'active'"
        },
        {
          "type": "python",
          "name": "_check_format",
          "definition": "@api.constrains('time_format', 'date_format')\n    def _check_format(self):\n        for lang in self:\n            for pattern in lang._disallowed_datetime_patterns:\n                if (lang.time_format and pattern in lang.time_format) or \\\n                        (lang.date_format and pattern in lang.date_format):\n                    raise ValidationError(_('Invalid date/time format directive specified. '\n                                            'Please refer to the list of allowed directives, '\n                                            'displayed when you edit a language.'))",
          "message": "'time_format', 'date_format'"
        },
        {
          "type": "python",
          "name": "_check_grouping",
          "definition": "@api.constrains('grouping')\n    def _check_grouping(self):\n        warning = _('The Separator Format should be like [,n] where 0 < n :starting from Unit digit. '\n                    '-1 will end the separation. e.g. [3,2,-1] will represent 106500 to be 1,06,500;'\n                    '[1,2,-1] will represent it to be 106,50,0;[3] will represent it as 106,500. '\n                    'Provided as the thousand separator in each case.')\n        for lang in self:\n            try:\n                if any(not isinstance(x, int) for x in json.loads(lang.grouping)):\n                    raise ValidationError(warning)\n            except Exception:\n                raise ValidationError(warning)",
          "message": "'grouping'"
        }
      ],
      "accessRules": [
        {
          "name": "install_lang (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Lang"
    },
    {
      "name": "format.address.mixin",
      "description": "Address Format",
      "fields": [],
      "methods": [
        {
          "name": "_extract_fields_from_address",
          "params": [
            "self",
            "address_line"
          ],
          "decorators": [],
          "source": "def _extract_fields_from_address(self, address_line):\n        \"\"\"\n        Extract keys from the address line.\n        For example, if the address line is \"zip: %(zip)s, city: %(city)s.\",\n        this method will return ['zip', 'city'].\n        \"\"\"\n        address_fields = ['%(' + field + ')s' for field in ADDRESS_FIELDS + ('state_code', 'state_name')]\n        return sorted([field[2:-2] for field in address_fields if field in address_line], key=address_line.index)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_view_get_address",
          "params": [
            "self",
            "arch"
          ],
          "decorators": [],
          "source": "def _view_get_address(self, arch):\n        # consider the country of the user, not the country of the partner we want to display\n        address_view_id = self.env.company.country_id.address_view_id.sudo()\n        address_format = self.env.company.country_id.address_format\n        if address_view_id and not self._context.get('no_address_format') and (not address_view_id.model or address_view_id.model == self._name):\n            #render the partner address accordingly to address_view_id\n            for address_node in arch.xpath(\"//div[hasclass('o_address_format')]\"):\n                Partner = self.env['res.partner'].with_context(no_address_format=True)\n                sub_arch, _sub_view = Partner._get_view(address_view_id.id, 'form')\n                #if the model is different than res.partner, there are chances that the view won't work\n                #(e.g fields not present on the model). In that case we just return arch\n                if self._name != 'res.partner':\n                    try:\n                        self.env['ir.ui.view'].postprocess_and_fields(sub_arch, model=self._name)\n                    except ValueError:\n                        return arch\n                address_node.getparent().replace(address_node, sub_arch)\n        elif address_format and not self._context.get('no_address_format'):\n            # For the zip, city and state fields we need to move them around in order to follow the country address format.\n            # The purpose of this is to help the user by following a format he is used to.\n            city_line = [self._extract_fields_from_address(line) for line in address_format.split('\\n') if 'city' in line]\n            if city_line:\n                field_order = city_line[0]\n                for address_node in arch.xpath(\"//div[hasclass('o_address_format')]\"):\n                    first_field = field_order[0] if field_order[0] not in ('state_code', 'state_name') else 'state_id'\n                    concerned_fields = {'zip', 'city', 'state_id'} - {first_field}\n                    current_field = address_node.find(f\".//field[@name='{first_field}']\")\n                    # First loop into the fields displayed in the address_format, and order them.\n                    for field in field_order[1:]:\n                        if field in ('state_code', 'state_name'):\n                            field = 'state_id'\n                        previous_field = current_field\n                        current_field = address_node.find(f\".//field[@name='{field}']\")\n                        if previous_field is not None and current_field is not None:\n                            previous_field.addnext(current_field)\n                        concerned_fields -= {field}\n                    # Add the remaining fields in 'concerned_fields' at the end, after the others\n                    for field in concerned_fields:\n                        previous_field = current_field\n                        current_field = address_node.find(f\".//field[@name='{field}']\")\n                        if previous_field is not None and current_field is not None:\n                            previous_field.addnext(current_field)\n\n        return arch",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view_cache_key",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view_cache_key(self, view_id=None, view_type='form', **options):\n        \"\"\"The override of _get_view, using _view_get_address,\n        changing the architecture according to the address view of the company,\n        makes the view cache dependent on the company.\n        Different companies could use each a different address view\"\"\"\n        key = super()._get_view_cache_key(view_id, view_type, **options)\n        return key + (self.env.company, self._context.get('no_address_format'),)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view(self, view_id=None, view_type='form', **options):\n        arch, view = super()._get_view(view_id, view_type, **options)\n        if view.type == 'form':\n            arch = self._view_get_address(arch)\n        return arch, view",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_get_view_cache_key (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "FormatAddressMixin"
    },
    {
      "name": "res.partner.category",
      "description": "Partner Tags",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Tag Name"
        },
        {
          "name": "color",
          "type": "Integer",
          "string": "Color"
        },
        {
          "name": "parent_id",
          "type": "Many2one",
          "relation": "res.partner.category",
          "string": "Parent Category"
        },
        {
          "name": "child_ids",
          "type": "One2many",
          "relation": "res.partner.category",
          "string": "Child Tags"
        },
        {
          "name": "active",
          "type": "Boolean",
          "help": "The active field allows you to hide the category without removing it."
        },
        {
          "name": "parent_path",
          "type": "Char"
        },
        {
          "name": "partner_ids",
          "type": "Many2many",
          "relation": "res.partner",
          "string": "Partners"
        }
      ],
      "methods": [
        {
          "name": "_get_default_color",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_color(self):\n        return randint(1, 11)\n\n    name = fields.Char(string='Tag Name', required=True, translate=True)\n    color = fields.Integer(string='Color', default=_get_default_color)\n    parent_id = fields.Many2one('res.partner.category', string='Parent Category', index=True, ondelete='cascade')\n    child_ids = fields.One2many('res.partner.category', 'parent_id', string='Child Tags')\n    active = fields.Boolean(default=True, help=\"The active field allows you to hide the category without removing it.\")\n    parent_path = fields.Char(index=True, unaccent=False)\n    partner_ids = fields.Many2many('res.partner', column1='category_id', column2='partner_id', string='Partners', copy=False)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_parent_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_parent_id(self):\n        if not self._check_recursion():\n            raise ValidationError(_('You can not create recursive tags.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        \"\"\" Return the categories' display name, including their direct\n            parent by default.\n        \"\"\"\n        for category in self:\n            names = []\n            current = category\n            while current:\n                names.append(current.name or \"\")\n                current = current.parent_id\n            category.display_name = ' / '.join(reversed(names))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_name_search",
          "params": [
            "self",
            "name",
            "domain=None",
            "operator='ilike'",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n        domain = domain or []\n        if name:\n            # Be sure name_search is symetric to display_name\n            name = name.split(' / ')[-1]\n            domain = [('name', operator, name)] + domain\n        return self._search(domain, limit=limit, order=order)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_parent_id",
          "definition": "@api.constrains('parent_id')\n    def _check_parent_id(self):\n        if not self._check_recursion():\n            raise ValidationError(_('You can not create recursive tags.'))",
          "message": "'parent_id'"
        }
      ],
      "accessRules": [
        {
          "name": "_name_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "PartnerCategory"
    },
    {
      "name": "res.partner.title",
      "description": "Partner Title",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "string": "Title"
        },
        {
          "name": "shortcut",
          "type": "Char",
          "string": "Abbreviation"
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "PartnerTitle"
    },
    {
      "name": "res.partner",
      "description": "Contact",
      "fields": [
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "complete_name",
          "type": "Char"
        },
        {
          "name": "date",
          "type": "Date"
        },
        {
          "name": "title",
          "type": "Many2one",
          "relation": "res.partner.title"
        },
        {
          "name": "parent_id",
          "type": "Many2one",
          "relation": "res.partner",
          "string": "Related Company"
        },
        {
          "name": "parent_name",
          "type": "Char",
          "readonly": true,
          "string": "Parent name"
        },
        {
          "name": "child_ids",
          "type": "One2many",
          "relation": "res.partner",
          "string": "Contact"
        },
        {
          "name": "ref",
          "type": "Char",
          "string": "Reference"
        },
        {
          "name": "lang",
          "type": "Selection",
          "string": "Language",
          "help": "All the emails and documents sent to this contact will be translated in this language."
        },
        {
          "name": "active_lang_count",
          "type": "Integer"
        },
        {
          "name": "tz",
          "type": "Selection",
          "string": "Timezone"
        },
        {
          "name": "tz_offset",
          "type": "Char",
          "string": "Timezone offset"
        },
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "string": "Salesperson",
          "help": "The internal user in charge of this contact."
        },
        {
          "name": "vat",
          "type": "Char",
          "string": "Tax ID",
          "help": "The Tax Identification Number. Values here will be validated based on the country format. You can use "
        },
        {
          "name": "same_vat_partner_id",
          "type": "Many2one",
          "relation": "res.partner",
          "string": "Partner with same Tax ID"
        },
        {
          "name": "same_company_registry_partner_id",
          "type": "Many2one",
          "relation": "res.partner",
          "string": "Partner with same Company Registry"
        },
        {
          "name": "company_registry",
          "type": "Char",
          "string": "Company ID",
          "help": "The registry number of the company. Use it if it is different from the Tax ID. It must be unique across all partners of a same country"
        },
        {
          "name": "bank_ids",
          "type": "One2many",
          "relation": "res.partner.bank",
          "string": "Banks"
        },
        {
          "name": "website",
          "type": "Char"
        },
        {
          "name": "comment",
          "type": "Html",
          "string": "Notes"
        },
        {
          "name": "category_id",
          "type": "Many2many",
          "relation": "res.partner.category",
          "string": "Tags"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "employee",
          "type": "Boolean",
          "help": "Check this box if this contact is an Employee."
        },
        {
          "name": "function",
          "type": "Char",
          "string": "Job Position"
        },
        {
          "name": "type",
          "type": "Selection"
        },
        {
          "name": "street",
          "type": "Char"
        },
        {
          "name": "street2",
          "type": "Char"
        },
        {
          "name": "zip",
          "type": "Char"
        },
        {
          "name": "city",
          "type": "Char"
        },
        {
          "name": "state_id",
          "type": "Many2one",
          "relation": "res.country.state",
          "string": "State"
        },
        {
          "name": "country_id",
          "type": "Many2one",
          "relation": "res.country",
          "string": "Country"
        },
        {
          "name": "country_code",
          "type": "Char",
          "string": "Country Code"
        },
        {
          "name": "partner_latitude",
          "type": "Float",
          "string": "Geo Latitude"
        },
        {
          "name": "partner_longitude",
          "type": "Float",
          "string": "Geo Longitude"
        },
        {
          "name": "email",
          "type": "Char"
        },
        {
          "name": "email_formatted",
          "type": "Char",
          "help": "Format email address "
        },
        {
          "name": "phone",
          "type": "Char"
        },
        {
          "name": "mobile",
          "type": "Char"
        },
        {
          "name": "is_company",
          "type": "Boolean",
          "string": "Is a Company",
          "help": "Check if the contact is a company, otherwise it is a person"
        },
        {
          "name": "is_public",
          "type": "Boolean"
        },
        {
          "name": "industry_id",
          "type": "Many2one",
          "relation": "res.partner.industry"
        },
        {
          "name": "company_type",
          "type": "Selection",
          "string": "Company Type"
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company"
        },
        {
          "name": "color",
          "type": "Integer",
          "string": "Color Index"
        },
        {
          "name": "user_ids",
          "type": "One2many",
          "relation": "res.users",
          "string": "Users"
        },
        {
          "name": "partner_share",
          "type": "Boolean"
        },
        {
          "name": "contact_address",
          "type": "Char",
          "string": "Complete Address"
        },
        {
          "name": "commercial_partner_id",
          "type": "Many2one",
          "relation": "res.partner",
          "string": "Commercial Entity"
        },
        {
          "name": "commercial_company_name",
          "type": "Char"
        },
        {
          "name": "company_name",
          "type": "Char"
        },
        {
          "name": "barcode",
          "type": "Char",
          "help": "Use a barcode to identify this contact."
        },
        {
          "name": "self",
          "type": "Many2one"
        }
      ],
      "methods": [
        {
          "name": "_default_category",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _default_category(self):\n        return self.env['res.partner.category'].browse(self._context.get('category_id'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "default_get",
          "params": [
            "self",
            "default_fields"
          ],
          "decorators": [],
          "source": "def default_get(self, default_fields):\n        \"\"\"Add the company of the parent as default if we are creating a child partner.\n        Also take the parent lang by default if any, otherwise, fallback to default DB lang.\"\"\"\n        values = super().default_get(default_fields)\n        parent = self.env[\"res.partner\"]\n        if 'parent_id' in default_fields and values.get('parent_id'):\n            parent = self.browse(values.get('parent_id'))\n            values['company_id'] = parent.company_id.id\n        if 'lang' in default_fields:\n            values['lang'] = values.get('lang') or parent.lang or self.env.lang\n        # protection for `default_type` values leaking from menu action context (e.g. for crm's email)\n        if 'type' in default_fields and values.get('type'):\n            if values['type'] not in self._fields['type'].get_values(self.env):\n                values['type'] = None\n        return values\n\n    name = fields.Char(index=True, default_export_compatible=True)\n    complete_name = fields.Char(compute='_compute_complete_name', store=True, index=True)\n    date = fields.Date(index=True)\n    title = fields.Many2one('res.partner.title')\n    parent_id = fields.Many2one('res.partner', string='Related Company', index=True)\n    parent_name = fields.Char(related='parent_id.name', readonly=True, string='Parent name')\n    child_ids = fields.One2many('res.partner', 'parent_id', string='Contact', domain=[('active', '=', True)])\n    ref = fields.Char(string='Reference', index=True)\n    lang = fields.Selection(_lang_get, string='Language',\n                            help=\"All the emails and documents sent to this contact will be translated in this language.\")\n    active_lang_count = fields.Integer(compute='_compute_active_lang_count')\n    tz = fields.Selection(_tz_get, string='Timezone', default=lambda self: self._context.get('tz'),\n                          help=\"When printing documents and exporting/importing data, time values are computed according to this timezone.\\n\"\n                               \"If the timezone is not set, UTC (Coordinated Universal Time) is used.\\n\"\n                               \"Anywhere else, time values are computed according to the time offset of your web client.\")\n\n    tz_offset = fields.Char(compute='_compute_tz_offset', string='Timezone offset')\n    user_id = fields.Many2one(\n        'res.users', string='Salesperson',\n        compute='_compute_user_id',\n        precompute=True,  # avoid queries post-create\n        readonly=False, store=True,\n        help='The internal user in charge of this contact.')\n    vat = fields.Char(string='Tax ID', index=True, help=\"The Tax Identification Number. Values here will be validated based on the country format. You can use '/' to indicate that the partner is not subject to tax.\")\n    same_vat_partner_id = fields.Many2one('res.partner', string='Partner with same Tax ID', compute='_compute_same_vat_partner_id', store=False)\n    same_company_registry_partner_id = fields.Many2one('res.partner', string='Partner with same Company Registry', compute='_compute_same_vat_partner_id', store=False)\n    company_registry = fields.Char(string=\"Company ID\", compute='_compute_company_registry', store=True, readonly=False,\n       help=\"The registry number of the company. Use it if it is different from the Tax ID. It must be unique across all partners of a same country\")\n    bank_ids = fields.One2many('res.partner.bank', 'partner_id', string='Banks')\n    website = fields.Char('Website Link')\n    comment = fields.Html(string='Notes')\n\n    category_id = fields.Many2many('res.partner.category', column1='partner_id',\n                                    column2='category_id', string='Tags', default=_default_category)\n    active = fields.Boolean(default=True)\n    employee = fields.Boolean(help=\"Check this box if this contact is an Employee.\")\n    function = fields.Char(string='Job Position')\n    type = fields.Selection(\n        [('contact', 'Contact'),\n         ('invoice', 'Invoice Address'),\n         ('delivery', 'Delivery Address'),\n         ('other', 'Other Address'),\n        ], string='Address Type',\n        default='contact',\n        help=\"- Contact: Use this to organize the contact details of employees of a given company (e.g. CEO, CFO, ...).\\n\"\n             \"- Invoice Address: Preferred address for all invoices. Selected by default when you invoice an order that belongs to this company.\\n\"\n             \"- Delivery Address: Preferred address for all deliveries. Selected by default when you deliver an order that belongs to this company.\\n\"\n             \"- Other: Other address for the company (e.g. subsidiary, ...)\")\n    # address fields\n    street = fields.Char()\n    street2 = fields.Char()\n    zip = fields.Char(change_default=True)\n    city = fields.Char()\n    state_id = fields.Many2one(\"res.country.state\", string='State', ondelete='restrict', domain=\"[('country_id', '=?', country_id)]\")\n    country_id = fields.Many2one('res.country', string='Country', ondelete='restrict')\n    country_code = fields.Char(related='country_id.code', string=\"Country Code\")\n    partner_latitude = fields.Float(string='Geo Latitude', digits=(10, 7))\n    partner_longitude = fields.Float(string='Geo Longitude', digits=(10, 7))\n    email = fields.Char()\n    email_formatted = fields.Char(\n        'Formatted Email', compute='_compute_email_formatted',\n        help='Format email address \"Name <email@domain>\"')\n    phone = fields.Char(unaccent=False)\n    mobile = fields.Char(unaccent=False)\n    is_company = fields.Boolean(string='Is a Company', default=False,\n        help=\"Check if the contact is a company, otherwise it is a person\")\n    is_public = fields.Boolean(compute='_compute_is_public')\n    industry_id = fields.Many2one('res.partner.industry', 'Industry')\n    # company_type is only an interface field, do not use it in business logic\n    company_type = fields.Selection(string='Company Type',\n        selection=[('person', 'Individual'), ('company', 'Company')],\n        compute='_compute_company_type', inverse='_write_company_type')\n    company_id = fields.Many2one('res.company', 'Company', index=True)\n    color = fields.Integer(string='Color Index', default=0)\n    user_ids = fields.One2many('res.users', 'partner_id', string='Users', auto_join=True)\n    partner_share = fields.Boolean(\n        'Share Partner', compute='_compute_partner_share', store=True,\n        help=\"Either customer (not a user), either shared user. Indicated the current partner is a customer without \"\n             \"access or with a limited access created for sharing data.\")\n    contact_address = fields.Char(compute='_compute_contact_address', string='Complete Address')\n\n    # technical field used for managing commercial fields\n    commercial_partner_id = fields.Many2one(\n        'res.partner', string='Commercial Entity',\n        compute='_compute_commercial_partner', store=True,\n        recursive=True, index=True)\n    commercial_company_name = fields.Char('Company Name Entity', compute='_compute_commercial_company_name',\n                                          store=True)\n    company_name = fields.Char('Company Name')\n    barcode = fields.Char(help=\"Use a barcode to identify this contact.\", copy=False, company_dependent=True)\n\n    # hack to allow using plain browse record in qweb views, and used in ir.qweb.field.contact\n    self = fields.Many2one(comodel_name=_name, compute='_compute_get_ids')\n\n    _sql_constraints = [\n        ('check_name', \"CHECK( (type='contact' AND name IS NOT NULL) or (type!='contact') )\", 'Contacts require a name'),\n    ]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_street_split",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_street_split(self):\n        self.ensure_one()\n        return tools.street_split(self.street or '')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_1920",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_1920(self):\n        super()._compute_avatar_1920()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_1024",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_1024(self):\n        super()._compute_avatar_1024()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_512",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_512(self):\n        super()._compute_avatar_512()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_256",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_256(self):\n        super()._compute_avatar_256()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar_128",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_avatar_128(self):\n        super()._compute_avatar_128()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_avatar",
          "params": [
            "self",
            "avatar_field",
            "image_field"
          ],
          "decorators": [],
          "source": "def _compute_avatar(self, avatar_field, image_field):\n        partners_with_internal_user = self.filtered(lambda partner: partner.user_ids - partner.user_ids.filtered('share'))\n        super(Partner, partners_with_internal_user)._compute_avatar(avatar_field, image_field)\n        partners_without_image = (self - partners_with_internal_user).filtered(lambda p: not p[image_field])\n        for _, group in tools.groupby(partners_without_image, key=lambda p: p._avatar_get_placeholder_path()):\n            group_partners = self.env['res.partner'].concat(*group)\n            group_partners[avatar_field] = base64.b64encode(group_partners[0]._avatar_get_placeholder())\n\n        for partner in self - partners_with_internal_user - partners_without_image:\n            partner[avatar_field] = partner[image_field]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_avatar_get_placeholder_path",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _avatar_get_placeholder_path(self):\n        if self.is_company:\n            return \"base/static/img/company_image.png\"\n        if self.type == 'delivery':\n            return \"base/static/img/truck.png\"\n        if self.type == 'invoice':\n            return \"base/static/img/money.png\"\n        return super()._avatar_get_placeholder_path()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_complete_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_complete_name(self):\n        self.ensure_one()\n\n        displayed_types = self._complete_name_displayed_types\n        type_description = dict(self._fields['type']._description_selection(self.env))\n\n        name = self.name or ''\n        if self.company_name or self.parent_id:\n            if not name and self.type in displayed_types:\n                name = type_description[self.type]\n            if not self.is_company:\n                name = f\"{self.commercial_company_name or self.sudo().parent_id.name}, {name}\"\n        return name.strip()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_complete_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_complete_name(self):\n        for partner in self:\n            partner.complete_name = partner.with_context({})._get_complete_name()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_active_lang_count",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_active_lang_count(self):\n        lang_count = len(self.env['res.lang'].get_installed())\n        for partner in self:\n            partner.active_lang_count = lang_count",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_tz_offset",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_tz_offset(self):\n        for partner in self:\n            partner.tz_offset = datetime.datetime.now(pytz.timezone(partner.tz or 'GMT')).strftime('%z')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_user_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_user_id(self):\n        \"\"\" Synchronize sales rep with parent if partner is a person \"\"\"\n        for partner in self.filtered(lambda partner: not partner.user_id and partner.company_type == 'person' and partner.parent_id.user_id):\n            partner.user_id = partner.parent_id.user_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_partner_share",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_partner_share(self):\n        super_partner = self.env['res.users'].browse(SUPERUSER_ID).partner_id\n        if super_partner in self:\n            super_partner.partner_share = False\n        for partner in self - super_partner:\n            partner.partner_share = not partner.user_ids or not any(not user.share for user in partner.user_ids)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_same_vat_partner_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_same_vat_partner_id(self):\n        for partner in self:\n            # use _origin to deal with onchange()\n            partner_id = partner._origin.id\n            #active_test = False because if a partner has been deactivated you still want to raise the error,\n            #so that you can reactivate it instead of creating a new one, which would loose its history.\n            Partner = self.with_context(active_test=False).sudo()\n            domain = [\n                ('vat', '=', partner.vat),\n            ]\n            if partner.company_id:\n                domain += [('company_id', 'in', [False, partner.company_id.id])]\n            if partner_id:\n                domain += [('id', '!=', partner_id), '!', ('id', 'child_of', partner_id)]\n            # For VAT number being only one character, we will skip the check just like the regular check_vat\n            should_check_vat = partner.vat and len(partner.vat) != 1\n            partner.same_vat_partner_id = should_check_vat and not partner.parent_id and Partner.search(domain, limit=1)\n            # check company_registry\n            domain = [\n                ('company_registry', '=', partner.company_registry),\n                ('company_id', 'in', [False, partner.company_id.id]),\n            ]\n            if partner_id:\n                domain += [('id', '!=', partner_id), '!', ('id', 'child_of', partner_id)]\n            partner.same_company_registry_partner_id = bool(partner.company_registry) and not partner.parent_id and Partner.search(domain, limit=1)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_contact_address",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_contact_address(self):\n        for partner in self:\n            partner.contact_address = partner._display_address()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_get_ids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_get_ids(self):\n        for partner in self:\n            partner.self = partner.id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_commercial_partner",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_commercial_partner(self):\n        for partner in self:\n            if partner.is_company or not partner.parent_id:\n                partner.commercial_partner_id = partner\n            else:\n                partner.commercial_partner_id = partner.parent_id.commercial_partner_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_commercial_company_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_commercial_company_name(self):\n        for partner in self:\n            p = partner.commercial_partner_id\n            partner.commercial_company_name = p.is_company and p.name or partner.company_name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_company_registry",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_company_registry(self):\n        # exists to allow overrides\n        for company in self:\n            company.company_registry = company.company_registry",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_view",
          "params": [
            "self",
            "view_id=None",
            "view_type='form'",
            "**options"
          ],
          "decorators": [],
          "source": "def _get_view(self, view_id=None, view_type='form', **options):\n        arch, view = super()._get_view(view_id, view_type, **options)\n        company = self.env.company\n        if company.country_id.vat_label:\n            for node in arch.xpath(\"//field[@name='vat']\"):\n                node.attrib[\"string\"] = company.country_id.vat_label\n        return arch, view",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_parent_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_parent_id(self):\n        if not self._check_recursion():\n            raise ValidationError(_('You cannot create recursive Partner hierarchies.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        self.ensure_one()\n        chosen_name = default.get('name') if default else ''\n        new_name = chosen_name or _('%s (copy)', self.name)\n        default = dict(default or {}, name=new_name)\n        return super(Partner, self).copy(default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "onchange_parent_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def onchange_parent_id(self):\n        # return values in result, as this method is used by _fields_sync()\n        if not self.parent_id:\n            return\n        result = {}\n        partner = self._origin\n        if partner.parent_id and partner.parent_id != self.parent_id:\n            result['warning'] = {\n                'title': _('Warning'),\n                'message': _('Changing the company of a contact should only be done if it '\n                             'was never correctly set. If an existing contact starts working for a new '\n                             'company then a new contact should be created under that new '\n                             'company. You can use the \"Discard\" button to abandon this change.')}\n        if partner.type == 'contact' or self.type == 'contact':\n            # for contacts: copy the parent address, if set (aka, at least one\n            # value is set in the address: otherwise, keep the one from the\n            # contact)\n            address_fields = self._address_fields()\n            if any(self.parent_id[key] for key in address_fields):",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "convert",
          "params": [
            "value"
          ],
          "decorators": [],
          "source": "def convert(value):\n                    return value.id if isinstance(value, models.BaseModel) else value\n                result['value'] = {key: convert(self.parent_id[key]) for key in address_fields}\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_parent_id_for_lang",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_parent_id_for_lang(self):\n        # While creating / updating child contact, take the parent lang by default if any\n        # otherwise, fallback to default context / DB lang\n        if self.parent_id:\n            self.lang = self.parent_id.lang or self.env.context.get('default_lang') or self.env.lang",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_country_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_country_id(self):\n        if self.country_id and self.country_id != self.state_id.country_id:\n            self.state_id = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_state",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_state(self):\n        if self.state_id.country_id and self.country_id != self.state_id.country_id:\n            self.country_id = self.state_id.country_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "onchange_email",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def onchange_email(self):\n        if not self.image_1920 and self._context.get('gravatar_image') and self.email:\n            self.image_1920 = self._get_gravatar_image(self.email)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_onchange_company_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _onchange_company_id(self):\n        if self.parent_id:\n            self.company_id = self.parent_id.company_id.id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_email_formatted",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_email_formatted(self):\n        \"\"\" Compute formatted email for partner, using formataddr. Be defensive\n        in computation, notably\n\n          * double format: if email already holds a formatted email like\n            'Name' <email@domain.com> we should not use it as it to compute\n            email formatted like \"Name <'Name' <email@domain.com>>\";\n          * multi emails: sometimes this field is used to hold several addresses\n            like email1@domain.com, email2@domain.com. We currently let this value\n            untouched, but remove any formatting from multi emails;\n          * invalid email: if something is wrong, keep it in email_formatted as\n            this eases management and understanding of failures at mail.mail,\n            mail.notification and mailing.trace level;\n          * void email: email_formatted is False, as we cannot do anything with\n            it;\n        \"\"\"\n        self.email_formatted = False\n        for partner in self:\n            emails_normalized = tools.email_normalize_all(partner.email)\n            if emails_normalized:\n                # note: multi-email input leads to invalid email like \"Name\" <email1, email2>\n                # but this is current behavior in Odoo 14+ and some servers allow it\n                partner.email_formatted = tools.formataddr((\n                    partner.name or u\"False\",\n                    ','.join(emails_normalized)\n                ))\n            elif partner.email:\n                partner.email_formatted = tools.formataddr((\n                    partner.name or u\"False\",\n                    partner.email\n                ))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_company_type",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_company_type(self):\n        for partner in self:\n            partner.company_type = 'company' if partner.is_company else 'person'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_write_company_type",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _write_company_type(self):\n        for partner in self:\n            partner.is_company = partner.company_type == 'company'",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "onchange_company_type",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def onchange_company_type(self):\n        self.is_company = (self.company_type == 'company')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_barcode_unicity",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_barcode_unicity(self):\n        for partner in self:\n            if partner.barcode and self.env['res.partner'].search_count([('barcode', '=', partner.barcode)]) > 1:\n                raise ValidationError(_('Another partner already has this barcode'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_fields_values",
          "params": [
            "self",
            "fields"
          ],
          "decorators": [],
          "source": "def _update_fields_values(self, fields):\n        \"\"\" Returns dict of write() values for synchronizing ``fields`` \"\"\"\n        values = {}\n        for fname in fields:\n            field = self._fields[fname]\n            if field.type == 'many2one':\n                values[fname] = self[fname].id\n            elif field.type == 'one2many':\n                raise AssertionError(_('One2Many fields cannot be synchronized as part of `commercial_fields` or `address fields`'))\n            elif field.type == 'many2many':\n                values[fname] = [Command.set(self[fname].ids)]\n            else:\n                values[fname] = self[fname]\n        return values",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_address_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _address_fields(self):\n        \"\"\"Returns the list of address fields that are synced from the parent.\"\"\"\n        return list(ADDRESS_FIELDS)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_formatting_address_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _formatting_address_fields(self):\n        \"\"\"Returns the list of address fields usable to format addresses.\"\"\"\n        return self._address_fields()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "update_address",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def update_address(self, vals):\n        addr_vals = {key: vals[key] for key in self._address_fields() if key in vals}\n        if addr_vals:\n            return super(Partner, self).write(addr_vals)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_commercial_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _commercial_fields(self):\n        \"\"\" Returns the list of fields that are managed by the commercial entity\n        to which a partner belongs. These fields are meant to be hidden on\n        partners that aren't `commercial entities` themselves, and will be\n        delegated to the parent `commercial entity`. The list is meant to be\n        extended by inheriting classes. \"\"\"\n        return ['vat', 'company_registry', 'industry_id']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_commercial_sync_from_company",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _commercial_sync_from_company(self):\n        \"\"\" Handle sync of commercial fields when a new parent commercial entity is set,\n        as if they were related fields \"\"\"\n        commercial_partner = self.commercial_partner_id\n        if commercial_partner != self:\n            sync_vals = commercial_partner._update_fields_values(self._commercial_fields())\n            self.write(sync_vals)\n            self._commercial_sync_to_children()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_commercial_sync_to_children",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _commercial_sync_to_children(self):\n        \"\"\" Handle sync of commercial fields to descendants \"\"\"\n        commercial_partner = self.commercial_partner_id\n        sync_vals = commercial_partner._update_fields_values(self._commercial_fields())\n        sync_children = self.child_ids.filtered(lambda c: not c.is_company)\n        for child in sync_children:\n            child._commercial_sync_to_children()\n        res = sync_children.write(sync_vals)\n        sync_children._compute_commercial_partner()\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_fields_sync",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _fields_sync(self, values):\n        \"\"\" Sync commercial fields and address fields from company and to children after create/update,\n        just as if those were all modeled as fields.related to the parent \"\"\"\n        # 1. From UPSTREAM: sync from parent\n        if values.get('parent_id') or values.get('type') == 'contact':\n            # 1a. Commercial fields: sync if parent changed\n            if values.get('parent_id'):\n                self.sudo()._commercial_sync_from_company()\n            # 1b. Address fields: sync if parent or use_parent changed *and* both are now set\n            if self.parent_id and self.type == 'contact':\n                onchange_vals = self.onchange_parent_id().get('value', {})\n                self.update_address(onchange_vals)\n\n        # 2. To DOWNSTREAM: sync children\n        self._children_sync(values)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_children_sync",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _children_sync(self, values):\n        if not self.child_ids:\n            return\n        # 2a. Commercial Fields: sync if commercial entity\n        if self.commercial_partner_id == self:\n            commercial_fields = self._commercial_fields()\n            if any(field in values for field in commercial_fields):\n                self.sudo()._commercial_sync_to_children()\n        for child in self.child_ids.filtered(lambda c: not c.is_company):\n            if child.commercial_partner_id != self.commercial_partner_id:\n                self.sudo()._commercial_sync_to_children()\n                break\n        # 2b. Address fields: sync if address changed\n        address_fields = self._address_fields()\n        if any(field in values for field in address_fields):\n            contacts = self.child_ids.filtered(lambda c: c.type == 'contact')\n            contacts.update_address(values)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_handle_first_contact_creation",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _handle_first_contact_creation(self):\n        \"\"\" On creation of first contact for a company (or root) that has no address, assume contact address\n        was meant to be company address \"\"\"\n        parent = self.parent_id\n        address_fields = self._address_fields()\n        if (parent.is_company or not parent.parent_id) and len(parent.child_ids) == 1 and \\\n            any(self[f] for f in address_fields) and not any(parent[f] for f in address_fields):\n            addr_vals = self._update_fields_values(address_fields)\n            parent.update_address(addr_vals)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_clean_website",
          "params": [
            "self",
            "website"
          ],
          "decorators": [],
          "source": "def _clean_website(self, website):\n        url = urls.url_parse(website)\n        if not url.scheme:\n            if not url.netloc:\n                url = url.replace(netloc=url.path, path='')\n            website = url.replace(scheme='http').to_url()\n        return website",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_is_public",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_is_public(self):\n        for partner in self.with_context(active_test=False):\n            users = partner.user_ids\n            partner.is_public = users and any(user._is_public() for user in users)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if vals.get('active') is False:\n            # DLE: It should not be necessary to modify this to make work the ORM. The problem was just the recompute\n            # of partner.user_ids when you create a new user for this partner, see test test_70_archive_internal_partners\n            # You modified it in a previous commit, see original commit of this:\n            # https://github.com/odoo/odoo/commit/9d7226371730e73c296bcc68eb1f856f82b0b4ed\n            #\n            # RCO: when creating a user for partner, the user is automatically added in partner.user_ids.\n            # This is wrong if the user is not active, as partner.user_ids only returns active users.\n            # Hence this temporary hack until the ORM updates inverse fields correctly.\n            self.invalidate_recordset(['user_ids'])\n            users = self.env['res.users'].sudo().search([('partner_id', 'in', self.ids)])\n            if users:\n                if self.env['res.users'].sudo(False).check_access_rights('write', raise_exception=False):\n                    error_msg = _('You cannot archive contacts linked to an active user.\\n'\n                                  'You first need to archive their associated user.\\n\\n'\n                                  'Linked active users : %(names)s', names=\", \".join([u.display_name for u in users]))\n                    action_error = users._action_show()\n                    raise RedirectWarning(error_msg, action_error, _('Go to users'))\n                else:\n                    raise ValidationError(_('You cannot archive contacts linked to an active user.\\n'\n                                            'Ask an administrator to archive their associated user first.\\n\\n'\n                                            'Linked active users :\\n%(names)s', names=\", \".join([u.display_name for u in users])))\n        # res.partner must only allow to set the company_id of a partner if it\n        # is the same as the company of all users that inherit from this partner\n        # (this is to allow the code from res_users to write to the partner!) or\n        # if setting the company_id to False (this is compatible with any user\n        # company)\n        if vals.get('website'):\n            vals['website'] = self._clean_website(vals['website'])\n        if vals.get('parent_id'):\n            vals['company_name'] = False\n        if 'company_id' in vals:\n            company_id = vals['company_id']\n            for partner in self:\n                if company_id and partner.user_ids:\n                    company = self.env['res.company'].browse(company_id)\n                    companies = set(user.company_id for user in partner.user_ids)\n                    if len(companies) > 1 or company not in companies:\n                        raise UserError(\n                            (\"The selected company is not compatible with the companies of the related user(s)\"))\n                if partner.child_ids:\n                    partner.child_ids.write({'company_id': company_id})\n        result = True\n        # To write in SUPERUSER on field is_company and avoid access rights problems.\n        if 'is_company' in vals and self.user_has_groups('base.group_partner_manager') and not self.env.su:\n            result = super(Partner, self.sudo()).write({'is_company': vals.get('is_company')})\n            del vals['is_company']\n        result = result and super(Partner, self).write(vals)\n        for partner in self:\n            if any(u._is_internal() for u in partner.user_ids if u != self.env.user):\n                self.env['res.users'].check_access_rights('write')\n            partner._fields_sync(vals)\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        if self.env.context.get('import_file'):\n            self._check_import_consistency(vals_list)\n        for vals in vals_list:\n            if vals.get('website'):\n                vals['website'] = self._clean_website(vals['website'])\n            if vals.get('parent_id'):\n                vals['company_name'] = False\n        partners = super(Partner, self).create(vals_list)\n\n        if self.env.context.get('_partners_skip_fields_sync'):\n            return partners\n\n        for partner, vals in zip(partners, vals_list):\n            partner._fields_sync(vals)\n            # Lang: propagate from parent if no value was given\n            if 'lang' not in vals and partner.parent_id:\n                partner._onchange_parent_id_for_lang()\n            partner._handle_first_contact_creation()\n        return partners",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_except_user",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_except_user(self):\n        users = self.env['res.users'].sudo().search([('partner_id', 'in', self.ids)])\n        if not users:\n            return  # no linked user, operation is allowed\n        if self.env['res.users'].sudo(False).check_access_rights('write', raise_exception=False):\n            error_msg = _('You cannot delete contacts linked to an active user.\\n'\n                          'You should rather archive them after archiving their associated user.\\n\\n'\n                          'Linked active users : %(names)s', names=\", \".join([u.display_name for u in users]))\n            action_error = users._action_show()\n            raise RedirectWarning(error_msg, action_error, _('Go to users'))\n        else:\n            raise ValidationError(_('You cannot delete contacts linked to an active user.\\n'\n                                    'Ask an administrator to archive their associated user first.\\n\\n'\n                                    'Linked active users :\\n%(names)s', names=\", \".join([u.display_name for u in users])))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_load_records_create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def _load_records_create(self, vals_list):\n        partners = super(Partner, self.with_context(_partners_skip_fields_sync=True))._load_records_create(vals_list)\n\n        # batch up first part of _fields_sync\n        # group partners by commercial_partner_id (if not self) and parent_id (if type == contact)\n        groups = collections.defaultdict(list)\n        for partner, vals in zip(partners, vals_list):\n            cp_id = None\n            if vals.get('parent_id') and partner.commercial_partner_id != partner:\n                cp_id = partner.commercial_partner_id.id\n\n            add_id = None\n            if partner.parent_id and partner.type == 'contact':\n                add_id = partner.parent_id.id\n            groups[(cp_id, add_id)].append(partner.id)\n\n        for (cp_id, add_id), children in groups.items():\n            # values from parents (commercial, regular) written to their common children\n            to_write = {}\n            # commercial fields from commercial partner\n            if cp_id:\n                to_write = self.browse(cp_id)._update_fields_values(self._commercial_fields())\n            # address fields from parent\n            if add_id:\n                parent = self.browse(add_id)\n                for f in self._address_fields():\n                    v = parent[f]\n                    if v:\n                        to_write[f] = v.id if isinstance(v, models.BaseModel) else v\n            if to_write:\n                self.sudo().browse(children).write(to_write)\n\n        # do the second half of _fields_sync the \"normal\" way\n        for partner, vals in zip(partners, vals_list):\n            partner._children_sync(vals)\n            partner._handle_first_contact_creation()\n        return partners",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create_company",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def create_company(self):\n        self.ensure_one()\n        if self.company_name:\n            # Create parent company\n            values = dict(name=self.company_name, is_company=True, vat=self.vat)\n            values.update(self._update_fields_values(self._address_fields()))\n            new_company = self.create(values)\n            # Set new company as my parent\n            self.write({\n                'parent_id': new_company.id,\n                'child_ids': [Command.update(partner_id, dict(parent_id=new_company.id)) for partner_id in self.child_ids.ids]\n            })\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "open_commercial_entity",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def open_commercial_entity(self):\n        \"\"\" Utility method used to add an \"Open Company\" button in partner views \"\"\"\n        self.ensure_one()\n        return {'type': 'ir.actions.act_window',\n                'res_model': 'res.partner',\n                'view_mode': 'form',\n                'res_id': self.commercial_partner_id.id,\n                'target': 'current',\n                }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "open_parent",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def open_parent(self):\n        \"\"\" Utility method used to add an \"Open Parent\" button in partner views \"\"\"\n        self.ensure_one()\n        address_form_id = self.env.ref('base.view_partner_address_form').id\n        return {'type': 'ir.actions.act_window',\n                'res_model': 'res.partner',\n                'view_mode': 'form',\n                'views': [(address_form_id, 'form')],\n                'res_id': self.parent_id.id,\n                'target': 'new',\n                }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_display_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_display_name(self):\n        for partner in self:\n            name = partner.with_context(lang=self.env.lang)._get_complete_name()\n            if partner._context.get('show_address'):\n                name = name + \"\\n\" + partner._display_address(without_company=True)\n            name = re.sub(r'\\s+\\n', '\\n', name)\n            if partner._context.get('partner_show_db_id'):\n                name = f\"{name} ({partner.id})\"\n            if partner._context.get('address_inline'):\n                splitted_names = name.split(\"\\n\")\n                name = \", \".join([n for n in splitted_names if n.strip()])\n            if partner._context.get('show_email') and partner.email:\n                name = f\"{name} <{partner.email}>\"\n            if partner._context.get('show_vat') and partner.vat:\n                name = f\"{name}  {partner.vat}\"\n\n            partner.display_name = name.strip()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "name_create",
          "params": [
            "self",
            "name"
          ],
          "decorators": [],
          "source": "def name_create(self, name):\n        \"\"\" Override of orm's name_create method for partners. The purpose is\n            to handle some basic formats to create partners using the\n            name_create.\n            If only an email address is received and that the regex cannot find\n            a name, the name will have the email value.\n            If 'force_email' key in context: must find the email address. \"\"\"\n        default_type = self._context.get('default_type')\n        if default_type and default_type not in self._fields['type'].get_values(self.env):\n            context = dict(self._context)\n            context.pop('default_type')\n            self = self.with_context(context)\n        name, email_normalized = tools.parse_contact_from_email(name)\n        if self._context.get('force_email') and not email_normalized:\n            raise ValidationError(_(\"Couldn't create contact without email address!\"))\n\n        create_values = {self._rec_name: name or email_normalized}\n        if email_normalized:  # keep default_email in context\n            create_values['email'] = email_normalized\n        partner = self.create(create_values)\n        return partner.id, partner.display_name",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "find_or_create",
          "params": [
            "self",
            "email",
            "assert_valid_email=False"
          ],
          "decorators": [],
          "source": "def find_or_create(self, email, assert_valid_email=False):\n        \"\"\" Find a partner with the given ``email`` or use :py:method:`~.name_create`\n        to create a new one.\n\n        :param str email: email-like string, which should contain at least one email,\n            e.g. ``\"Raoul Grosbedon <r.g@grosbedon.fr>\"``\n        :param boolean assert_valid_email: raise if no valid email is found\n        :return: newly created record\n        \"\"\"\n        if not email:\n            raise ValueError(_('An email is required for find_or_create to work'))\n\n        parsed_name, parsed_email_normalized = tools.parse_contact_from_email(email)\n        if not parsed_email_normalized and assert_valid_email:\n            raise ValueError(_('A valid email is required for find_or_create to work properly.'))\n\n        partners = self.search([('email', '=ilike', parsed_email_normalized)], limit=1)\n        if partners:\n            return partners\n\n        create_values = {self._rec_name: parsed_name or parsed_email_normalized}\n        if parsed_email_normalized:  # keep default_email in context\n            create_values['email'] = parsed_email_normalized\n        return self.create(create_values)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_gravatar_image",
          "params": [
            "self",
            "email"
          ],
          "decorators": [],
          "source": "def _get_gravatar_image(self, email):\n        email_hash = hashlib.md5(email.lower().encode('utf-8')).hexdigest()\n        url = \"https://www.gravatar.com/avatar/\" + email_hash\n        try:\n            res = requests.get(url, params={'d': '404', 's': '128'}, timeout=5)\n            if res.status_code != requests.codes.ok:\n                return False\n        except requests.exceptions.ConnectionError as e:\n            return False\n        except requests.exceptions.Timeout as e:\n            return False\n        return base64.b64encode(res.content)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_email_send",
          "params": [
            "self",
            "email_from",
            "subject",
            "body",
            "on_error=None"
          ],
          "decorators": [],
          "source": "def _email_send(self, email_from, subject, body, on_error=None):\n        warnings.warn(\"Partner._email_send has not done anything but raise errors since 15.0\", stacklevel=2, category=DeprecationWarning)\n        return True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "address_get",
          "params": [
            "self",
            "adr_pref=None"
          ],
          "decorators": [],
          "source": "def address_get(self, adr_pref=None):\n        \"\"\" Find contacts/addresses of the right type(s) by doing a depth-first-search\n        through descendants within company boundaries (stop at entities flagged ``is_company``)\n        then continuing the search at the ancestors that are within the same company boundaries.\n        Defaults to partners of type ``'default'`` when the exact type is not found, or to the\n        provided partner itself if no type ``'default'`` is found either. \"\"\"\n        adr_pref = set(adr_pref or [])\n        if 'contact' not in adr_pref:\n            adr_pref.add('contact')\n        result = {}\n        visited = set()\n        for partner in self:\n            current_partner = partner\n            while current_partner:\n                to_scan = [current_partner]\n                # Scan descendants, DFS\n                while to_scan:\n                    record = to_scan.pop(0)\n                    visited.add(record)\n                    if record.type in adr_pref and not result.get(record.type):\n                        result[record.type] = record.id\n                    if len(result) == len(adr_pref):\n                        return result\n                    to_scan = [c for c in record.child_ids\n                                 if c not in visited\n                                 if not c.is_company] + to_scan\n\n                # Continue scanning at ancestor if current_partner is not a commercial entity\n                if current_partner.is_company or not current_partner.parent_id:\n                    break\n                current_partner = current_partner.parent_id\n\n        # default to type 'contact' or the partner itself\n        default = result.get('contact', self.id or False)\n        for adr_type in adr_pref:\n            result[adr_type] = result.get(adr_type) or default\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "view_header_get",
          "params": [
            "self",
            "view_id",
            "view_type"
          ],
          "decorators": [],
          "source": "def view_header_get(self, view_id, view_type):\n        if self.env.context.get('category_id'):\n            return  _(\n                'Partners: %(category)s',\n                category=self.env['res.partner.category'].browse(self.env.context['category_id']).name,\n            )\n        return super().view_header_get(view_id, view_type)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "main_partner",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def main_partner(self):\n        ''' Return the main partner '''\n        return self.env.ref('base.main_partner')",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_default_address_format",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_default_address_format(self):\n        return \"%(street)s\\n%(street2)s\\n%(city)s %(state_code)s %(zip)s\\n%(country_name)s\"",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_address_format",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_address_format(self):\n        return self.country_id.address_format or self._get_default_address_format()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_prepare_display_address",
          "params": [
            "self",
            "without_company=False"
          ],
          "decorators": [],
          "source": "def _prepare_display_address(self, without_company=False):\n        # get the information that will be injected into the display format\n        # get the address format\n        address_format = self._get_address_format()\n        args = defaultdict(str, {\n            'state_code': self.state_id.code or '',\n            'state_name': self.state_id.name or '',\n            'country_code': self.country_id.code or '',\n            'country_name': self._get_country_name(),\n            'company_name': self.commercial_company_name or '',\n        })\n        for field in self._formatting_address_fields():\n            args[field] = self[field] or ''\n        if without_company:\n            args['company_name'] = ''\n        elif self.commercial_company_name:\n            address_format = '%(company_name)s\\n' + address_format\n        return address_format, args",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_display_address",
          "params": [
            "self",
            "without_company=False"
          ],
          "decorators": [],
          "source": "def _display_address(self, without_company=False):\n        '''\n        The purpose of this function is to build and return an address formatted accordingly to the\n        standards of the country where it belongs.\n\n        :param without_company: if address contains company\n        :returns: the address formatted in a display that fit its country habits (or the default ones\n            if not country is specified)\n        :rtype: string\n        '''\n        address_format, args = self._prepare_display_address(without_company)\n        return address_format % args",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_display_address_depends",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _display_address_depends(self):\n        # field dependencies of method _display_address()\n        return self._formatting_address_fields() + [\n            'country_id', 'company_name', 'state_id',\n        ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_import_templates",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_import_templates(self):\n        return [{\n            'label': _('Import Template for Customers'),\n            'template': '/base/static/xls/res_partner.xlsx'\n        }]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_import_consistency",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def _check_import_consistency(self, vals_list):\n        \"\"\"\n        The values created by an import are generated by a name search, field by field.\n        As a result there is no check that the field values are consistent with each others.\n        We check that if the state is given a value, it does belong to the given country, or we remove it.\n        \"\"\"\n        States = self.env['res.country.state']\n        states_ids = {vals['state_id'] for vals in vals_list if vals.get('state_id')}\n        state_to_country = States.search_read([('id', 'in', list(states_ids))], ['country_id'])\n        for vals in vals_list:\n            if vals.get('state_id'):\n                country_id = next(c['country_id'][0] for c in state_to_country if c['id'] == vals.get('state_id'))\n                state = States.browse(vals['state_id'])\n                if state.country_id.id != country_id:\n                    state_domain = [('code', '=', state.code),\n                                    ('country_id', '=', country_id)]\n                    state = States.search(state_domain, limit=1)\n                    vals['state_id'] = state.id  # replace state or remove it if not found",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_country_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_country_name(self):\n        return self.country_id.name or ''",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_all_addr",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_all_addr(self):\n        self.ensure_one()\n        return [{\n            'contact_type': self.street,\n            'street': self.street,\n            'zip': self.zip,\n            'city': self.city,\n            'country': self.country_id.code,\n        }]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "python",
          "name": "_check_parent_id",
          "definition": "@api.constrains('parent_id')\n    def _check_parent_id(self):\n        if not self._check_recursion():\n            raise ValidationError(_('You cannot create recursive Partner hierarchies.'))",
          "message": "'parent_id'"
        },
        {
          "type": "python",
          "name": "_check_barcode_unicity",
          "definition": "@api.constrains('barcode')\n    def _check_barcode_unicity(self):\n        for partner in self:\n            if partner.barcode and self.env['res.partner'].search_count([('barcode', '=', partner.barcode)]) > 1:\n                raise ValidationError(_('Another partner already has this barcode'))",
          "message": "'barcode'"
        }
      ],
      "accessRules": [
        {
          "name": "default_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_address_fields (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_formatting_address_fields (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_commercial_fields (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "name_create (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "view_header_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_default_address_format (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_address_format (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_import_templates (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_check_import_consistency (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Partner"
    },
    {
      "name": "res.partner.industry",
      "description": "Industry",
      "fields": [
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "full_name",
          "type": "Char"
        },
        {
          "name": "active",
          "type": "Boolean"
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ResPartnerIndustry"
    },
    {
      "name": "res.groups",
      "description": "Access Groups",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        },
        {
          "name": "users",
          "type": "Many2many",
          "relation": "res.users"
        },
        {
          "name": "model_access",
          "type": "One2many",
          "relation": "ir.model.access",
          "string": "Access Controls"
        },
        {
          "name": "rule_groups",
          "type": "Many2many",
          "relation": "ir.rule",
          "string": "Rules"
        },
        {
          "name": "menu_access",
          "type": "Many2many",
          "relation": "ir.ui.menu",
          "string": "Access Menu"
        },
        {
          "name": "view_access",
          "type": "Many2many",
          "relation": "ir.ui.view",
          "string": "Views"
        },
        {
          "name": "comment",
          "type": "Text"
        },
        {
          "name": "category_id",
          "type": "Many2one",
          "relation": "ir.module.category",
          "string": "Application"
        },
        {
          "name": "color",
          "type": "Integer",
          "string": "Color Index"
        },
        {
          "name": "full_name",
          "type": "Char",
          "string": "Group Name"
        },
        {
          "name": "share",
          "type": "Boolean",
          "string": "Share Group",
          "help": "Group created to set access rights for sharing data with some users."
        }
      ],
      "methods": [
        {
          "name": "_check_one_user_type",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_one_user_type(self):\n        self.users._check_one_user_type()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_except_settings_group",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_except_settings_group(self):\n        classified = self.env['res.config.settings']._get_classified_fields()\n        for _name, _groups, implied_group in classified['group']:\n            if implied_group.id in self.ids:\n                raise ValidationError(_('You cannot delete a group linked with a settings field.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_full_name",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_full_name(self):\n        # Important: value must be stored in environment of group, not group1!\n        for group, group1 in zip(self, self.sudo()):\n            if group1.category_id:\n                group.full_name = '%s / %s' % (group1.category_id.name, group1.name)\n            else:\n                group.full_name = group1.name",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search_full_name",
          "params": [
            "self",
            "operator",
            "operand"
          ],
          "decorators": [],
          "source": "def _search_full_name(self, operator, operand):\n        lst = True\n        if isinstance(operand, bool):\n            return [('name', operator, operand)]\n        if isinstance(operand, str):\n            lst = False\n            operand = [operand]\n        where = []\n        for group in operand:\n            values = [v for v in group.split('/') if v]\n            group_name = values.pop().strip()\n            category_name = values and '/'.join(values).strip() or group_name\n            group_domain = [('name', operator, lst and [group_name] or group_name)]\n            category_ids = self.env['ir.module.category'].sudo()._search(\n                [('name', operator, [category_name] if lst else category_name)])\n            category_domain = [('category_id', 'in', category_ids)]\n            if operator in expression.NEGATIVE_TERM_OPERATORS and not values:\n                category_domain = expression.OR([category_domain, [('category_id', '=', False)]])\n            if (operator in expression.NEGATIVE_TERM_OPERATORS) == (not values):\n                sub_where = expression.AND([group_domain, category_domain])\n            else:\n                sub_where = expression.OR([group_domain, category_domain])\n            if operator in expression.NEGATIVE_TERM_OPERATORS:\n                where = expression.AND([where, sub_where])\n            else:\n                where = expression.OR([where, sub_where])\n        return where",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search",
          "params": [
            "self",
            "domain",
            "offset=0",
            "limit=None",
            "order=None",
            "access_rights_uid=None"
          ],
          "decorators": [],
          "source": "def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):\n        # add explicit ordering if search is sorted on full_name\n        if order and order.startswith('full_name'):\n            groups = super().search(domain)\n            groups = groups.sorted('full_name', reverse=order.endswith('DESC'))\n            groups = groups[offset:offset+limit] if limit else groups[offset:]\n            return groups._as_query(order)\n        return super()._search(domain, offset, limit, order, access_rights_uid)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        self.ensure_one()\n        chosen_name = default.get('name') if default else ''\n        default_name = chosen_name or _('%s (copy)', self.name)\n        default = dict(default or {}, name=default_name)\n        return super(Groups, self).copy(default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "vals"
          ],
          "decorators": [],
          "source": "def write(self, vals):\n        if 'name' in vals:\n            if vals['name'].startswith('-'):\n                raise UserError(_('The name of the group can not start with \"-\"'))\n        # invalidate caches before updating groups, since the recomputation of\n        # field 'share' depends on method has_group()\n        # DLE P139\n        if self.ids:\n            self.env['ir.model.access'].call_cache_clearing_methods()\n        return super(Groups, self).write(vals)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_ensure_xml_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _ensure_xml_id(self):\n        \"\"\"Return the groups external identifiers, creating the external identifier for groups missing one\"\"\"\n        result = self.get_external_id()\n        missings = {group_id: f'__custom__.group_{group_id}' for group_id, ext_id in result.items() if not ext_id}\n        if missings:\n            self.env['ir.model.data'].sudo().create(\n                [\n                    {\n                        'name': name.split('.')[1],\n                        'model': 'res.groups',\n                        'res_id': group_id,\n                        'module': name.split('.')[0],\n                    }\n                    for group_id, name in missings.items()\n                ]\n            )\n            result.update(missings)\n\n        return result",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "name_uniq",
          "definition": "unique (category_id, name)",
          "message": "The name of the group must be unique within an application!"
        },
        {
          "type": "python",
          "name": "_check_one_user_type",
          "definition": "@api.constrains('users')\n    def _check_one_user_type(self):\n        self.users._check_one_user_type()",
          "message": "'users'"
        }
      ],
      "accessRules": [
        {
          "name": "_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Groups"
    },
    {
      "name": "res.users.log",
      "description": "Users Log",
      "fields": [],
      "methods": [
        {
          "name": "_gc_user_logs",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _gc_user_logs(self):\n        self._cr.execute(\"\"\"\n            DELETE FROM res_users_log log1 WHERE EXISTS (\n                SELECT 1 FROM res_users_log log2\n                WHERE log1.create_uid = log2.create_uid\n                AND log1.create_date < log2.create_date\n            )\n        \"\"\")\n        _logger.info(\"GC'd %d user log entries\", self._cr.rowcount)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "ResUsersLog"
    },
    {
      "name": "res.users",
      "description": "User",
      "fields": [
        {
          "name": "partner_id",
          "type": "Many2one",
          "relation": "res.partner",
          "required": true,
          "string": "Related Partner",
          "help": "Partner-related data of the user"
        },
        {
          "name": "login",
          "type": "Char",
          "required": true,
          "help": "Used to log into the system"
        },
        {
          "name": "password",
          "type": "Char",
          "help": "Keep empty if you don"
        },
        {
          "name": "new_password",
          "type": "Char",
          "string": "Set Password",
          "help": "Specify a value only when creating a user or if you"
        },
        {
          "name": "signature",
          "type": "Html",
          "string": "Email Signature"
        },
        {
          "name": "active",
          "type": "Boolean"
        },
        {
          "name": "active_partner",
          "type": "Boolean",
          "readonly": true,
          "string": "Partner is Active"
        },
        {
          "name": "action_id",
          "type": "Many2one",
          "relation": "ir.actions.actions",
          "string": "Home Action",
          "help": "If specified, this action will be opened at log on for this user, in addition to the standard menu."
        },
        {
          "name": "groups_id",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Groups"
        },
        {
          "name": "log_ids",
          "type": "One2many",
          "relation": "res.users.log",
          "string": "User log entries"
        },
        {
          "name": "login_date",
          "type": "Datetime",
          "string": "Latest authentication"
        },
        {
          "name": "share",
          "type": "Boolean",
          "string": "Share User",
          "help": "External user with limited access, created only for the purpose of sharing data."
        },
        {
          "name": "companies_count",
          "type": "Integer",
          "string": "Number of Companies"
        },
        {
          "name": "tz_offset",
          "type": "Char",
          "string": "Timezone offset"
        },
        {
          "name": "res_users_settings_ids",
          "type": "One2many",
          "relation": "res.users.settings"
        },
        {
          "name": "res_users_settings_id",
          "type": "Many2one",
          "relation": "res.users.settings",
          "string": "Settings"
        },
        {
          "name": "company_id",
          "type": "Many2one",
          "relation": "res.company",
          "required": true,
          "string": "Company",
          "help": "The default company for this user."
        },
        {
          "name": "company_ids",
          "type": "Many2many",
          "relation": "res.company",
          "string": "Companies"
        },
        {
          "name": "name",
          "type": "Char"
        },
        {
          "name": "email",
          "type": "Char"
        },
        {
          "name": "accesses_count",
          "type": "Integer",
          "help": "Number of access rights that apply to the current user"
        },
        {
          "name": "rules_count",
          "type": "Integer",
          "help": "Number of record rules that apply to the current user"
        },
        {
          "name": "groups_count",
          "type": "Integer",
          "help": "Number of groups that apply to the current user"
        }
      ],
      "methods": [
        {
          "name": "_check_company_domain",
          "params": [
            "self",
            "companies"
          ],
          "decorators": [],
          "source": "def _check_company_domain(self, companies):\n        if not companies:\n            return []\n        return [('company_ids', 'in', models.to_company_ids(companies))]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "SELF_READABLE_FIELDS",
          "params": [
            "self"
          ],
          "decorators": [
            "@property"
          ],
          "source": "@property\n    def SELF_READABLE_FIELDS(self):\n        \"\"\" The list of fields a user can read on their own user record.\n        In order to add fields, please override this property on model extensions.\n        \"\"\"\n        return [\n            'signature', 'company_id', 'login', 'email', 'name', 'image_1920',\n            'image_1024', 'image_512', 'image_256', 'image_128', 'lang', 'tz',\n            'tz_offset', 'groups_id', 'partner_id', 'write_date', 'action_id',\n            'avatar_1920', 'avatar_1024', 'avatar_512', 'avatar_256', 'avatar_128',\n            'share',\n        ]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "SELF_WRITEABLE_FIELDS",
          "params": [
            "self"
          ],
          "decorators": [
            "@property"
          ],
          "source": "@property\n    def SELF_WRITEABLE_FIELDS(self):\n        \"\"\" The list of fields a user can write on their own user record.\n        In order to add fields, please override this property on model extensions.\n        \"\"\"\n        return ['signature', 'action_id', 'company_id', 'email', 'name', 'image_1920', 'lang', 'tz']",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "_default_groups",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _default_groups(self):\n        \"\"\"Default groups for employees\n\n        All the groups of the Template User\n        \"\"\"\n        default_user = self.env.ref('base.default_user', raise_if_not_found=False)\n        return default_user.sudo().groups_id if default_user else []\n\n    partner_id = fields.Many2one('res.partner', required=True, ondelete='restrict', auto_join=True, index=True,\n        string='Related Partner', help='Partner-related data of the user')\n    login = fields.Char(required=True, help=\"Used to log into the system\")\n    password = fields.Char(\n        compute='_compute_password', inverse='_set_password', copy=False,\n        help=\"Keep empty if you don't want the user to be able to connect on the system.\")\n    new_password = fields.Char(string='Set Password',\n        compute='_compute_password', inverse='_set_new_password',\n        help=\"Specify a value only when creating a user or if you're \"\\\n             \"changing the user's password, otherwise leave empty. After \"\\\n             \"a change of password, the user has to login again.\")\n    signature = fields.Html(string=\"Email Signature\", compute='_compute_signature', readonly=False, store=True)\n    active = fields.Boolean(default=True)\n    active_partner = fields.Boolean(related='partner_id.active', readonly=True, string=\"Partner is Active\")\n    action_id = fields.Many2one('ir.actions.actions', string='Home Action',\n        help=\"If specified, this action will be opened at log on for this user, in addition to the standard menu.\")\n    groups_id = fields.Many2many('res.groups', 'res_groups_users_rel', 'uid', 'gid', string='Groups', default=lambda s: s._default_groups())\n    log_ids = fields.One2many('res.users.log', 'create_uid', string='User log entries')\n    login_date = fields.Datetime(related='log_ids.create_date', string='Latest authentication', readonly=False)\n    share = fields.Boolean(compute='_compute_share', compute_sudo=True, string='Share User', store=True,\n         help=\"External user with limited access, created only for the purpose of sharing data.\")\n    companies_count = fields.Integer(compute='_compute_companies_count', string=\"Number of Companies\")\n    tz_offset = fields.Char(compute='_compute_tz_offset', string='Timezone offset')\n    res_users_settings_ids = fields.One2many('res.users.settings', 'user_id')\n    # Provide a target for relateds that is not a x2Many field.\n    res_users_settings_id = fields.Many2one('res.users.settings', string=\"Settings\", compute='_compute_res_users_settings_id', search='_search_res_users_settings_id')\n\n    # Special behavior for this field: res.company.search() will only return the companies\n    # available to the current user (should be the user's companies?), when the user_preference\n    # context is set.\n    company_id = fields.Many2one('res.company', string='Company', required=True, default=lambda self: self.env.company.id,\n        help='The default company for this user.', context={'user_preference': True})\n    company_ids = fields.Many2many('res.company', 'res_company_users_rel', 'user_id', 'cid',\n        string='Companies', default=lambda self: self.env.company.ids)\n\n    # overridden inherited fields to bypass access rights, in case you have\n    # access to the user but not its corresponding partner\n    name = fields.Char(related='partner_id.name', inherited=True, readonly=False)\n    email = fields.Char(related='partner_id.email', inherited=True, readonly=False)\n\n    accesses_count = fields.Integer('# Access Rights', help='Number of access rights that apply to the current user',\n                                    compute='_compute_accesses_count', compute_sudo=True)\n    rules_count = fields.Integer('# Record Rules', help='Number of record rules that apply to the current user',\n                                 compute='_compute_accesses_count', compute_sudo=True)\n    groups_count = fields.Integer('# Groups', help='Number of groups that apply to the current user',\n                                  compute='_compute_accesses_count', compute_sudo=True)\n\n    _sql_constraints = [\n        ('login_key', 'UNIQUE (login)', 'You can not have two users with the same login!')\n    ]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def init(self):\n        cr = self.env.cr\n\n        # allow setting plaintext passwords via SQL and have them\n        # automatically encrypted at startup: look for passwords which don't\n        # match the \"extended\" MCF and pass those through passlib.\n        # Alternative: iterate on *all* passwords and use CryptContext.identify\n        cr.execute(r\"\"\"\n        SELECT id, password FROM res_users\n        WHERE password IS NOT NULL\n          AND password !~ '^\\$[^$]+\\$[^$]+\\$.'\n        \"\"\")\n        if self.env.cr.rowcount:\n            Users = self.sudo()\n            for uid, pw in cr.fetchall():\n                Users.browse(uid).password = pw",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_password",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _set_password(self):\n        ctx = self._crypt_context()\n        for user in self:\n            self._set_encrypted_password(user.id, ctx.hash(user.password))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_encrypted_password",
          "params": [
            "self",
            "uid",
            "pw"
          ],
          "decorators": [],
          "source": "def _set_encrypted_password(self, uid, pw):\n        assert self._crypt_context().identify(pw) != 'plaintext'\n\n        self.env.cr.execute(\n            'UPDATE res_users SET password=%s WHERE id=%s',\n            (pw, uid)\n        )\n        self.browse(uid).invalidate_recordset(['password'])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_credentials",
          "params": [
            "self",
            "password",
            "env"
          ],
          "decorators": [],
          "source": "def _check_credentials(self, password, env):\n        \"\"\" Validates the current user's password.\n\n        Override this method to plug additional authentication methods.\n\n        Overrides should:\n\n        * call `super` to delegate to parents for credentials-checking\n        * catch AccessDenied and perform their own checking\n        * (re)raise AccessDenied if the credentials are still invalid\n          according to their own validation method\n\n        When trying to check for credentials validity, call _check_credentials\n        instead.\n        \"\"\"\n        \"\"\" Override this method to plug additional authentication methods\"\"\"\n        assert password\n        self.env.cr.execute(\n            \"SELECT COALESCE(password, '') FROM res_users WHERE id=%s\",\n            [self.env.user.id]\n        )\n        [hashed] = self.env.cr.fetchone()\n        valid, replacement = self._crypt_context()\\\n            .verify_and_update(password, hashed)\n        if replacement is not None:\n            self._set_encrypted_password(self.env.user.id, replacement)\n        if not valid:\n            raise AccessDenied()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_password",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_password(self):\n        for user in self:\n            user.password = ''\n            user.new_password = ''",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_set_new_password",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _set_new_password(self):\n        for user in self:\n            if not user.new_password:\n                # Do not update the password if no value is provided, ignore silently.\n                # For example web client submits False values for all empty fields.\n                continue\n            if user == self.env.user:\n                # To change their own password, users must use the client-specific change password wizard,\n                # so that the new password is immediately used for further RPC requests, otherwise the user\n                # will face unexpected 'Access Denied' exceptions.\n                raise UserError(_('Please use the change password wizard (in User Preferences or User menu) to change your own password.'))\n            else:\n                user.password = user.new_password",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_signature",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_signature(self):\n        for user in self.filtered(lambda user: user.name and is_html_empty(user.signature)):\n            user.signature = Markup('<p>--<br />%s</p>') % user['name']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_share",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_share(self):\n        user_group_id = self.env['ir.model.data']._xmlid_to_res_id('base.group_user')\n        internal_users = self.filtered_domain([('groups_id', 'in', [user_group_id])])\n        internal_users.share = False\n        (self - internal_users).share = True",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_companies_count",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_companies_count(self):\n        self.companies_count = self.env['res.company'].sudo().search_count([])",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_tz_offset",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_tz_offset(self):\n        for user in self:\n            user.tz_offset = datetime.datetime.now(pytz.timezone(user.tz or 'GMT')).strftime('%z')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_accesses_count",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_accesses_count(self):\n        for user in self:\n            groups = user.groups_id\n            user.accesses_count = len(groups.model_access)\n            user.rules_count = len(groups.rule_groups)\n            user.groups_count = len(groups)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_res_users_settings_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_res_users_settings_id(self):\n        for user in self:\n            user.res_users_settings_id = user.res_users_settings_ids and user.res_users_settings_ids[0]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search_res_users_settings_id",
          "params": [
            "self",
            "operator",
            "operand"
          ],
          "decorators": [],
          "source": "def _search_res_users_settings_id(self, operator, operand):\n        return [('res_users_settings_ids', operator, operand)]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "on_change_login",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def on_change_login(self):\n        if self.login and tools.single_email_re.match(self.login):\n            self.email = self.login",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "onchange_parent_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def onchange_parent_id(self):\n        return self.partner_id.onchange_parent_id()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_fetch_query",
          "params": [
            "self",
            "query",
            "fields"
          ],
          "decorators": [],
          "source": "def _fetch_query(self, query, fields):\n        records = super()._fetch_query(query, fields)\n        if not set(USER_PRIVATE_FIELDS).isdisjoint(field.name for field in fields):\n            if self.check_access_rights('write', raise_exception=False):\n                return records\n            for fname in USER_PRIVATE_FIELDS:\n                self.env.cache.update(records, self._fields[fname], repeat('********'))\n        return records",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_company",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_company(self):\n        for user in self.filtered(lambda u: u.active):\n            if user.company_id not in user.company_ids:\n                raise ValidationError(\n                    _('Company %(company_name)s is not in the allowed companies for user %(user_name)s (%(company_allowed)s).',\n                      company_name=user.company_id.name,\n                      user_name=user.name,\n                      company_allowed=', '.join(user.mapped('company_ids.name')))\n                )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_action_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_action_id(self):\n        action_open_website = self.env.ref('base.action_open_website', raise_if_not_found=False)\n        if action_open_website and any(user.action_id.id == action_open_website.id for user in self):\n            raise ValidationError(_('The \"App Switcher\" action cannot be selected as home action.'))\n        # We use sudo() because  \"Access rights\" admins can't read action models\n        for user in self.sudo():\n            if user.action_id.type == \"ir.actions.client\":\n                # Prevent using reload actions.\n                action = self.env[\"ir.actions.client\"].browse(user.action_id.id)  # magic\n                if action.tag == \"reload\":\n                    raise ValidationError(_('The \"%s\" action cannot be selected as home action.', action.name))\n\n            elif user.action_id.type == \"ir.actions.act_window\":\n                # Restrict actions that include 'active_id' in their context.\n                action = self.env[\"ir.actions.act_window\"].browse(user.action_id.id)  # magic\n                if not action.context:\n                    continue\n                if \"active_id\" in action.context:\n                    raise ValidationError(\n                        _('The action \"%s\" cannot be set as the home action because it requires a record to be selected beforehand.', action.name)\n                    )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_one_user_type",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_one_user_type(self):\n        \"\"\"We check that no users are both portal and users (same with public).\n           This could typically happen because of implied groups.\n        \"\"\"\n        user_types_category = self.env.ref('base.module_category_user_type', raise_if_not_found=False)\n        user_types_groups = self.env['res.groups'].search(\n            [('category_id', '=', user_types_category.id)]) if user_types_category else False\n        if user_types_groups:  # needed at install\n            if self._has_multiple_groups(user_types_groups.ids):\n                raise ValidationError(_('The user cannot have more than one user types.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_has_multiple_groups",
          "params": [
            "self",
            "group_ids"
          ],
          "decorators": [],
          "source": "def _has_multiple_groups(self, group_ids):\n        \"\"\"The method is not fast if the list of ids is very long;\n           so we rather check all users than limit to the size of the group\n        :param group_ids: list of group ids\n        :return: boolean: is there at least a user in at least 2 of the provided groups\n        \"\"\"\n        if group_ids:\n            args = [tuple(group_ids)]\n            if len(self.ids) == 1:\n                where_clause = \"AND r.uid = %s\"\n                args.append(self.id)\n            else:\n                where_clause = \"\"  # default; we check ALL users (actually pretty efficient)\n            query = \"\"\"\n                    SELECT 1 FROM res_groups_users_rel WHERE EXISTS(\n                        SELECT r.uid\n                        FROM res_groups_users_rel r\n                        WHERE r.gid IN %s\"\"\" + where_clause + \"\"\"\n                        GROUP BY r.uid HAVING COUNT(r.gid) > 1\n                    )\n            \"\"\"\n            self.env.cr.execute(query, args)\n            return bool(self.env.cr.fetchall())\n        else:\n            return False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "toggle_active",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def toggle_active(self):\n        for user in self:\n            if not user.active and not user.partner_id.active:\n                user.partner_id.toggle_active()\n        super(Users, self).toggle_active()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "onchange",
          "params": [
            "self",
            "values",
            "field_names",
            "fields_spec"
          ],
          "decorators": [],
          "source": "def onchange(self, values, field_names, fields_spec):\n        # Hacky fix to access fields in `SELF_READABLE_FIELDS` in the onchange logic.\n        # Put field values in the cache.\n        if self == self.env.user:\n            [self.sudo()[field_name] for field_name in self.SELF_READABLE_FIELDS]\n        return super().onchange(values, field_names, fields_spec)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "read",
          "params": [
            "self",
            "fields=None",
            "load='_classic_read'"
          ],
          "decorators": [],
          "source": "def read(self, fields=None, load='_classic_read'):\n        readable = self.SELF_READABLE_FIELDS\n        if fields and self == self.env.user and all(key in readable or key.startswith('context_') for key in fields):\n            # safe fields only, so we read as super-user to bypass access rights\n            self = self.sudo()\n        return super(Users, self).read(fields=fields, load=load)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "check_field_access_rights",
          "params": [
            "self",
            "operation",
            "field_names"
          ],
          "decorators": [],
          "source": "def check_field_access_rights(self, operation, field_names):\n        readable = self.SELF_READABLE_FIELDS\n        if field_names and self == self.env.user and all(key in readable or key.startswith('context_') for key in field_names):\n            # safe fields only, so we read as super-user to bypass access rights\n            self = self.sudo()\n        return super(Users, self).check_field_access_rights(operation, field_names)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_read_group_check_field_access_rights",
          "params": [
            "self",
            "field_names"
          ],
          "decorators": [],
          "source": "def _read_group_check_field_access_rights(self, field_names):\n        super()._read_group_check_field_access_rights(field_names)\n        if set(field_names).intersection(USER_PRIVATE_FIELDS):\n            raise AccessError(_(\"Invalid 'group by' parameter\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_search",
          "params": [
            "self",
            "domain",
            "offset=0",
            "limit=None",
            "order=None",
            "access_rights_uid=None"
          ],
          "decorators": [],
          "source": "def _search(self, domain, offset=0, limit=None, order=None, access_rights_uid=None):\n        if not self.env.su and domain:\n            domain_fields = {term[0] for term in domain if isinstance(term, (tuple, list))}\n            if domain_fields.intersection(USER_PRIVATE_FIELDS):\n                raise AccessError(_('Invalid search criterion'))\n        return super()._search(domain, offset, limit, order, access_rights_uid)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        users = super(Users, self).create(vals_list)\n        for user in users:\n            # if partner is global we keep it that way\n            if user.partner_id.company_id:\n                user.partner_id.company_id = user.company_id\n            user.partner_id.active = user.active\n            # Generate employee initals as avatar for internal users without image\n            if not user.image_1920 and not user.share and user.name:\n                user.image_1920 = user.partner_id._avatar_generate_svg()\n\n        return users",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_apply_groups_to_existing_employees",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _apply_groups_to_existing_employees(self):\n        \"\"\" Should new groups be added to existing employees?\n\n        If the template user is being modified, the groups should be applied to\n        every other base_user users\n        \"\"\"\n        default_user = self.env.ref('base.default_user', raise_if_not_found=False)\n        return default_user and default_user in self",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        if values.get('active') and SUPERUSER_ID in self._ids:\n            raise UserError(_(\"You cannot activate the superuser.\"))\n        if values.get('active') == False and self._uid in self._ids:\n            raise UserError(_(\"You cannot deactivate the user you're currently logged in as.\"))\n\n        if values.get('active'):\n            for user in self:\n                if not user.active and not user.partner_id.active:\n                    user.partner_id.toggle_active()\n        if self == self.env.user:\n            writeable = self.SELF_WRITEABLE_FIELDS\n            for key in list(values):\n                if not (key in writeable or key.startswith('context_')):\n                    break\n            else:\n                if 'company_id' in values:\n                    if values['company_id'] not in self.env.user.company_ids.ids:\n                        del values['company_id']\n                # safe fields only, so we write as super-user to bypass access rights\n                self = self.sudo()\n\n        old_groups = []\n        if 'groups_id' in values and self._apply_groups_to_existing_employees():\n            # if modify groups_id content, compute the delta of groups to apply\n            # the new ones to other existing users\n            old_groups = self._default_groups()\n\n        res = super(Users, self).write(values)\n\n        if old_groups:\n            # new elements in _default_groups() means new groups for default users\n            # that needs to be added to existing ones as well for consistency\n            added_groups = self._default_groups() - old_groups\n            if added_groups:\n                internal_users = self.env.ref('base.group_user').users - self\n                internal_users.write({'groups_id': [Command.link(gid) for gid in added_groups.ids]})\n\n        if 'company_id' in values:\n            for user in self:\n                # if partner is global we keep it that way\n                if user.partner_id.company_id and user.partner_id.company_id.id != values['company_id']:\n                    user.partner_id.write({'company_id': user.company_id.id})\n\n        if 'company_id' in values or 'company_ids' in values:\n            # Reset lazy properties `company` & `companies` on all envs,\n            # and also their _cache_key, which may depend on them.\n            # This is unlikely in a business code to change the company of a user and then do business stuff\n            # but in case it happens this is handled.\n            # e.g. `account_test_savepoint.py` `setup_company_data`, triggered by `test_account_invoice_report.py`\n            for env in list(self.env.transaction.envs):\n                if env.user in self:\n                    lazy_property.reset_all(env)\n                    env._cache_key.clear()\n\n        # clear caches linked to the users\n        if self.ids and 'groups_id' in values:\n            # DLE P139: Calling invalidate_cache on a new, well you lost everything as you wont be able to take it back from the cache\n            # `test_00_equipment_multicompany_user`\n            self.env['ir.model.access'].call_cache_clearing_methods()\n\n        # per-method / per-model caches have been removed so the various\n        # clear_cache/clear_caches methods pretty much just end up calling\n        # Registry.clear_cache\n        invalidation_fields = self._get_invalidation_fields()\n        if (invalidation_fields & values.keys()) or any(key.startswith('context_') for key in values):\n            self.env.registry.clear_cache()\n\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_unlink_except_master_data",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _unlink_except_master_data(self):\n        portal_user_template = self.env.ref('base.template_portal_user_id', False)\n        default_user_template = self.env.ref('base.default_user', False)\n        if SUPERUSER_ID in self.ids:\n            raise UserError(_('You can not remove the admin user as it is used internally for resources created by Odoo (updates, module installation, ...)'))\n        user_admin = self.env.ref('base.user_admin', raise_if_not_found=False)\n        if user_admin and user_admin in self:\n            raise UserError(_('You cannot delete the admin user because it is utilized in various places (such as security configurations,...). Instead, archive it.'))\n        self.env.registry.clear_cache()\n        if (portal_user_template and portal_user_template in self) or (default_user_template and default_user_template in self):\n            raise UserError(_('Deleting the template users is not allowed. Deleting this profile will compromise critical functionalities.'))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_name_search",
          "params": [
            "self",
            "name",
            "domain=None",
            "operator='ilike'",
            "limit=None",
            "order=None"
          ],
          "decorators": [],
          "source": "def _name_search(self, name, domain=None, operator='ilike', limit=None, order=None):\n        domain = domain or []\n        user_ids = []\n        if operator not in expression.NEGATIVE_TERM_OPERATORS:\n            if operator == 'ilike' and not (name or '').strip():\n                name_domain = []\n            else:\n                name_domain = [('login', '=', name)]\n            user_ids = self._search(expression.AND([name_domain, domain]), limit=limit, order=order)\n        if not user_ids:\n            user_ids = self._search(expression.AND([[('name', operator, name)], domain]), limit=limit, order=order)\n        return user_ids",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "copy",
          "params": [
            "self",
            "default=None"
          ],
          "decorators": [],
          "source": "def copy(self, default=None):\n        self.ensure_one()\n        default = dict(default or {})\n        if ('name' not in default) and ('partner_id' not in default):\n            default['name'] = _(\"%s (copy)\", self.name)\n        if 'login' not in default:\n            default['login'] = _(\"%s (copy)\", self.login)\n        return super(Users, self).copy(default)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "context_get",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def context_get(self):\n        user = self.env.user\n        # determine field names to read\n        name_to_key = {\n            name: name[8:] if name.startswith('context_') else name\n            for name in self._fields\n            if name.startswith('context_') or name in ('lang', 'tz')\n        }\n        # use read() to not read other fields: this must work while modifying\n        # the schema of models res.users or res.partner\n        values = user.read(list(name_to_key), load=False)[0]\n\n        context = {\n            key: values[name]\n            for name, key in name_to_key.items()\n        }\n\n        # ensure lang is set and available\n        # context > request > company > english > any lang installed\n        langs = [code for code, _ in self.env['res.lang'].get_installed()]\n        lang = context.get('lang')\n        if lang not in langs:\n            lang = request.best_lang if request else None\n            if lang not in langs:\n                lang = self.env.user.with_context(prefetch_fields=False).company_id.partner_id.lang\n                if lang not in langs:\n                    lang = DEFAULT_LANG\n                    if lang not in langs:\n                        lang = langs[0] if langs else DEFAULT_LANG\n        context['lang'] = lang\n\n        # ensure uid is set\n        context['uid'] = self.env.uid\n\n        return frozendict(context)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_company_ids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_company_ids(self):\n        # use search() instead of `self.company_ids` to avoid extra query for `active_test`\n        domain = [('active', '=', True), ('user_ids', 'in', self.id)]\n        return self.env['res.company'].search(domain)._ids",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_get",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_get(self):\n        return self.sudo().env.ref('base.action_res_users_my').read()[0]",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "check_super",
          "params": [
            "self",
            "passwd"
          ],
          "decorators": [],
          "source": "def check_super(self, passwd):\n        return check_super(passwd)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_invalidation_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_invalidation_fields(self):\n        return {\n            'groups_id', 'active', 'lang', 'tz', 'company_id', 'company_ids',\n            *USER_PRIVATE_FIELDS,\n            *self._get_session_token_fields()\n        }",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_last_login",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _update_last_login(self):\n        # only create new records to avoid any side-effect on concurrent transactions\n        # extra records will be deleted by the periodical garbage collection\n        self.env['res.users.log'].sudo().create({}) # populated by defaults",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_login_domain",
          "params": [
            "self",
            "login"
          ],
          "decorators": [],
          "source": "def _get_login_domain(self, login):\n        return [('login', '=', login)]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_email_domain",
          "params": [
            "self",
            "email"
          ],
          "decorators": [],
          "source": "def _get_email_domain(self, email):\n        return [('email', '=', email)]",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_login_order",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_login_order(self):\n        return self._order",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_login",
          "params": [
            "cls",
            "db",
            "login",
            "password",
            "user_agent_env"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def _login(cls, db, login, password, user_agent_env):\n        if not password:\n            raise AccessDenied()\n        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'\n        try:\n            with cls.pool.cursor() as cr:\n                self = api.Environment(cr, SUPERUSER_ID, {})[cls._name]\n                with self._assert_can_auth(user=login):\n                    user = self.search(self._get_login_domain(login), order=self._get_login_order(), limit=1)\n                    if not user:\n                        raise AccessDenied()\n                    user = user.with_user(user)\n                    user._check_credentials(password, user_agent_env)\n                    tz = request.httprequest.cookies.get('tz') if request else None\n                    if tz in pytz.all_timezones and (not user.tz or not user.login_date):\n                        # first login or missing tz -> set tz to browser tz\n                        user.tz = tz\n                    user._update_last_login()\n        except AccessDenied:\n            _logger.info(\"Login failed for db:%s login:%s from %s\", db, login, ip)\n            raise\n\n        _logger.info(\"Login successful for db:%s login:%s from %s\", db, login, ip)\n\n        return user.id",
          "isPrivate": true,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "authenticate",
          "params": [
            "cls",
            "db",
            "login",
            "password",
            "user_agent_env"
          ],
          "decorators": [
            "@classmethod"
          ],
          "source": "@classmethod\n    def authenticate(cls, db, login, password, user_agent_env):\n        \"\"\"Verifies and returns the user ID corresponding to the given\n          ``login`` and ``password`` combination, or False if there was\n          no matching user.\n           :param str db: the database on which user is trying to authenticate\n           :param str login: username\n           :param str password: user password\n           :param dict user_agent_env: environment dictionary describing any\n               relevant environment attributes\n        \"\"\"\n        uid = cls._login(db, login, password, user_agent_env=user_agent_env)\n        if user_agent_env and user_agent_env.get('base_location'):\n            with cls.pool.cursor() as cr:\n                env = api.Environment(cr, uid, {})\n                if env.user.has_group('base.group_system'):\n                    # Successfully logged in as system user!\n                    # Attempt to guess the web base url...\n                    try:\n                        base = user_agent_env['base_location']\n                        ICP = env['ir.config_parameter']\n                        if not ICP.get_param('web.base.url.freeze'):\n                            ICP.set_param('web.base.url', base)\n                    except Exception:\n                        _logger.exception(\"Failed to update web.base.url configuration parameter\")\n        return uid",
          "isPrivate": false,
          "isStatic": true,
          "isDecorated": true
        },
        {
          "name": "check",
          "params": [
            "cls",
            "db",
            "uid",
            "passwd"
          ],
          "decorators": [],
          "source": "def check(cls, db, uid, passwd):\n        \"\"\"Verifies that the given (uid, password) is authorized for the database ``db`` and\n           raise an exception if it is not.\"\"\"\n        if not passwd:\n            # empty passwords disallowed for obvious security reasons\n            raise AccessDenied()\n\n        with contextlib.closing(cls.pool.cursor()) as cr:\n            self = api.Environment(cr, uid, {})[cls._name]\n            with self._assert_can_auth(user=uid):\n                if not self.env.user.active:\n                    raise AccessDenied()\n                self._check_credentials(passwd, {'interactive': False})",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_session_token_fields",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_session_token_fields(self):\n        return {'id', 'login', 'password', 'active'}",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_compute_session_token",
          "params": [
            "self",
            "sid"
          ],
          "decorators": [],
          "source": "def _compute_session_token(self, sid):\n        \"\"\" Compute a session token given a session id and a user id \"\"\"\n        # retrieve the fields used to generate the session token\n        session_fields = ', '.join(sorted(self._get_session_token_fields()))\n        self.env.cr.execute(\"\"\"SELECT %s, (SELECT value FROM ir_config_parameter WHERE key='database.secret')\n                                FROM res_users\n                                WHERE id=%%s\"\"\" % (session_fields), (self.id,))\n        if self.env.cr.rowcount != 1:\n            self.env.registry.clear_cache()\n            return False\n        data_fields = self.env.cr.fetchone()\n        # generate hmac key\n        key = (u'%s' % (data_fields,)).encode('utf-8')\n        # hmac the session id\n        data = sid.encode('utf-8')\n        h = hmac.new(key, data, sha256)\n        # keep in the cache the token\n        return h.hexdigest()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "change_password",
          "params": [
            "self",
            "old_passwd",
            "new_passwd"
          ],
          "decorators": [],
          "source": "def change_password(self, old_passwd, new_passwd):\n        \"\"\"Change current user password. Old password must be provided explicitly\n        to prevent hijacking an existing user session, or for cases where the cleartext\n        password is not used to authenticate requests.\n\n        :return: True\n        :raise: odoo.exceptions.AccessDenied when old password is wrong\n        :raise: odoo.exceptions.UserError when new password is not set or empty\n        \"\"\"\n        if not old_passwd:\n            raise AccessDenied()\n\n        # alternatively: use identitycheck wizard?\n        self._check_credentials(old_passwd, {'interactive': True})\n\n        # use self.env.user here, because it has uid=SUPERUSER_ID\n        self.env.user._change_password(new_passwd)\n        return True",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_change_password",
          "params": [
            "self",
            "new_passwd"
          ],
          "decorators": [],
          "source": "def _change_password(self, new_passwd):\n        new_passwd = new_passwd.strip()\n        if not new_passwd:\n            raise UserError(_(\"Setting empty passwords is not allowed for security reasons!\"))\n\n        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'\n        _logger.info(\n            \"Password change for %r (#%d) by %r (#%d) from %s\",\n             self.login, self.id,\n             self.env.user.login, self.env.user.id,\n             ip\n        )\n\n        self.password = new_passwd",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_deactivate_portal_user",
          "params": [
            "self",
            "**post"
          ],
          "decorators": [],
          "source": "def _deactivate_portal_user(self, **post):\n        \"\"\"Try to remove the current portal user.\n\n        This is used to give the opportunity to portal users to de-activate their accounts.\n        Indeed, as the portal users can easily create accounts, they will sometimes wish\n        it removed because they don't use this Odoo portal anymore.\n\n        Before this feature, they would have to contact the website or the support to get\n        their account removed, which could be tedious.\n        \"\"\"\n        non_portal_users = self.filtered(lambda user: not user.share)\n        if non_portal_users:\n            raise AccessDenied(_(\n                'Only the portal users can delete their accounts. '\n                'The user(s) %s can not be deleted.',\n                ', '.join(non_portal_users.mapped('name')),\n            ))\n\n        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'\n\n        res_users_deletion_values = []\n\n        for user in self:\n            _logger.info(\n                'Account deletion asked for \"%s\" (#%i) from %s. '\n                'Archive the user and remove login information.',\n                user.login, user.id, ip,\n            )\n\n            user.write({\n                'login': f'__deleted_user_{user.id}_{time.time()}',\n                'password': '',\n            })\n            user.api_key_ids._remove()\n\n            res_users_deletion_values.append({\n                'user_id': user.id,\n                'state': 'todo',\n            })\n\n        # Here we try to archive the user / partner, and then add the user in a deletion\n        # queue, to remove it from the database. As the deletion might fail (if the\n        # partner is related to an invoice e.g.) it's important to archive it here.\n        try:\n            # A user can not self-deactivate\n            self.with_user(SUPERUSER_ID).action_archive()\n        except Exception:\n            pass\n        try:\n            self.partner_id.action_archive()\n        except Exception:\n            pass\n        # Add users in the deletion queue\n        self.env['res.users.deletion'].create(res_users_deletion_values)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "preference_save",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def preference_save(self):\n        return {\n            'type': 'ir.actions.client',\n            'tag': 'reload_context',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "preference_change_password",
          "params": [
            "self"
          ],
          "decorators": [
            "@check_identity"
          ],
          "source": "@check_identity\n    def preference_change_password(self):\n        return {\n            'type': 'ir.actions.act_window',\n            'target': 'new',\n            'res_model': 'change.password.own',\n            'view_mode': 'form',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "action_revoke_all_devices",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_revoke_all_devices(self):\n        ctx = dict(self.env.context, dialog_size='medium')\n        return {\n            'name': _('Log out from all devices?'),\n            'type': 'ir.actions.act_window',\n            'target': 'new',\n            'res_model': 'res.users.identitycheck',\n            'view_mode': 'form',\n            'view_id': self.env.ref('base.res_users_identitycheck_view_form_revokedevices').id,\n            'context': ctx,\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "has_group",
          "params": [
            "self",
            "group_ext_id"
          ],
          "decorators": [],
          "source": "def has_group(self, group_ext_id):\n        # use singleton's id if called on a non-empty recordset, otherwise\n        # context uid\n        uid = self.id\n        if uid and uid != self._uid:\n            self = self.with_user(uid)\n        return self._has_group(group_ext_id)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_has_group",
          "params": [
            "self",
            "group_ext_id"
          ],
          "decorators": [],
          "source": "def _has_group(self, group_ext_id):\n        \"\"\"Checks whether user belongs to given group.\n\n        :param str group_ext_id: external ID (XML ID) of the group.\n           Must be provided in fully-qualified form (``module.ext_id``), as there\n           is no implicit module to use..\n        :return: True if the current user is a member of the group with the\n           given external ID (XML ID), else False.\n        \"\"\"\n        assert group_ext_id and '.' in group_ext_id, \"External ID '%s' must be fully qualified\" % group_ext_id\n        module, ext_id = group_ext_id.split('.')\n        self._cr.execute(\"\"\"SELECT 1 FROM res_groups_users_rel WHERE uid=%s AND gid IN\n                            (SELECT res_id FROM ir_model_data WHERE module=%s AND name=%s AND model='res.groups')\"\"\",\n                         (self._uid, module, ext_id))\n        return bool(self._cr.fetchone())",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_action_show",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _action_show(self):\n        \"\"\"If self is a singleton, directly access the form view. If it is a recordset, open a tree view\"\"\"\n        view_id = self.env.ref('base.view_users_form').id\n        action = {\n            'type': 'ir.actions.act_window',\n            'res_model': 'res.users',\n            'context': {'create': False},\n        }\n        if len(self) > 1:\n            action.update({\n                'name': _('Users'),\n                'view_mode': 'list,form',\n                'views': [[None, 'list'], [view_id, 'form']],\n                'domain': [('id', 'in', self.ids)],\n            })\n        else:\n            action.update({\n                'view_mode': 'form',\n                'views': [[view_id, 'form']],\n                'res_id': self.id,\n            })\n        return action",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_show_groups",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_show_groups(self):\n        self.ensure_one()\n        return {\n            'name': _('Groups'),\n            'view_mode': 'tree,form',\n            'res_model': 'res.groups',\n            'type': 'ir.actions.act_window',\n            'context': {'create': False, 'delete': False},\n            'domain': [('id','in', self.groups_id.ids)],\n            'target': 'current',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_show_accesses",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_show_accesses(self):\n        self.ensure_one()\n        return {\n            'name': _('Access Rights'),\n            'view_mode': 'tree,form',\n            'res_model': 'ir.model.access',\n            'type': 'ir.actions.act_window',\n            'context': {'create': False, 'delete': False},\n            'domain': [('id', 'in', self.groups_id.model_access.ids)],\n            'target': 'current',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "action_show_rules",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def action_show_rules(self):\n        self.ensure_one()\n        return {\n            'name': _('Record Rules'),\n            'view_mode': 'tree,form',\n            'res_model': 'ir.rule',\n            'type': 'ir.actions.act_window',\n            'context': {'create': False, 'delete': False},\n            'domain': [('id', 'in', self.groups_id.rule_groups.ids)],\n            'target': 'current',\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_internal",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _is_internal(self):\n        self.ensure_one()\n        return not self.sudo().share",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_portal",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _is_portal(self):\n        self.ensure_one()\n        return self.has_group('base.group_portal')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_public",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _is_public(self):\n        self.ensure_one()\n        return self.has_group('base.group_public')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_system",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _is_system(self):\n        self.ensure_one()\n        return self.has_group('base.group_system')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_admin",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _is_admin(self):\n        self.ensure_one()\n        return self._is_superuser() or self.has_group('base.group_erp_manager')",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_is_superuser",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _is_superuser(self):\n        self.ensure_one()\n        return self.id == SUPERUSER_ID",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_company_currency_id",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_company_currency_id(self):\n        return self.env.company.currency_id.id",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_crypt_context",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _crypt_context(self):\n        \"\"\" Passlib CryptContext instance used to encrypt and verify\n        passwords. Can be overridden if technical, legal or political matters\n        require different kdfs than the provided default.\n\n        The work factor of the default KDF can be configured using the\n        ``password.hashing.rounds`` ICP.\n        \"\"\"\n        cfg = self.env['ir.config_parameter'].sudo()\n        return CryptContext(\n            # kdf which can be verified by the context. The default encryption\n            # kdf is the first of the list\n            ['pbkdf2_sha512', 'plaintext'],\n            # deprecated algorithms are still verified as usual, but\n            # ``needs_update`` will indicate that the stored hash should be\n            # replaced by a more recent algorithm.\n            deprecated=['auto'],\n            pbkdf2_sha512__rounds=max(MIN_ROUNDS, int(cfg.get_param('password.hashing.rounds', 0))),\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_assert_can_auth",
          "params": [
            "self",
            "user=None"
          ],
          "decorators": [],
          "source": "def _assert_can_auth(self, user=None):\n        \"\"\" Checks that the current environment even allows the current auth\n        request to happen.\n\n        The baseline implementation is a simple linear login cooldown: after\n        a number of failures trying to log-in, the user (by login) is put on\n        cooldown. During the cooldown period, login *attempts* are ignored\n        and logged.\n\n        :param user: user id or login, for logging purpose\n\n        .. warning::\n\n            The login counter is not shared between workers and not\n            specifically thread-safe, the feature exists mostly for\n            rate-limiting on large number of login attempts (brute-forcing\n            passwords) so that should not be much of an issue.\n\n            For a more complex strategy (e.g. database or distribute storage)\n            override this method. To simply change the cooldown criteria\n            (configuration, ...) override _on_login_cooldown instead.\n\n        .. note::\n\n            This is a *context manager* so it can be called around the login\n            procedure without having to call it itself.\n        \"\"\"\n        # needs request for remote address\n        if not request:\n            yield\n            return\n\n        reg = self.env.registry\n        failures_map = getattr(reg, '_login_failures', None)\n        if failures_map is None:\n            failures_map = reg._login_failures = collections.defaultdict(lambda : (0, datetime.datetime.min))\n\n        source = request.httprequest.remote_addr\n        (failures, previous) = failures_map[source]\n        if self._on_login_cooldown(failures, previous):\n            _logger.warning(\n                \"Login attempt ignored for %s (user %r) on %s: \"\n                \"%d failures since last success, last failure at %s. \"\n                \"You can configure the number of login failures before a \"\n                \"user is put on cooldown as well as the duration in the \"\n                \"System Parameters. Disable this feature by setting \"\n                \"\\\"base.login_cooldown_after\\\" to 0.\",\n                source, user or \"?\", self.env.cr.dbname, failures, previous)\n            if ipaddress.ip_address(source).is_private:\n                _logger.warning(\n                    \"The rate-limited IP address %s is classified as private \"\n                    \"and *might* be a proxy. If your Odoo is behind a proxy, \"\n                    \"it may be mis-configured. Check that you are running \"\n                    \"Odoo in Proxy Mode and that the proxy is properly configured, see \"\n                    \"https://www.odoo.com/documentation/17.0/administration/install/deploy.html#https for details.\",\n                    source\n                )\n            raise AccessDenied(_(\"Too many login failures, please wait a bit before trying again.\"))\n\n        try:\n            yield\n        except AccessDenied:\n            (failures, __) = reg._login_failures[source]\n            reg._login_failures[source] = (failures + 1, datetime.datetime.now())\n            raise\n        else:\n            reg._login_failures.pop(source, None)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_on_login_cooldown",
          "params": [
            "self",
            "failures",
            "previous"
          ],
          "decorators": [],
          "source": "def _on_login_cooldown(self, failures, previous):\n        \"\"\" Decides whether the user trying to log in is currently\n        \"on cooldown\" and not even allowed to attempt logging in.\n\n        The default cooldown function simply puts the user on cooldown for\n        <login_cooldown_duration> seconds after each failure following the\n        <login_cooldown_after>th (0 to disable).\n\n        Can be overridden to implement more complex backoff strategies, or\n        e.g. wind down or reset the cooldown period as the previous failure\n        recedes into the far past.\n\n        :param int failures: number of recorded failures (since last success)\n        :param previous: timestamp of previous failure\n        :type previous:  datetime.datetime\n        :returns: whether the user is currently in cooldown phase (true if cooldown, false if no cooldown and login can continue)\n        :rtype: bool\n        \"\"\"\n        cfg = self.env['ir.config_parameter'].sudo()\n        min_failures = int(cfg.get_param('base.login_cooldown_after', 5))\n        if min_failures == 0:\n            return False\n\n        delay = int(cfg.get_param('base.login_cooldown_duration', 60))\n        return failures >= min_failures and (datetime.datetime.now() - previous) < datetime.timedelta(seconds=delay)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_register_hook",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _register_hook(self):\n        if hasattr(self, 'check_credentials'):\n            _logger.warning(\"The check_credentials method of res.users has been renamed _check_credentials. One of your installed modules defines one, but it will not be called anymore.\")",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_mfa_type",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _mfa_type(self):\n        \"\"\" If an MFA method is enabled, returns its type as a string. \"\"\"\n        return",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_mfa_url",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _mfa_url(self):\n        \"\"\" If an MFA method is enabled, returns the URL for its second step. \"\"\"\n        return",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_should_alert_new_device",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _should_alert_new_device(self):\n        \"\"\" Determine if an alert should be sent to the user regarding a new device\n\n        To be overriden in 2FA modules implementing known devices\n        \"\"\"\n        return False\n\n#\n# Implied groups\n#\n# Extension of res.groups and res.users with a relation for \"implied\" or\n# \"inherited\" groups.  Once a user belongs to a group, it automatically belongs\n# to the implied groups (transitively).\n#",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "delegation",
          "parent": "res.partner",
          "field": "partner_id"
        }
      ],
      "constraints": [
        {
          "type": "sql",
          "name": "login_key",
          "definition": "UNIQUE (login)",
          "message": "You can not have two users with the same login!"
        },
        {
          "type": "python",
          "name": "_check_company",
          "definition": "@api.constrains('company_id', 'company_ids', 'active')\n    def _check_company(self):\n        for user in self.filtered(lambda u: u.active):\n            if user.company_id not in user.company_ids:\n                raise ValidationError(\n                    _('Company %(company_name)s is not in the allowed companies for user %(user_name)s (%(company_allowed)s).',\n                      company_name=user.company_id.name,\n                      user_name=user.name,\n                      company_allowed=', '.join(user.mapped('company_ids.name')))\n                )",
          "message": "'company_id', 'company_ids', 'active'"
        },
        {
          "type": "python",
          "name": "_check_action_id",
          "definition": "@api.constrains('action_id')\n    def _check_action_id(self):\n        action_open_website = self.env.ref('base.action_open_website', raise_if_not_found=False)\n        if action_open_website and any(user.action_id.id == action_open_website.id for user in self):\n            raise ValidationError(_('The \"App Switcher\" action cannot be selected as home action.'))\n        # We use sudo() because  \"Access rights\" admins can't read action models\n        for user in self.sudo():\n            if user.action_id.type == \"ir.actions.client\":\n                # Prevent using reload actions.\n                action = self.env[\"ir.actions.client\"].browse(user.action_id.id)  # magic\n                if action.tag == \"reload\":\n                    raise ValidationError(_('The \"%s\" action cannot be selected as home action.', action.name))\n\n            elif user.action_id.type == \"ir.actions.act_window\":\n                # Restrict actions that include 'active_id' in their context.\n                action = self.env[\"ir.actions.act_window\"].browse(user.action_id.id)  # magic\n                if not action.context:\n                    continue\n                if \"active_id\" in action.context:\n                    raise ValidationError(\n                        _('The action \"%s\" cannot be set as the home action because it requires a record to be selected beforehand.', action.name)\n                    )",
          "message": "'action_id'"
        },
        {
          "type": "python",
          "name": "_check_one_user_type",
          "definition": "@api.constrains('groups_id')\n    def _check_one_user_type(self):\n        \"\"\"We check that no users are both portal and users (same with public).\n           This could typically happen because of implied groups.\n        \"\"\"\n        user_types_category = self.env.ref('base.module_category_user_type', raise_if_not_found=False)\n        user_types_groups = self.env['res.groups'].search(\n            [('category_id', '=', user_types_category.id)]) if user_types_category else False\n        if user_types_groups:  # needed at install\n            if self._has_multiple_groups(user_types_groups.ids):\n                raise ValidationError(_('The user cannot have more than one user types.'))",
          "message": "'groups_id'"
        }
      ],
      "accessRules": [
        {
          "name": "_search_res_users_settings_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_field_access_rights (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_read_group_check_field_access_rights (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_name_search (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "action_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_invalidation_fields (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_update_last_login (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_login_domain (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_email_domain (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_get_login_order (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "change_password (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "has_group (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_company_currency_id (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "check_access_rights",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "Users"
    },
    {
      "name": "groupsimplied",
      "description": "",
      "fields": [
        {
          "name": "implied_ids",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Inherits",
          "help": "Users of this group automatically inherit those groups"
        },
        {
          "name": "trans_implied_ids",
          "type": "Many2many",
          "relation": "res.groups",
          "string": "Transitively inherits"
        }
      ],
      "methods": [
        {
          "name": "_compute_trans_implied",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_trans_implied(self):\n        # Compute the transitive closure recursively. Note that the performance\n        # is good, because the record cache behaves as a memo (the field is\n        # never computed twice on a given group.)\n        for g in self:\n            g.trans_implied_ids = g.implied_ids | g.implied_ids.trans_implied_ids",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        user_ids_list = [vals.pop('users', None) for vals in vals_list]\n        groups = super(GroupsImplied, self).create(vals_list)\n        for group, user_ids in zip(groups, user_ids_list):\n            if user_ids:\n                # delegate addition of users to add implied groups\n                group.write({'users': user_ids})\n        return groups",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        res = super(GroupsImplied, self).write(values)\n        if values.get('users') or values.get('implied_ids'):\n            # add all implied groups (to all users of each group)\n            updated_group_ids = OrderedSet()\n            updated_user_ids = OrderedSet()\n            for group in self:\n                self._cr.execute(\"\"\"\n                    WITH RECURSIVE group_imply(gid, hid) AS (\n                        SELECT gid, hid\n                          FROM res_groups_implied_rel\n                         UNION\n                        SELECT i.gid, r.hid\n                          FROM res_groups_implied_rel r\n                          JOIN group_imply i ON (i.hid = r.gid)\n                    )\n                    INSERT INTO res_groups_users_rel (gid, uid)\n                         SELECT i.hid, r.uid\n                           FROM group_imply i, res_groups_users_rel r\n                          WHERE r.gid = i.gid\n                            AND i.gid = %(gid)s\n                         EXCEPT\n                         SELECT r.gid, r.uid\n                           FROM res_groups_users_rel r\n                           JOIN group_imply i ON (r.gid = i.hid)\n                          WHERE i.gid = %(gid)s\n                    RETURNING gid, uid\n                \"\"\", dict(gid=group.id))\n                updated = self.env.cr.fetchall()\n                gids, uids = zip(*updated) if updated else ([], [])\n                updated_group_ids.update(gids)\n                updated_user_ids.update(uids)\n            # notify the ORM about the updated users and groups\n            updated_groups = self.env['res.groups'].browse(updated_group_ids)\n            updated_groups.invalidate_recordset(['users'])\n            updated_groups.modified(['users'])\n            updated_users = self.env['res.users'].browse(updated_user_ids)\n            updated_users.invalidate_recordset(['groups_id'])\n            updated_users.modified(['groups_id'])\n            # explicitly check constraints\n            updated_groups._validate_fields(['users'])\n            updated_users._validate_fields(['groups_id'])\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_apply_group",
          "params": [
            "self",
            "implied_group"
          ],
          "decorators": [],
          "source": "def _apply_group(self, implied_group):\n        \"\"\" Add the given group to the groups implied by the current group\n        :param implied_group: the implied group to add\n        \"\"\"\n        groups = self.filtered(lambda g: implied_group not in g.implied_ids)\n        groups.write({'implied_ids': [Command.link(implied_group.id)]})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_remove_group",
          "params": [
            "self",
            "implied_group"
          ],
          "decorators": [],
          "source": "def _remove_group(self, implied_group):\n        \"\"\" Remove the given group from the implied groups of the current group\n        :param implied_group: the implied group to remove\n        \"\"\"\n        groups = self.filtered(lambda g: implied_group in g.implied_ids)\n        if groups:\n            groups.write({'implied_ids': [Command.unlink(implied_group.id)]})\n            # if user belongs to implied_group thanks to another group, don't remove him\n            # this avoids readding the template user and triggering the mechanism at 121cd0d6084cb28\n            users_to_unlink = [\n                user\n                for user in groups.with_context(active_test=False).users\n                if implied_group not in (user.groups_id - implied_group).trans_implied_ids\n            ]\n            if users_to_unlink:\n                # do not remove inactive users (e.g. default)\n                implied_group.with_context(active_test=False).write(\n                    {'users': [Command.unlink(user.id) for user in users_to_unlink]})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "res.groups"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "GroupsImplied"
    },
    {
      "name": "usersimplied",
      "description": "",
      "fields": [],
      "methods": [
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        for values in vals_list:\n            if 'groups_id' in values:\n                # complete 'groups_id' with implied groups\n                user = self.new(values)\n                gs = user.groups_id._origin\n                gs = gs | gs.trans_implied_ids\n                values['groups_id'] = self._fields['groups_id'].convert_to_write(gs, user)\n        return super(UsersImplied, self).create(vals_list)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        if not values.get('groups_id'):\n            return super(UsersImplied, self).write(values)\n        users_before = self.filtered(lambda u: u._is_internal())\n        res = super(UsersImplied, self).write(values)\n        demoted_users = users_before.filtered(lambda u: not u._is_internal())\n        if demoted_users:\n            # demoted users are restricted to the assigned groups only\n            vals = {'groups_id': [Command.clear()] + values['groups_id']}\n            super(UsersImplied, demoted_users).write(vals)\n        # add implied groups for all users (in batches)\n        users_batch = defaultdict(self.browse)\n        for user in self:\n            users_batch[user.groups_id] += user\n        for groups, users in users_batch.items():\n            gs = set(concat(g.trans_implied_ids for g in groups))\n            vals = {'groups_id': [Command.link(g.id) for g in gs]}\n            super(UsersImplied, users).write(vals)\n        return res\n\n#\n# Virtual checkbox and selection for res.user form view\n#\n# Extension of res.groups and res.users for the special groups view in the users\n# form.  This extension presents groups with selection and boolean widgets:\n# - Groups are shown by application, with boolean and/or selection fields.\n#   Selection fields typically defines a role \"Name\" for the given application.\n# - Uncategorized groups are presented as boolean fields and grouped in a\n#   section \"Others\".\n#\n# The user form view is modified by an inherited view (base.user_groups_view);\n# the inherited view replaces the field 'groups_id' by a set of reified group\n# fields (boolean or selection fields).  The arch of that view is regenerated\n# each time groups are changed.\n#\n# Naming conventions for reified groups fields:\n# - boolean field 'in_group_ID' is True iff\n#       ID is in 'groups_id'\n# - selection field 'sel_groups_ID1_..._IDk' is ID iff\n#       ID is in 'groups_id' and ID is maximal in the set {ID1, ..., IDk}\n#",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "res.users"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "UsersImplied"
    },
    {
      "name": "user_group_warning",
      "description": "",
      "fields": [],
      "methods": [
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        groups = super().create(vals_list)\n        self._update_user_groups_view()\n        # actions.get_bindings() depends on action records\n        self.env.registry.clear_cache()\n        return groups",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        # determine which values the \"user groups view\" depends on\n        VIEW_DEPS = ('category_id', 'implied_ids')\n        view_values0 = [g[name] for name in VIEW_DEPS if name in values for g in self]\n        res = super(GroupsView, self).write(values)\n        # update the \"user groups view\" only if necessary\n        view_values1 = [g[name] for name in VIEW_DEPS if name in values for g in self]\n        if view_values0 != view_values1:\n            self._update_user_groups_view()\n        # actions.get_bindings() depends on action records\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        res = super(GroupsView, self).unlink()\n        self._update_user_groups_view()\n        # actions.get_bindings() depends on action records\n        self.env.registry.clear_cache()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_get_hidden_extra_categories",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _get_hidden_extra_categories(self):\n        return ['base.module_category_hidden', 'base.module_category_extra', 'base.module_category_usability']",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_update_user_groups_view",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _update_user_groups_view(self):\n        \"\"\" Modify the view with xmlid ``base.user_groups_view``, which inherits\n            the user form view, and introduces the reified group fields.\n        \"\"\"\n        # remove the language to avoid translations, it will be handled at the view level\n        self = self.with_context(lang=None)\n\n        # We have to try-catch this, because at first init the view does not\n        # exist but we are already creating some basic groups.\n        view = self.env.ref('base.user_groups_view', raise_if_not_found=False)\n        if not (view and view._name == 'ir.ui.view'):\n            return\n\n        if self._context.get('install_filename') or self._context.get(MODULE_UNINSTALL_FLAG):\n            # use a dummy view during install/upgrade/uninstall\n            xml = E.field(name=\"groups_id\", position=\"after\")\n\n        else:\n            group_no_one = view.env.ref('base.group_no_one')\n            group_employee = view.env.ref('base.group_user')\n            xml0, xml1, xml2, xml3, xml4 = [], [], [], [], []\n            xml_by_category = {}\n            xml1.append(E.separator(string='User Type', colspan=\"2\", groups='base.group_no_one'))\n\n            user_type_field_name = ''\n            user_type_readonly = str({})\n            sorted_tuples = sorted(self.get_groups_by_application(),\n                                   key=lambda t: t[0].xml_id != 'base.module_category_user_type')\n            for app, kind, gs, category_name in sorted_tuples:  # we process the user type first\n                attrs = {}\n                # hide groups in categories 'Hidden' and 'Extra' (except for group_no_one)\n                if app.xml_id in self._get_hidden_extra_categories():\n                    attrs['groups'] = 'base.group_no_one'\n\n                # User type (employee, portal or public) is a separated group. This is the only 'selection'\n                # group of res.groups without implied groups (with each other).\n                if app.xml_id == 'base.module_category_user_type':\n                    # application name with a selection field\n                    field_name = name_selection_groups(gs.ids)\n                    # test_reified_groups, put the user category type in invisible\n                    # as it's used in domain of attrs of other fields,\n                    # and the normal user category type field node is wrapped in a `groups=\"base.no_one\"`,\n                    # and is therefore removed when not in debug mode.\n                    xml0.append(E.field(name=field_name, invisible=\"1\", on_change=\"1\"))\n                    user_type_field_name = field_name\n                    user_type_readonly = f'{user_type_field_name} != {group_employee.id}'\n                    attrs['widget'] = 'radio'\n                    # Trigger the on_change of this \"virtual field\"\n                    attrs['on_change'] = '1'\n                    xml1.append(E.field(name=field_name, **attrs))\n                    xml1.append(E.newline())\n\n                elif kind == 'selection':\n                    # application name with a selection field\n                    field_name = name_selection_groups(gs.ids)\n                    attrs['readonly'] = user_type_readonly\n                    attrs['on_change'] = '1'\n                    if category_name not in xml_by_category:\n                        xml_by_category[category_name] = []\n                        xml_by_category[category_name].append(E.newline())\n                    xml_by_category[category_name].append(E.field(name=field_name, **attrs))\n                    xml_by_category[category_name].append(E.newline())\n                    # add duplicate invisible field so default values are saved on create\n                    if attrs.get('groups') == 'base.group_no_one':\n                        xml0.append(E.field(name=field_name, **dict(attrs, invisible=\"1\", groups='!base.group_no_one')))\n\n                else:\n                    # application separator with boolean fields\n                    app_name = app.name or 'Other'\n                    xml4.append(E.separator(string=app_name, **attrs))\n                    left_group, right_group = [], []\n                    attrs['readonly'] = user_type_readonly\n                    # we can't use enumerate, as we sometime skip groups\n                    group_count = 0\n                    for g in gs:\n                        field_name = name_boolean_group(g.id)\n                        dest_group = left_group if group_count % 2 == 0 else right_group\n                        if g == group_no_one:\n                            # make the group_no_one invisible in the form view\n                            dest_group.append(E.field(name=field_name, invisible=\"1\", **attrs))\n                        else:\n                            dest_group.append(E.field(name=field_name, **attrs))\n                        # add duplicate invisible field so default values are saved on create\n                        xml0.append(E.field(name=field_name, **dict(attrs, invisible=\"1\", groups='!base.group_no_one')))\n                        group_count += 1\n                    xml4.append(E.group(*left_group))\n                    xml4.append(E.group(*right_group))\n\n            xml4.append({'class': \"o_label_nowrap\"})\n            user_type_invisible = f'{user_type_field_name} != {group_employee.id}' if user_type_field_name else None\n\n            for xml_cat in sorted(xml_by_category.keys(), key=lambda it: it[0]):\n                master_category_name = xml_cat[1]\n                xml3.append(E.group(*(xml_by_category[xml_cat]), string=master_category_name))\n\n            field_name = 'user_group_warning'\n            user_group_warning_xml = E.div({\n                'class': \"alert alert-warning\",\n                'role': \"alert\",\n                'colspan': \"2\",\n                'invisible': f'not {field_name}',\n            })\n            user_group_warning_xml.append(E.label({\n                'for': field_name,\n                'string': \"Access Rights Mismatch\",\n                'class': \"text text-warning fw-bold\",\n            }))\n            user_group_warning_xml.append(E.field(name=field_name))\n            xml2.append(user_group_warning_xml)\n\n            xml = E.field(\n                *(xml0),\n                E.group(*(xml1), groups=\"base.group_no_one\"),\n                E.group(*(xml2), invisible=user_type_invisible),\n                E.group(*(xml3), invisible=user_type_invisible),\n                E.group(*(xml4), invisible=user_type_invisible, groups=\"base.group_no_one\"), name=\"groups_id\", position=\"replace\")\n            xml.addprevious(etree.Comment(\"GENERATED AUTOMATICALLY BY GROUPS\"))\n\n        # serialize and update the view\n        xml_content = etree.tostring(xml, pretty_print=True, encoding=\"unicode\")\n        if xml_content != view.arch:  # avoid useless xml validation if no change\n            new_context = dict(view._context)\n            new_context.pop('install_filename', None)  # don't set arch_fs for this computed view\n            new_context['lang'] = None\n            view.with_context(new_context).write({'arch': xml_content})",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_application_groups",
          "params": [
            "self",
            "domain"
          ],
          "decorators": [],
          "source": "def get_application_groups(self, domain):\n        \"\"\" Return the non-share groups that satisfy ``domain``. \"\"\"\n        return self.search(domain + [('share', '=', False)])",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "get_groups_by_application",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def get_groups_by_application(self):\n        \"\"\" Return all groups classified by application (module category), as a list::\n\n                [(app, kind, groups), ...],\n\n            where ``app`` and ``groups`` are recordsets, and ``kind`` is either\n            ``'boolean'`` or ``'selection'``. Applications are given in sequence\n            order.  If ``kind`` is ``'selection'``, ``groups`` are given in\n            reverse implication order.\n        \"\"\"",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "linearize",
          "params": [
            "app",
            "gs",
            "category_name"
          ],
          "decorators": [],
          "source": "def linearize(app, gs, category_name):\n            # 'User Type' is an exception\n            if app.xml_id == 'base.module_category_user_type':\n                return (app, 'selection', gs.sorted('id'), category_name)\n            # determine sequence order: a group appears after its implied groups\n            order = {g: len(g.trans_implied_ids & gs) for g in gs}\n            # We want a selection for Accounting too. Auditor and Invoice are both\n            # children of Accountant, but the two of them make a full accountant\n            # so it makes no sense to have checkboxes.\n            if app.xml_id == 'base.module_category_accounting_accounting':\n                return (app, 'selection', gs.sorted(key=order.get), category_name)\n            # check whether order is total, i.e., sequence orders are distinct\n            if len(set(order.values())) == len(gs):\n                return (app, 'selection', gs.sorted(key=order.get), category_name)\n            else:\n                return (app, 'boolean', gs, (100, 'Other'))\n\n        # classify all groups by application\n        by_app, others = defaultdict(self.browse), self.browse()\n        for g in self.get_application_groups([]):\n            if g.category_id:\n                by_app[g.category_id] += g\n            else:\n                others += g\n        # build the result\n        res = []\n        for app, gs in sorted(by_app.items(), key=lambda it: it[0].sequence or 0):\n            if app.parent_id:\n                res.append(linearize(app, gs, (app.parent_id.sequence, app.parent_id.name)))\n            else:\n                res.append(linearize(app, gs, (100, 'Other')))\n\n        if others:\n            res.append((self.env['ir.module.category'], 'boolean', others, (100,'Other')))\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "res.groups"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "_update_user_groups_view (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "get_groups_by_application (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "GroupsView"
    },
    {
      "name": "modulecategory",
      "description": "",
      "fields": [],
      "methods": [
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        res = super().write(values)\n        if \"name\" in values:\n            self.env[\"res.groups\"]._update_user_groups_view()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "unlink",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def unlink(self):\n        res = super().unlink()\n        self.env[\"res.groups\"]._update_user_groups_view()\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "ir.module.category"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "ModuleCategory"
    },
    {
      "name": "usersview",
      "description": "",
      "fields": [
        {
          "name": "user_group_warning",
          "type": "Text",
          "string": "User Group Warning"
        }
      ],
      "methods": [
        {
          "name": "_compute_user_group_warning",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_user_group_warning(self):\n        self.user_group_warning = False\n        if self._context.get('show_user_group_warning'):\n            for user in self.filtered_domain([('share', '=', False)]):\n                group_inheritance_warnings = self._prepare_warning_for_group_inheritance(user)\n                if group_inheritance_warnings:\n                    user.user_group_warning = group_inheritance_warnings",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "create",
          "params": [
            "self",
            "vals_list"
          ],
          "decorators": [],
          "source": "def create(self, vals_list):\n        new_vals_list = []\n        for values in vals_list:\n            new_vals_list.append(self._remove_reified_groups(values))\n        users = super(UsersView, self).create(new_vals_list)\n        group_multi_company_id = self.env['ir.model.data']._xmlid_to_res_id(\n            'base.group_multi_company', raise_if_not_found=False)\n        if group_multi_company_id:\n            for user in users:\n                if len(user.company_ids) <= 1 and group_multi_company_id in user.groups_id.ids:\n                    user.write({'groups_id': [Command.unlink(group_multi_company_id)]})\n                elif len(user.company_ids) > 1 and group_multi_company_id not in user.groups_id.ids:\n                    user.write({'groups_id': [Command.link(group_multi_company_id)]})\n        return users",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "write",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def write(self, values):\n        values = self._remove_reified_groups(values)\n        res = super(UsersView, self).write(values)\n        if 'company_ids' not in values:\n            return res\n        group_multi_company = self.env.ref('base.group_multi_company', False)\n        if group_multi_company:\n            for user in self:\n                if len(user.company_ids) <= 1 and user.id in group_multi_company.users.ids:\n                    user.write({'groups_id': [Command.unlink(group_multi_company.id)]})\n                elif len(user.company_ids) > 1 and user.id not in group_multi_company.users.ids:\n                    user.write({'groups_id': [Command.link(group_multi_company.id)]})\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "new",
          "params": [
            "self",
            "values=None",
            "origin=None",
            "ref=None"
          ],
          "decorators": [],
          "source": "def new(self, values=None, origin=None, ref=None):\n        if values is None:\n            values = {}\n        values = self._remove_reified_groups(values)\n        user = super().new(values=values, origin=origin, ref=ref)\n        group_multi_company = self.env.ref('base.group_multi_company', False)\n        if group_multi_company and 'company_ids' in values:\n            if len(user.company_ids) <= 1 and user.id in group_multi_company.users.ids:\n                user.update({'groups_id': [Command.unlink(group_multi_company.id)]})\n            elif len(user.company_ids) > 1 and user.id not in group_multi_company.users.ids:\n                user.update({'groups_id': [Command.link(group_multi_company.id)]})\n        return user",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_prepare_warning_for_group_inheritance",
          "params": [
            "self",
            "user"
          ],
          "decorators": [],
          "source": "def _prepare_warning_for_group_inheritance(self, user):\n        \"\"\" Check (updated) groups configuration for user. If implieds groups\n        will be added back due to inheritance and hierarchy in groups return\n        a message explaining the missing groups.\n\n        :param res.users user: target user\n\n        :return: string to display in a warning\n        \"\"\"\n        # Current groups of the user\n        current_groups = user.groups_id.filtered('trans_implied_ids')\n        current_groups_by_category = defaultdict(lambda: self.env['res.groups'])\n        for group in current_groups:\n            current_groups_by_category[group.category_id] |= group.trans_implied_ids.filtered(lambda grp: grp.category_id == group.category_id)\n\n        missing_groups = {}\n        # We don't want to show warning for \"Technical\" and \"Extra Rights\" groups\n        categories_to_ignore = self.env.ref('base.module_category_hidden') + self.env.ref('base.module_category_usability')\n        for group in current_groups:\n            # Get the updated group from current groups\n            missing_implied_groups = group.implied_ids - user.groups_id\n            # Get the missing group needed in updated group's category (For example, someone changes\n            # Sales: Admin to Sales: User, but Field Service is already set to Admin, so here in the\n            # 'Sales' category, we will at the minimum need Admin group)\n            missing_implied_groups = missing_implied_groups.filtered(\n                lambda g:\n                g.category_id not in (group.category_id | categories_to_ignore) and\n                g not in current_groups_by_category[g.category_id] and\n                (self.user_has_groups('base.group_no_one') or g.category_id)\n            )\n            if missing_implied_groups:\n                # prepare missing group message, by categories\n                missing_groups[group] = \", \".join(f'\"{missing_group.category_id.name or _(\"Other\")}: {missing_group.name}\"'\n                                                  for missing_group in missing_implied_groups)\n        return \"\\n\".join(\n            _('Since %(user)s is a/an \"%(category)s: %(group)s\", they will at least obtain the right %(missing_group_message)s',\n              user=user.name,\n              category=group.category_id.name or _('Other'),\n              group=group.name,\n              missing_group_message=missing_group_message\n             ) for group, missing_group_message in missing_groups.items()\n        )",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_remove_reified_groups",
          "params": [
            "self",
            "values"
          ],
          "decorators": [],
          "source": "def _remove_reified_groups(self, values):\n        \"\"\" return `values` without reified group fields \"\"\"\n        add, rem = [], []\n        values1 = {}\n\n        for key, val in values.items():\n            if is_boolean_group(key):\n                (add if val else rem).append(get_boolean_group(key))\n            elif is_selection_groups(key):\n                rem += get_selection_groups(key)\n                if val:\n                    add.append(val)\n            else:\n                values1[key] = val\n\n        if 'groups_id' not in values and (add or rem):\n            added = self.env['res.groups'].sudo().browse(add)\n            added |= added.mapped('trans_implied_ids')\n            added_ids = added._ids\n            # remove group ids in `rem` and add group ids in `add`\n            # do not remove groups that are added by implied\n            values1['groups_id'] = list(itertools.chain(\n                zip(repeat(3), [gid for gid in rem if gid not in added_ids]),\n                zip(repeat(4), add)\n            ))\n\n        return values1",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "default_get",
          "params": [
            "self",
            "fields"
          ],
          "decorators": [],
          "source": "def default_get(self, fields):\n        group_fields, fields = partition(is_reified_group, fields)\n        fields1 = (fields + ['groups_id']) if group_fields else fields\n        values = super(UsersView, self).default_get(fields1)\n        self._add_reified_groups(group_fields, values)\n        return values",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_determine_fields_to_fetch",
          "params": [
            "self",
            "field_names",
            "ignore_when_in_cache=False"
          ],
          "decorators": [],
          "source": "def _determine_fields_to_fetch(self, field_names, ignore_when_in_cache=False):\n        valid_fields = partition(is_reified_group, field_names)[1]\n        return super()._determine_fields_to_fetch(valid_fields, ignore_when_in_cache)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_read_format",
          "params": [
            "self",
            "fnames",
            "load='_classic_read'"
          ],
          "decorators": [],
          "source": "def _read_format(self, fnames, load='_classic_read'):\n        valid_fields = partition(is_reified_group, fnames)[1]\n        return super()._read_format(valid_fields, load)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "onchange",
          "params": [
            "self",
            "values",
            "field_names",
            "fields_spec"
          ],
          "decorators": [],
          "source": "def onchange(self, values, field_names, fields_spec):\n        reified_fnames = [fname for fname in fields_spec if is_reified_group(fname)]\n        if reified_fnames:\n            values = {key: val for key, val in values.items() if key != 'groups_id'}\n            values = self._remove_reified_groups(values)\n\n            if any(is_reified_group(fname) for fname in field_names):\n                field_names = [fname for fname in field_names if not is_reified_group(fname)]\n                field_names.append('groups_id')\n\n            fields_spec = {\n                field_name: field_spec\n                for field_name, field_spec in fields_spec.items()\n                if not is_reified_group(field_name)\n            }\n            fields_spec['groups_id'] = {}\n\n        result = super().onchange(values, field_names, fields_spec)\n\n        if reified_fnames and 'groups_id' in result.get('value', {}):\n            self._add_reified_groups(reified_fnames, result['value'])\n            result['value'].pop('groups_id', None)\n\n        return result",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "read",
          "params": [
            "self",
            "fields=None",
            "load='_classic_read'"
          ],
          "decorators": [],
          "source": "def read(self, fields=None, load='_classic_read'):\n        # determine whether reified groups fields are required, and which ones\n        fields1 = fields or list(self.fields_get())\n        group_fields, other_fields = partition(is_reified_group, fields1)\n\n        # read regular fields (other_fields); add 'groups_id' if necessary\n        drop_groups_id = False\n        if group_fields and fields:\n            if 'groups_id' not in other_fields:\n                other_fields.append('groups_id')\n                drop_groups_id = True\n        else:\n            other_fields = fields\n\n        res = super(UsersView, self).read(other_fields, load=load)\n\n        # post-process result to add reified group fields\n        if group_fields:\n            for values in res:\n                self._add_reified_groups(group_fields, values)\n                if drop_groups_id:\n                    values.pop('groups_id', None)\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "read_group",
          "params": [
            "self",
            "domain",
            "fields",
            "groupby",
            "offset=0",
            "limit=None",
            "orderby=False",
            "lazy=True"
          ],
          "decorators": [],
          "source": "def read_group(self, domain, fields, groupby, offset=0, limit=None, orderby=False, lazy=True):\n        if fields:\n            # ignore reified fields\n            fields = [fname for fname in fields if not is_reified_group(fname)]\n        return super().read_group(domain, fields, groupby, offset=offset, limit=limit, orderby=orderby, lazy=lazy)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_add_reified_groups",
          "params": [
            "self",
            "fields",
            "values"
          ],
          "decorators": [],
          "source": "def _add_reified_groups(self, fields, values):\n        \"\"\" add the given reified group fields into `values` \"\"\"\n        gids = set(parse_m2m(values.get('groups_id') or []))\n        for f in fields:\n            if is_boolean_group(f):\n                values[f] = get_boolean_group(f) in gids\n            elif is_selection_groups(f):\n                # determine selection groups, in order\n                sel_groups = self.env['res.groups'].sudo().browse(get_selection_groups(f))\n                sel_order = {g: len(g.trans_implied_ids & sel_groups) for g in sel_groups}\n                sel_groups = sel_groups.sorted(key=sel_order.get)\n                # determine which ones are in gids\n                selected = [gid for gid in sel_groups.ids if gid in gids]\n                # if 'Internal User' is in the group, this is the \"User Type\" group\n                # and we need to show 'Internal User' selected, not Public/Portal.\n                if self.env.ref('base.group_user').id in selected:\n                    values[f] = self.env.ref('base.group_user').id\n                else:\n                    values[f] = selected and selected[-1] or False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "fields_get",
          "params": [
            "self",
            "allfields=None",
            "attributes=None"
          ],
          "decorators": [],
          "source": "def fields_get(self, allfields=None, attributes=None):\n        res = super(UsersView, self).fields_get(allfields, attributes=attributes)\n        # add reified groups fields\n        for app, kind, gs, category_name in self.env['res.groups'].sudo().get_groups_by_application():\n            if kind == 'selection':\n                # 'User Type' should not be 'False'. A user is either 'employee', 'portal' or 'public' (required).\n                selection_vals = [(False, '')]\n                if app.xml_id == 'base.module_category_user_type':\n                    selection_vals = []\n                field_name = name_selection_groups(gs.ids)\n                if allfields and field_name not in allfields:\n                    continue\n                # selection group field\n                tips = []\n                if app.description:\n                    tips.append(app.description + '\\n')\n                tips.extend('%s: %s' % (g.name, g.comment) for g in gs if g.comment)\n                res[field_name] = {\n                    'type': 'selection',\n                    'string': app.name or _('Other'),\n                    'selection': selection_vals + [(g.id, g.name) for g in gs],\n                    'help': '\\n'.join(tips),\n                    'exportable': False,\n                    'selectable': False,\n                }\n            else:\n                # boolean group fields\n                for g in gs:\n                    field_name = name_boolean_group(g.id)\n                    if allfields and field_name not in allfields:\n                        continue\n                    res[field_name] = {\n                        'type': 'boolean',\n                        'string': g.name,\n                        'help': g.comment,\n                        'exportable': False,\n                        'selectable': False,\n                    }\n        # add self readable/writable fields\n        missing = set(self.SELF_WRITEABLE_FIELDS).union(self.SELF_READABLE_FIELDS).difference(res.keys())\n        if allfields:\n            missing = missing.intersection(allfields)\n        if missing:\n            res.update({\n                key: dict(values, readonly=key not in self.SELF_WRITEABLE_FIELDS, searchable=False)\n                for key, values in super(UsersView, self.sudo()).fields_get(missing, attributes).items()\n            })\n        return res",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "res.users"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "create (model_create_multi)",
          "permissions": {
            "read": true,
            "write": true,
            "create": true,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "new (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "default_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "read_group (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        },
        {
          "name": "fields_get (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "UsersView"
    },
    {
      "name": "res.users.identitycheck",
      "description": "Password Check Wizard",
      "fields": [
        {
          "name": "request",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "password",
          "type": "Char"
        }
      ],
      "methods": [
        {
          "name": "_check_identity",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_identity(self):\n        try:\n            self.create_uid._check_credentials(self.password, {'interactive': True})\n        except AccessDenied:\n            raise UserError(_(\"Incorrect Password, try again or click on Forgot Password to reset your password.\"))\n        finally:\n            self.password = False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "run_check",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def run_check(self):\n        assert request, \"This method can only be accessed over HTTP\"\n        self._check_identity()\n\n        request.session['identity-check-last'] = time.time()\n        ctx, model, ids, method = json.loads(self.sudo().request)\n        method = getattr(self.env(context=ctx)[model].browse(ids), method)\n        assert getattr(method, '__has_check_identity', False)\n        return method()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "revoke_all_devices",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def revoke_all_devices(self):\n        current_password = self.password\n        self._check_identity()\n        self.env.user._change_password(current_password)\n        self.sudo().unlink()\n        return {'type': 'ir.actions.client', 'tag': 'reload'}\n\n#----------------------------------------------------------\n# change password wizard\n#----------------------------------------------------------",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "CheckIdentity"
    },
    {
      "name": "change.password.wizard",
      "description": "Change Password Wizard",
      "fields": [
        {
          "name": "user_ids",
          "type": "One2many",
          "relation": "change.password.user",
          "string": "Users"
        }
      ],
      "methods": [
        {
          "name": "_default_user_ids",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _default_user_ids(self):\n        user_ids = self._context.get('active_model') == 'res.users' and self._context.get('active_ids') or []\n        return [\n            Command.create({'user_id': user.id, 'user_login': user.login})\n            for user in self.env['res.users'].browse(user_ids)\n        ]\n\n    user_ids = fields.One2many('change.password.user', 'wizard_id', string='Users', default=_default_user_ids)",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "change_password_button",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def change_password_button(self):\n        self.ensure_one()\n        self.user_ids.change_password_button()\n        if self.env.user in self.user_ids.user_id:\n            return {'type': 'ir.actions.client', 'tag': 'reload'}\n        return {'type': 'ir.actions.act_window_close'}",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "ChangePasswordWizard"
    },
    {
      "name": "change.password.user",
      "description": "User, Change Password Wizard",
      "fields": [
        {
          "name": "wizard_id",
          "type": "Many2one",
          "relation": "change.password.wizard",
          "required": true,
          "string": "Wizard"
        },
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "required": true,
          "string": "User"
        },
        {
          "name": "user_login",
          "type": "Char",
          "readonly": true,
          "string": "User Login"
        },
        {
          "name": "new_passwd",
          "type": "Char",
          "string": "New Password"
        }
      ],
      "methods": [
        {
          "name": "change_password_button",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def change_password_button(self):\n        for line in self:\n            if line.new_passwd:\n                line.user_id._change_password(line.new_passwd)\n        # don't keep temporary passwords in the database longer than necessary\n        self.write({'new_passwd': False})",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "ChangePasswordUser"
    },
    {
      "name": "change.password.own",
      "description": "User, change own password wizard",
      "fields": [
        {
          "name": "new_password",
          "type": "Char",
          "string": "New Password"
        },
        {
          "name": "confirm_password",
          "type": "Char"
        }
      ],
      "methods": [
        {
          "name": "_check_password_confirmation",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _check_password_confirmation(self):\n        if self.confirm_password != self.new_password:\n            raise ValidationError(_(\"The new password and its confirmation must be identical.\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "change_password",
          "params": [
            "self"
          ],
          "decorators": [
            "@check_identity"
          ],
          "source": "@check_identity\n    def change_password(self):\n        self.env.user._change_password(self.new_password)\n        self.unlink()\n        # reload to avoid a session expired error\n        # would be great to update the session id in-place, but it seems dicey\n        return {'type': 'ir.actions.client', 'tag': 'reload'}\n\n# API keys support\nAPI_KEY_SIZE = 20 # in bytes\nINDEX_SIZE = 8 # in hex digits, so 4 bytes, or 20% of the key\nKEY_CRYPT_CONTEXT = CryptContext(\n    # default is 29000 rounds which is 25~50ms, which is probably unnecessary\n    # given in this case all the keys are completely random data: dictionary\n    # attacks on API keys isn't much of a concern\n    ['pbkdf2_sha512'], pbkdf2_sha512__rounds=6000,\n)",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [
        {
          "type": "python",
          "name": "_check_password_confirmation",
          "definition": "@api.constrains('new_password', 'confirm_password')\n    def _check_password_confirmation(self):\n        if self.confirm_password != self.new_password:\n            raise ValidationError(_(\"The new password and its confirmation must be identical.\"))",
          "message": "'new_password', 'confirm_password'"
        }
      ],
      "accessRules": [],
      "className": "ChangePasswordOwn"
    },
    {
      "name": "apikeysuser",
      "description": "",
      "fields": [
        {
          "name": "api_key_ids",
          "type": "One2many",
          "relation": "res.users.apikeys",
          "string": "API Keys"
        }
      ],
      "methods": [
        {
          "name": "SELF_READABLE_FIELDS",
          "params": [
            "self"
          ],
          "decorators": [
            "@property"
          ],
          "source": "@property\n    def SELF_READABLE_FIELDS(self):\n        return super().SELF_READABLE_FIELDS + ['api_key_ids']",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "SELF_WRITEABLE_FIELDS",
          "params": [
            "self"
          ],
          "decorators": [
            "@property"
          ],
          "source": "@property\n    def SELF_WRITEABLE_FIELDS(self):\n        return super().SELF_WRITEABLE_FIELDS + ['api_key_ids']",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "_rpc_api_keys_only",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _rpc_api_keys_only(self):\n        \"\"\" To be overridden if RPC access needs to be restricted to API keys, e.g. for 2FA \"\"\"\n        return False",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_credentials",
          "params": [
            "self",
            "password",
            "user_agent_env"
          ],
          "decorators": [],
          "source": "def _check_credentials(self, password, user_agent_env):\n        user_agent_env = user_agent_env or {}\n        if user_agent_env.get('interactive', True):\n            if 'interactive' not in user_agent_env:\n                _logger.warning(\n                    \"_check_credentials without 'interactive' env key, assuming interactive login. \\\n                    Check calls and overrides to ensure the 'interactive' key is properly set in \\\n                    all _check_credentials environments\"\n                )\n            return super()._check_credentials(password, user_agent_env)\n\n        if not self.env.user._rpc_api_keys_only():\n            try:\n                return super()._check_credentials(password, user_agent_env)\n            except AccessDenied:\n                pass\n\n        # 'rpc' scope does not really exist, we basically require a global key (scope NULL)\n        if self.env['res.users.apikeys']._check_credentials(scope='rpc', key=password) == self.env.uid:\n            return\n\n        raise AccessDenied()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "api_key_wizard",
          "params": [
            "self"
          ],
          "decorators": [
            "@check_identity"
          ],
          "source": "@check_identity\n    def api_key_wizard(self):\n        return {\n            'type': 'ir.actions.act_window',\n            'res_model': 'res.users.apikeys.description',\n            'name': 'New API Key',\n            'target': 'new',\n            'views': [(False, 'form')],\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        }
      ],
      "inheritance": [
        {
          "type": "inherit",
          "parent": "res.users"
        }
      ],
      "constraints": [],
      "accessRules": [],
      "className": "APIKeysUser"
    },
    {
      "name": "res.users.apikeys",
      "description": "Users API Keys",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true,
          "readonly": true
        },
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "required": true,
          "readonly": true
        },
        {
          "name": "scope",
          "type": "Char",
          "readonly": true
        },
        {
          "name": "create_date",
          "type": "Datetime",
          "readonly": true
        }
      ],
      "methods": [
        {
          "name": "init",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def init(self):\n        table = sql.Identifier(self._table)\n        self.env.cr.execute(sql.SQL(\"\"\"\n        CREATE TABLE IF NOT EXISTS {table} (\n            id serial primary key,\n            name varchar not null,\n            user_id integer not null REFERENCES res_users(id) ON DELETE CASCADE,\n            scope varchar,\n            index varchar({index_size}) not null CHECK (char_length(index) = {index_size}),\n            key varchar not null,\n            create_date timestamp without time zone DEFAULT (now() at time zone 'utc')\n        )\n        \"\"\").format(table=table, index_size=sql.Placeholder('index_size')), {\n            'index_size': INDEX_SIZE\n        })\n\n        index_name = self._table + \"_user_id_index_idx\"\n        if len(index_name) > 63:\n            # unique determinist index name\n            index_name = self._table[:50] + \"_idx_\" + sha256(self._table.encode()).hexdigest()[:8]\n        self.env.cr.execute(sql.SQL(\"\"\"\n        CREATE INDEX IF NOT EXISTS {index_name} ON {table} (user_id, index);\n        \"\"\").format(\n            table=table,\n            index_name=sql.Identifier(index_name)\n        ))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "remove",
          "params": [
            "self"
          ],
          "decorators": [
            "@check_identity"
          ],
          "source": "@check_identity\n    def remove(self):\n        return self._remove()",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "_remove",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _remove(self):\n        \"\"\"Use the remove() method to remove an API Key. This method implement logic,\n        but won't check the identity (mainly used to remove trusted devices)\"\"\"\n        if not self:\n            return {'type': 'ir.actions.act_window_close'}\n        if self.env.is_system() or self.mapped('user_id') == self.env.user:\n            ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'\n            _logger.info(\"API key(s) removed: scope: <%s> for '%s' (#%s) from %s\",\n               self.mapped('scope'), self.env.user.login, self.env.uid, ip)\n            self.sudo().unlink()\n            return {'type': 'ir.actions.act_window_close'}\n        raise AccessError(_(\"You can not remove API keys unless they're yours or you are a system user\"))",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_check_credentials",
          "params": [
            "self",
            "*",
            "scope",
            "key"
          ],
          "decorators": [],
          "source": "def _check_credentials(self, *, scope, key):\n        assert scope, \"scope is required\"\n        index = key[:INDEX_SIZE]\n        self.env.cr.execute('''\n            SELECT user_id, key\n            FROM {} INNER JOIN res_users u ON (u.id = user_id)\n            WHERE u.active and index = %s AND (scope IS NULL OR scope = %s)\n        '''.format(self._table),\n        [index, scope])\n        for user_id, current_key in self.env.cr.fetchall():\n            if KEY_CRYPT_CONTEXT.verify(key, current_key):\n                return user_id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_generate",
          "params": [
            "self",
            "scope",
            "name"
          ],
          "decorators": [],
          "source": "def _generate(self, scope, name):\n        \"\"\"Generates an api key.\n        :param str scope: the scope of the key. If None, the key will give access to any rpc.\n        :param str name: the name of the key, mainly intended to be displayed in the UI.\n        :return: str: the key.\n\n        \"\"\"\n        # no need to clear the LRU when *adding* a key, only when removing\n        k = binascii.hexlify(os.urandom(API_KEY_SIZE)).decode()\n        self.env.cr.execute(\"\"\"\n        INSERT INTO {table} (name, user_id, scope, key, index)\n        VALUES (%s, %s, %s, %s, %s)\n        RETURNING id\n        \"\"\".format(table=self._table),\n        [name, self.env.user.id, scope, KEY_CRYPT_CONTEXT.hash(k), k[:INDEX_SIZE]])\n\n        ip = request.httprequest.environ['REMOTE_ADDR'] if request else 'n/a'\n        _logger.info(\"%s generated: scope: <%s> for '%s' (#%s) from %s\",\n            self._description, scope, self.env.user.login, self.env.uid, ip)\n\n        return k",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "APIKeys"
    },
    {
      "name": "res.users.apikeys.description",
      "description": "API Key Description",
      "fields": [
        {
          "name": "name",
          "type": "Char",
          "required": true
        }
      ],
      "methods": [
        {
          "name": "make_key",
          "params": [
            "self"
          ],
          "decorators": [
            "@check_identity"
          ],
          "source": "@check_identity\n    def make_key(self):\n        # only create keys for users who can delete their keys\n        self.check_access_make_key()\n\n        description = self.sudo()\n        k = self.env['res.users.apikeys']._generate(None, self.sudo().name)\n        description.unlink()\n\n        return {\n            'type': 'ir.actions.act_window',\n            'res_model': 'res.users.apikeys.show',\n            'name': _('API Key Ready'),\n            'views': [(False, 'form')],\n            'target': 'new',\n            'context': {\n                'default_key': k,\n            }\n        }",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": true
        },
        {
          "name": "check_access_make_key",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def check_access_make_key(self):\n        if not self.user_has_groups('base.group_user'):\n            raise AccessError(_(\"Only internal users can create API keys\"))",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [
        {
          "type": "extends",
          "parent": "models.TransientModel"
        }
      ],
      "constraints": [],
      "accessRules": [
        {
          "name": "check_access_make_key",
          "permissions": {
            "read": false,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "APIKeyDescription"
    },
    {
      "name": "res.users.apikeys.show",
      "description": "Show API Key",
      "fields": [
        {
          "name": "id",
          "type": "Id"
        },
        {
          "name": "key",
          "type": "Char",
          "readonly": true
        }
      ],
      "methods": [],
      "inheritance": [],
      "constraints": [],
      "accessRules": [],
      "className": "APIKeyShow"
    },
    {
      "name": "res.users.deletion",
      "description": "Users Deletion Request",
      "fields": [
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "string": "User"
        },
        {
          "name": "user_id_int",
          "type": "Integer"
        },
        {
          "name": "state",
          "type": "Selection"
        }
      ],
      "methods": [
        {
          "name": "_compute_user_id_int",
          "params": [
            "self"
          ],
          "decorators": [],
          "source": "def _compute_user_id_int(self):\n        for user_deletion in self:\n            if user_deletion.user_id:\n                user_deletion.user_id_int = user_deletion.user_id.id",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_gc_portal_users",
          "params": [
            "self",
            "batch_size=10"
          ],
          "decorators": [],
          "source": "def _gc_portal_users(self, batch_size=10):\n        \"\"\"Remove the portal users that asked to deactivate their account.\n\n        (see <res.users>::_deactivate_portal_user)\n\n        Removing a user can be an heavy operation on large database (because of\n        create_uid, write_uid on each models, which are not always indexed). Because of\n        that, this operation is done in a CRON.\n        \"\"\"\n        delete_requests = self.search([(\"state\", \"=\", \"todo\")])\n\n        # filter the requests related to a deleted user\n        done_requests = delete_requests.filtered(lambda request: not request.user_id)\n        done_requests.state = \"done\"\n\n        todo_requests = delete_requests - done_requests\n        batch_requests = todo_requests[:batch_size]\n\n        auto_commit = not getattr(threading.current_thread(), \"testing\", False)\n\n        for delete_request in batch_requests:\n            user = delete_request.user_id\n            user_name = user.name\n            requester_name = delete_request.create_uid.name\n            # Step 1: Delete User\n            try:\n                self.env.cr.execute(\"SAVEPOINT delete_user\")\n                partner = user.partner_id\n                user.unlink()\n                _logger.info(\"User #%i %r, deleted. Original request from %r.\",\n                             user.id, user_name, delete_request.create_uid.name)\n                self.env.cr.execute(\"RELEASE SAVEPOINT delete_user\")\n                delete_request.state = 'done'\n            except Exception as e:\n                _logger.error(\"User #%i %r could not be deleted. Original request from %r. Related error: %s\",\n                             user.id, user_name, requester_name, e)\n                self.env.cr.execute(\"ROLLBACK TO SAVEPOINT delete_user\")\n                delete_request.state = \"fail\"\n            # make sure we never rollback the work we've done, this can take a long time\n            if auto_commit:\n                self.env.cr.commit()\n            if delete_request.state == \"fail\":\n                continue\n\n            # Step 2: Delete Linked Partner\n            #         Could be impossible if the partner is linked to a SO for example\n            try:\n                self.env.cr.execute(\"SAVEPOINT delete_partner\")\n                partner.unlink()\n                _logger.info(\"Partner #%i %r, deleted. Original request from %r.\",\n                             partner.id, user_name, delete_request.create_uid.name)\n                self.env.cr.execute(\"RELEASE SAVEPOINT delete_partner\")\n            except Exception as e:\n                _logger.warning(\"Partner #%i %r could not be deleted. Original request from %r. Related error: %s\",\n                             partner.id, user_name, requester_name, e)\n                self.env.cr.execute(\"ROLLBACK TO SAVEPOINT delete_partner\")\n            # make sure we never rollback the work we've done, this can take a long time\n            if auto_commit:\n                self.env.cr.commit()\n        if len(todo_requests) > batch_size:\n            self.env.ref(\"base.ir_cron_res_users_deletion\")._trigger()",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [],
      "accessRules": [
        {
          "name": "_gc_portal_users (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ResUsersDeletion"
    },
    {
      "name": "res.users.settings",
      "description": "User Settings",
      "fields": [
        {
          "name": "user_id",
          "type": "Many2one",
          "relation": "res.users",
          "required": true,
          "readonly": true,
          "string": "User"
        }
      ],
      "methods": [
        {
          "name": "_find_or_create_for_user",
          "params": [
            "self",
            "user"
          ],
          "decorators": [],
          "source": "def _find_or_create_for_user(self, user):\n        settings = user.sudo().res_users_settings_ids\n        if not settings:\n            settings = self.sudo().create({'user_id': user.id})\n        return settings",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_res_users_settings_format",
          "params": [
            "self",
            "fields_to_format=None"
          ],
          "decorators": [],
          "source": "def _res_users_settings_format(self, fields_to_format=None):\n        self.ensure_one()\n        if not fields_to_format:\n            fields_to_format = [name for name, field in self._fields.items() if name == 'id' or not field.automatic]\n        res = self._format_settings(fields_to_format)\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "_format_settings",
          "params": [
            "self",
            "fields_to_format"
          ],
          "decorators": [],
          "source": "def _format_settings(self, fields_to_format):\n        res = self._read_format(fnames=fields_to_format)[0]\n        if 'user_id' in fields_to_format:\n            res = self._read_format(fnames=fields_to_format)[0]\n            res['user_id'] = {'id': self.user_id.id}\n        return res",
          "isPrivate": true,
          "isStatic": false,
          "isDecorated": false
        },
        {
          "name": "set_res_users_settings",
          "params": [
            "self",
            "new_settings"
          ],
          "decorators": [],
          "source": "def set_res_users_settings(self, new_settings):\n        self.ensure_one()\n        changed_settings = {}\n        for setting in new_settings.keys():\n            if setting in self._fields and new_settings[setting] != self[setting]:\n                changed_settings[setting] = new_settings[setting]\n        self.write(changed_settings)\n        formated = self._res_users_settings_format([*changed_settings.keys(), 'id'])\n        return formated",
          "isPrivate": false,
          "isStatic": false,
          "isDecorated": false
        }
      ],
      "inheritance": [],
      "constraints": [
        {
          "type": "sql",
          "name": "unique_user_id",
          "definition": "UNIQUE(user_id)",
          "message": "One user should only have one user settings."
        }
      ],
      "accessRules": [
        {
          "name": "_find_or_create_for_user (model)",
          "permissions": {
            "read": true,
            "write": false,
            "create": false,
            "unlink": false
          },
          "source": "python"
        }
      ],
      "className": "ResUsersSettings"
    }
  ],
  "views": [],
  "originalFileName": "base.zip"
}